---
title: Message reactions
meta_description: "React to chat messages"
---

<Aside data-type='experimental'>
The message reactions feature is currently Experimental. It is still in development and subject to rapid change.
</Aside>

Add, remove and display message reactions in a chat room. Users can react to messages, typically with emojis but can be any string, and others can see the reactions to the message. Message reactions can be added and removed and a summary of the reactions is persisted with the message.

The reaction `name` represents the reaction itself, for example an emoji. Reactions are aggregated by `name` and the aggregation method including how many reactions a user can place for a message is controlled by the reaction `type`. The `count` is an optional parameter that can be set when adding a reaction of type `Multiple`.

The reaction `name` can be any string. Summaries are aggregated based on unique `name` values. UTF-8 emojis are a common use case, but any string can be used as long as they are consistent across all front-ends of your app. Examples of common reaction names are `üëç`, `‚ù§Ô∏è`, `:like:`, `like`, `+1`, and so on. How those are presented to the user is entirely up to the app.

## Types of message reactions <a id="types-of-reactions"/>

Ably Chat supports three types of message reactions. They differ in how they are aggregated and what are the rules for adding and removing them.

| Type | Description | Example | Similar to |
| ---- | ----------- | ------- | --------- |
| `Unique` | Users can add a single reaction per message. If they react again, their previous reaction is replaced with the new one. | A user can add a üëç, but adding a ‚ù§Ô∏è will replace the üëç. | iMessage, WhatsApp, Facebook Messenger |
| `Distinct` | Users can add each type of reaction once per message. Multiple different reactions are allowed, but duplicates are not. | A user can add both üëç and ‚ù§Ô∏è, but cannot add a second üëç. | Slack |
| `Multiple` | Users can add unlimited reactions, including duplicates. A count parameter specifies how many reactions to add at once. Each new reaction adds to the total count. | A user can add 10 üëç reactions and 100 ‚ù§Ô∏è reactions to the same message. | Claps on Medium |

Note that if adding two identical reactions of type `Distinct`, the second one will be accepted and broadcast as a raw reaction, but it will be ignored in the summary (aggregate). Similarly, when removing a reaction that doesn't exist (of any type), the operation will be accepted and broadcast as a raw reaction, but it will have no effect on the summary.

### Configure the default reaction type <a id="default-type"/>

The default reaction type can be configured at room-level using the Room Options. If nothing is set, the default is `Distinct`.

<Code>
```javascript
import { MessageReactionType } from '@ably/chat';

const room = await ablyChatClient.rooms.get('room1', {
    messages: {
        defaultMessageReactionType: MessageReactionType.Unique,
    },
});
```

```swift
let room = try await ablyChatClient.rooms.get(
    name: "room1",
    options: .init(
        messages: .init(defaultMessageReactionType: .unique)
    )
)
```

```kotlin
val room = ablyChatClient.rooms.get("room1") {
    messages {
        defaultMessageReactionType = MessageReactionType.Unique
    }
}
```

```react
import { MessageReactionType } from '@ably/chat';
import { ChatRoomProvider } from '@ably/chat/react';

const MyComponent = () => {
  const roomOptions = {
    messages: {
      defaultMessageReactionType: MessageReactionType.Unique,
    },
  };

  return (
    <ChatRoomProvider name="room1" options={roomOptions}>
      <RoomContent />
    </ChatRoomProvider>
  );
};
```
</Code>

## Adding a message reaction <a id="adding-reactions"/>

<If lang="javascript,swift,kotlin">
To add a message reaction use `room.messages.reactions.send(message, params)`. This method takes the following parameters:
* `message` - The message to add the reaction to. This can be a Message object, or just the string serial.
* `params` - Set the `name`, and optionally override the `type` or set a `count`.
</If>

<If lang="react">
Use the [`sendReaction()`](https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat-react.UseMessagesResponse.html#sendReaction) method available from the response of the `useMessages` hook to add a reaction to a message. This method takes the following parameters:
* `message` - The message to add the reaction to. This can be a Message object, or just the string serial.
* `params` - Set the `name`, and optionally override the `type` or set a `count`.
</If>

<Code>
```javascript
import { MessageReactionType } from '@ably/chat';

// Add a üëç reaction using the default type
await room.messages.reactions.send(message, { name: 'üëç' });

// The reaction can be anything, not just UTF-8 emojis:
await room.messages.reactions.send(message, { name: ':like:' });
await room.messages.reactions.send(message, { name: '+1' });

// Add a :love: reaction using the Unique type
await room.messages.reactions.send(message, {
    name: ':love:',
    type: MessageReactionType.Unique,
});

// Add a ‚ù§Ô∏è reaction with count 100 using the Multiple type
await room.messages.reactions.send(message, {
    name: '‚ù§Ô∏è',
    type: MessageReactionType.Multiple,
    count: 100,
});
```

```swift
// Add a üëç reaction using the default type
await room.messages.reactions.send(to: message.serial, params: .init(name: "üëç"))

// The reaction can be anything, not just UTF-8 emojis:
await room.messages.reactions.send(to: message.serial, params: .init(name: ":like:"))
await room.messages.reactions.send(to: message.serial, params: .init(name: "+1"))

// Add a :love: reaction using the Unique type
await room.messages.reactions.send(to: message.serial, params: .init(
  reaction: ":love:",
  type: .unique
))

// Add a ‚ù§Ô∏è reaction with count 100 using the Multiple type
await room.messages.reactions.send(to: message.serial, params: .init(
  reaction: "‚ù§Ô∏è",
  type: .multiple,
  count: 100
))
```

```kotlin
// Add a üëç reaction using the default type
room.messages.reactions.send(message, name = "üëç")

// The reaction can be anything, not just UTF-8 emojis:
room.messages.reactions.send(message, name = ":like:"))
room.messages.reactions.send(message, name = "+1"))

// Add a :love: reaction using the Unique type
room.messages.reactions.send(message,
  name = ":love:",
  type = MessageReactionType.Unique,
)

// Add a ‚ù§Ô∏è reaction with count 100 using the Multiple type
room.messages.reactions.send(message,
  name = "‚ù§Ô∏è",
  type = MessageReactionType.Multiple,
  count = 100,
)
```

```react
import { MessageReactionType } from '@ably/chat';
import { useMessages } from '@ably/chat/react';

const MyComponent = () => {
  const { addReaction } = useMessages();

  const handleAddReaction = async (message) => {
    try {
      // Add a üëç reaction using the default type
      await addReaction(message, { name: 'üëç' });

      // The reaction can be anything, not just UTF-8 emojis:
      await addReaction(message, { name: ':like:' });
      await addReaction(message, { name: '+1' });

      // Add a :love: reaction using the Unique type
      await addReaction(message, {
        name: ':love:',
        type: MessageReactionType.Unique,
      });

      // Add a ‚ù§Ô∏è reaction with count 100 using the Multiple type
      await addReaction(message, {
        name: '‚ù§Ô∏è',
        type: MessageReactionType.Multiple,
        count: 100,
      });
    } catch (error) {
      console.error('Error adding reaction:', error);
    }
  };

  return (
    <div>
      <button onClick={() => handleAddReaction(message)}>Add Reaction</button>
    </div>
  );
};
```
</Code>

<Aside data-type='note'>
The `annotation-publish` capability is required for adding reactions.
</Aside>

## Removing a message reaction <a id="removing-reactions"/>

<If lang="javascript,swift,kotlin">
To remove a message reaction use `room.messages.reactions.delete(message, params)`. This method takes the following parameters:
* `message` - The message to remove the reaction from. It can also be an object of format `{serial: "message serial"}`.
* `params` - Set the `name`, and optionally override the `type` or set a `count`.
</If>

<If lang="react">
Use the [`deleteReaction()`](https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat-react.UseMessagesResponse.html#deleteReaction) method available from the response of the `useMessages` hook to remove a reaction from a message. This method takes the following parameters:
* `message` - The message to remove the reaction from. It can also be an object of format `{serial: "message serial"}`.
* `params` - Set the `name`, and optionally override the `type` or set a `count`.
</If>

<Code>
```javascript
// Remove a üëç reaction using the default type
await room.messages.reactions.delete(message, { name: 'üëç' });

// Remove a :love: reaction using the Unique type
await room.messages.reactions.delete(message, {
    name: ':love:',
    type: MessageReactionType.Unique,
});

// Remove a ‚ù§Ô∏è reaction with count 50 using the Multiple type
await room.messages.reactions.delete(message, {
    name: '‚ù§Ô∏è',
    type: MessageReactionType.Multiple,
    count: 50,
});
```

```react
import { MessageReactionType } from '@ably/chat';
import { useMessages } from '@ably/chat/react';

const MyComponent = () => {
  const { deleteReaction } = useMessages();

  const handleRemoveReaction = async (message) => {
    try {
      // Remove a üëç reaction using the default type
      await deleteReaction(message, { name: 'üëç' });

      // Remove a :love: reaction using the Unique type
      await deleteReaction(message, {
        name: ':love:',
        type: MessageReactionType.Unique,
      });

      // Remove a ‚ù§Ô∏è reaction with count 50 using the Multiple type
      await deleteReaction(message, {
        name: '‚ù§Ô∏è',
        type: MessageReactionType.Multiple,
        count: 50,
      });
    } catch (error) {
      console.error('Error removing reaction:', error);
    }
  };

  return (
    <div>
      <button onClick={() => handleRemoveReaction(message)}>Remove Reaction</button>
    </div>
  );
};
```
</Code>

## Messages and reactions <a id="messages-and-reactions"/>

The `Message` object contains a `reactions` property which is an object that looks like this:

<Code>
```javascript
interface Message {
    // ... (other fields omitted)
    reactions: {
        unique: Ably.SummaryUniqueValues,
        distinct: Ably.SummaryDistinctValues,
        multiple: Ably.SummaryMultipleValues,
    }
}

// example (in real use, it is unlikely that all reaction types are present):
{
    // ... other message fields omitted
    reactions: {
        unique: {
            'üëç': { total: 2, clientIds: ['clientA', 'clientB'] },
            '‚ù§Ô∏è': { total: 1, clientIds: ['clientC'] },
        },
        distinct: {
            'üëç': { total: 2, clientIds: ['clientA', 'clientB'] },
            '‚ù§Ô∏è': { total: 1, clientIds: ['clientA'] },
        },
        multiple: {
            'üëç': { total: 10, clientIds: {'clientA': 7, 'clientB': 3} },
            '‚ù§Ô∏è': { total: 100, clientIds: {'clientA': 100} },
        },
    }
}
```

```react
interface Message {
    // ... (other fields omitted)
    reactions: {
        unique: Ably.SummaryUniqueValues,
        distinct: Ably.SummaryDistinctValues,
        multiple: Ably.SummaryMultipleValues,
    }
}

// example (in real use, it is unlikely that all reaction types are present):
{
    // ... other message fields omitted
    reactions: {
        unique: {
            'üëç': { total: 2, clientIds: ['clientA', 'clientB'] },
            '‚ù§Ô∏è': { total: 1, clientIds: ['clientC'] },
        },
        distinct: {
            'üëç': { total: 2, clientIds: ['clientA', 'clientB'] },
            '‚ù§Ô∏è': { total: 1, clientIds: ['clientA'] },
        },
        multiple: {
            'üëç': { total: 10, clientIds: {'clientA': 7, 'clientB': 3} },
            '‚ù§Ô∏è': { total: 100, clientIds: {'clientA': 100} },
        },
    }
}
```
</Code>

All reaction types are always available via `Message.reactions`, regardless of the default reaction type configured via room options.

The `Message.reactions` property is populated when fetching messages from history through `historyBeforeSubscribe()` or `room.messages.history()`. It is **not** populated when receiving message events such as `ChatMessageEventType.Created`, `ChatMessageEventType.Updated`, or `ChatMessageEventType.Deleted` from the realtime channel.

Always call `Message.with(event)` when applying message events and reaction events to existing messages to ensure that reactions are correctly copied or updated. **Do not** replace existing messages with messages received from events as reactions will be lost.


## Subscribing to message reactions <a id="subscribe"/>

<If lang="javascript,swift,kotlin">
Ably generates a summary (aggregate) of the reactions for each message and for each reaction type. For displaying accurate counts for message reactions, subscribe to changes in the message summary.
</If>

<If lang="react">
Subscribe to message reactions with the [`useMessages`](https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/functions/chat-react.useMessages.html) hook. Supply a `reactionsListener` to receive message reaction summary events. Ably generates a summary (aggregate) of the reactions for each message and for each reaction type. For displaying accurate counts for message reactions, subscribe to changes in the message summary.
</If>

<Code>
```javascript
room.messages.reactions.subscribe((event) => {
    console.log("received reactions summary event", event);
});
```

```swift
room.messages.reactions.subscribe { event in
    print("received reactions summary event: \(event)")
}
```

```kotlin
room.messages.reactions.subscribe { event ->
    println("received reactions summary event: $event")
}
```

```react
import { useMessages } from '@ably/chat/react';

const MyComponent = () => {
  useMessages({
    reactionsListener: (event) => {
      console.log("received reactions summary event", event);
    },
  });

  return <div>...</div>;
};
```
</Code>

The event is of type `reaction.summary`. `event.summary` is the received reactions summary and contains the following properties:

| Property | Description | Example |
| -------- | ----------- | ------- |
| `messageSerial` | Serial of the message this summary is for. | `01826232498871-001&#64;abcdefghij:001` |
| `unique` | Unique reactions summary. | `{ "üëç": { total: 2, clientIds: ["a", "b"]} }` |
| `distinct` | Distinct reactions summary. | `{ "üëç": { total: 2, clientIds: ["a", "b"]} }` |
| `multiple` | Multiple reactions summary. | `{ "üëç": { total: 5, clientIds: {"a": 2, "b": 3} }` |

Message reaction summary events can be used with `Message.with(event)` to get an updated message object, with the reactions applied correctly. Similarly, when calling `Message.with()` with other message events (for example `ChatMessageEventType.Updated`), the reactions summary will be correctly preserved in the resulting message object.

Example usage:

<Code>
```javascript
// init messages, in practice this should be updated with a message subscription
let messages = await room.messages.history({limit: 50});

// subscribe to message reactions summary events
room.messages.reactions.subscribe((event) => {
    // find the relevant message (in practice: use binary search or a map for lookups)
    const idx = messages.findLastIndex((msg) => msg.serial === event.summary.messageSerial);
    if (idx === -1) {
        // not found
        return;
    }
    // update message
    messages[idx] = messages[idx].with(event);
});
```

```swift
// init messages, in practice this should be updated with a message subscription
var messages = (await room.messages.history(options: .init(limit: 50))).items

// subscribe to message reactions summary events
room.messages.reactions.subscribe { event in
    if let idx = messages.lastIndex(where: { $0.serial == event.summary.messageSerial }) {
        messages[idx] = messages[idx].with(summaryEvent: event)
    }
}
```

```kotlin
// init messages, in practice this should be updated with a message subscription
val messages = room.messages.history(limit = 50).items.toMutableList()

// subscribe to message reactions summary events
room.messages.reactions.subscribe { event ->
    // find the relevant message (in practice: use binary search or a map for lookups)
    val idx = messages.indexOfLast { msg -> msg.serial == event.summary.messageSerial }
    if (idx != -1) {
        // update message
        messages[idx] = messages[idx].with(event)
    }
}
```

```react
import { useState, useEffect } from 'react';
import { useMessages, Message } from '@ably/chat/react';

const MyComponent = () => {
  const [messages, setMessages] = useState<Message[]>([]);

  const { get } = useMessages({
    reactionsListener: (event) => {
      // find the relevant message (in practice: use binary search or a map for lookups)
      setMessages((prevMessages) => {
        const idx = prevMessages.findLastIndex((msg) => msg.serial === event.summary.messageSerial);
        if (idx === -1) {
          // not found
          return prevMessages;
        }
        // update message
        const updatedMessages = [...prevMessages];
        updatedMessages[idx] = updatedMessages[idx].with(event);
        return updatedMessages;
      });
    },
  });

  // Initialize messages on component mount
  useEffect(() => {
    const initMessages = async () => {
      try {
        const result = await get({ limit: 50 });
        setMessages(result.items);
      } catch (error) {
        console.error('Error fetching messages:', error);
      }
    };
    initMessages();
  }, [get]);

  return <div>...</div>;
};
```
</Code>

### Summary events are sent efficiently at scale <a id="throttle"/>

Summary events are typically created and published immediately after a reaction is added or removed. If the reaction is a no-op (for example, when removing a reaction that didn't exist), then there will be no summary event.

If multiple reactions are added in a short period of time, multiple reactions may be rolled up and only a single summary event will be published that contains the aggregated results of all reactions. This reduces the number of outbound messages and thus your costs in busy rooms.

### Subscribing to raw reactions <a id="raw-reactions"/>

<If lang="javascript,swift,kotlin">
Raw individual reactions are published for every reaction, unlike summaries which can be rolled up. Raw reactions are useful for receiving all reaction events, but they are not suitable for the purpose of displaying message reaction counts as their effect on the reactions summary depends on the previous reactions.

Individual reactions are not received by default to save bandwidth and to reduce the number of messages and cost. If you want to receive them, you can configure them via a room option which, in turn, sets the appropriate channel options to enable receiving individual annotations and reactions:
</If>

<If lang="react">
Raw individual reactions are published for every reaction, unlike summaries which can be rolled up. Raw reactions are useful for receiving all reaction events, but they are not suitable for the purpose of displaying message reaction counts as their effect on the reactions summary depends on the previous reactions.

Individual reactions are not received by default to save bandwidth and to reduce the number of messages and cost. If you want to receive them, you can configure them via a room option which, in turn, sets the appropriate channel options to enable receiving individual annotations and reactions:
</If>

<Code>
```javascript
const room = await ablyChatClient.rooms.get('room1', {
    messages: {
        rawMessageReactions: true,
    },
});
```

```swift
let room = try await ablyChatClient.rooms.get(
    name: "room1",
    options: .init(
        messages: .init(rawMessageReactions: true)
    )
)
```

```kotlin
val room = ablyChatClient.rooms.get("room1") {
    messages {
        rawMessageReactions = true
    }
}
```

```react
import { ChatRoomProvider } from '@ably/chat/react';

const MyComponent = () => {
  const roomOptions = {
    messages: {
      messages: {
        rawMessageReactions: true,
      },
    },
  };

  return (
    <ChatRoomProvider name="room1" options={roomOptions}>
      <RoomContent />
    </ChatRoomProvider>
  );
};
```
</Code>

<If lang="javascript,swift,kotlin">
Then you can receive raw reactions using the `room.messages.reactions.subscribeRaw()` method:
</If>

<If lang="react">
Then you can receive raw reactions using the `rawReactionsListener` parameter in the `useMessages` hook:
</If>

<Code>
```javascript
room.messages.reactions.subscribeRaw((event) => {
    if (event.type === MessageReactionEventType.Create) {
        console.log("new reaction", event.reaction);
    } else if (event.type === MessageReactionEventType.Delete) {
        console.log("reaction removed", event.reaction);
    }
});
```

```swift
room.messages.reactions.subscribeRaw { event in
    if (event.type == .create) {
        print("new reaction: \(event.reaction)")
    } else if (event.type == .delete) {
        print("reaction removed: \(event.reaction)")
    }
}
```

```kotlin
room.messages.reactions.subscribeRaw { event ->
    if (event.type == MessageReactionEventType.Create) {
        println("new reaction: ${event.reaction}")
    } else if (event.type == MessageReactionEventType.Delete) {
        println("reaction removed: ${event.reaction}")
    }
}
```

```react
import { MessageReactionEvents, useMessages } from '@ably/chat/react';

const MyComponent = () => {
  useMessages({
    rawReactionsListener: (event) => {
      if (event.type === MessageReactionEvents.Create) {
        console.log("new reaction", event.reaction);
      } else if (event.type === MessageReactionEvents.Delete) {
        console.log("reaction removed", event.reaction);
      }
    },
  });

  return <div>...</div>;
};
```
</Code>

<Aside data-type='note'>
The `annotation-subscribe` capability is required for receiving individual reactions, however it is not required to receive summaries.
</Aside>

You should be aware of the following limitations:

* Deleting a reaction succeeds even if it did not initially exist. It is a no-op in regards to the summary but the delete event is still broadcast.
* Adding a reaction succeeds and is broadcast, even if it has no effect on the summary (for example, when double-adding a reaction with the same name of type `Distinct` or `Unique`).
* Adding a reaction of type `Unique` may remove another reaction, but no delete event will be broadcast.
* It is not recommended to use raw reactions for displaying counts, instead use the summary events.
* Keeping a local summary updated based on raw reactions is not recommended as it may become out-of-sync with server-generated summaries.
