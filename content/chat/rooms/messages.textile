---
title: Messages
meta_description: "Send, update, delete, and receive messages in chat rooms."
product: chat
languages:
  - javascript
  - react
  - swift
  - kotlin
---

Send, update, delete, and receive messages in a chat room with any number of participants. Users subscribe to messages by registering a listener, and send messages to all users that are subscribed to receive them.
A user can also update or delete a message, all users that are subscribed to the room will be notified of the changes.

h2(#subscribe). Subscribe to messages

blang[javascript,swift,kotlin].
  Subscribe to receive messages in a room by registering a listener. Use the <span lang="javascript">"@messages.subscribe()@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat-js.Messages.html#subscribe</span><span lang="swift">"@messages.subscribe()@":https://sdk.ably.com/builds/ably/ably-chat-swift/main/AblyChat/documentation/ablychat/messages/subscribe%28%29-360z1</span><span lang="kotlin">"@messages.subscribe()@":https://sdk.ably.com/builds/ably/ably-chat-kotlin/main/dokka/chat-android/com.ably.chat/-messages/subscribe.html</span> method in a room to receive all messages that are sent to it:

blang[react].
    Subscribe to messages with the "@useMessages@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/functions/chat-react.useMessages.html hook. Supply a listener and the hook will automatically subscribe to message events sent to the room. As long as a defined value is provided, the subscription will persist across renders. If the listener value is undefined, the subscription will be removed until it becomes defined again.

    Providing a listener will also enable you to retrieve messages that have been "previously sent to the room.":/chat/rooms/history

```[javascript]
const {unsubscribe} = room.messages.subscribe((event) => {
  console.log(event.message);
});
```

```[react]
import { useState } from 'react';
import { useMessages } from '@ably/chat/react';

const MyComponent = () => {
  useMessages({
    listener: (event) => {
      console.log('Received message: ', event.message);
    },
  });

  return <div>...</div>;
};
```

```[swift]
let messagesSubscription = try await room.messages.subscribe()
for await message in messagesSubscription {
    print("Message received: \(message)")
}
```

```[kotlin]
val subscription = room.messages.subscribe { message: Message ->
    println(message.toString())
}
```

h3(#structure). Message structure

The following is the structure of a message:

```[json]
{
  "serial": "01826232498871-001@abcdefghij:001",
  "clientId": "basketLover014",
  "roomId": "basketball-stream",
  "text": "What a shot!",
  "headers": {},
  "metadata": {},
  "createdAt": new Date("2024-06-12T11:37:59.988Z"),
  "action": "message.create",
  "version": "01826232498871-001@abcdefghij:001",
  "timestamp": new Date("2024-06-12T11:37:59.988Z"),
  "operation": {},
}
```

The following are the properties of a message:

|_. Property |_. Description |_. Type |
| serial | An Ably-generated ID used to uniquely identify the message. By comparing it to others it provides a deterministic global ordering of messages. | String |
| clientId | The client identifier of the user that created the message. | String |
| roomId | The name of the room the message was created in. | String |
| text | The message contents. | String |
| headers | Optional headers for adding additional information to a message, such as the relative timestamp of a livestream video, or flagging a message as important. Do not use the headers for authoritative information. There is no server-side validation. When reading headers treat them like user input. | Object |
| metadata | Optional additional metadata about the message, such as animations, effects or links to other resources such as images. This information is not read by Ably. Do not use metadata for authoritative information. There is no server-side validation. When reading metadata treat it like user input. | Object |
| createdAt | The time the message was created. | Date |
| action | The latest action performed on this message, such as @message.create@, @message.update@ or @message.delete@.  | String |
| version | An Ably-generated ID used to uniquely identify the version of the message. It provides a deterministic global ordering of message versions. The @version@ is identical to @serial@ if the action is @message.create@.  | String |
| timestamp | The time the action was performed. It will be identical to @createdAt@ if the action is a @message.create@. | Date |
| operation | For updates and deletions, this provides additional details about the action. It may contain the following properties: | Object or undefined |
| | clientId: The client identifier of the user associated with the action. | String or undefined |
| | description: Optional description for the action. | String or undefined |
| | metadata: Optional additional metadata about the action. | Object or undefined |

<aside data-type="note">
<p>Both @serial@ and @version@ are lexicographically sortable strings. This means they can be used to enforce a deterministic global ordering based on string comparison.</p>
 <p><strong>Global Ordering Rules:</strong></p>
  <p>For message @serial@: If the @serial@ of one message occurs before another when lexicographically sorted, the first message is considered to have occurred globally before the other. If the @serial@ values are identical, the two messages are considered to be the same message.</p>
  <p>For @version@: When two messages share the same @serial@, their respective @version@ values can be used to determine the order of actions applied to the message.</p>
  <p>An action (such as an update) with a @version@ is considered to have occurred before some other action, if the first action's @version@ occurs before another when sorted lexicographically. If the @version@ values are identical, the actions are considered to be the same.</p>
</aside>

h3(#unsubscribe). Unsubscribe from messages

blang[javascript].
  Use the @unsubscribe()@ function returned in the @subscribe()@ response to remove a chat message listener:

blang[swift].
  You don't need to handle removing listeners, as this is done automatically by the SDK.

blang[kotlin].
  Use the @unsubscribe()@ method on the returned subscription to remove a chat message listener:

blang[react].
  When you unmount the component that is using the @useMessages@ hook, it will automatically handle unsubscribing any associated listeners registered to receive messages.

blang[javascript,kotlin].
  ```[javascript]
  // Initial subscription
  const { unsubscribe } = room.messages.subscribe((event) => console.log(event.message));

  // To remove the listener
  unsubscribe();
  ```

  ```[kotlin]
  subscription.unsubscribe()
  ```

blang[react,swift].

blang[javascript].
  Use the "@messages.unsubscribeAll()@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat-js.Messages.html#unsubscribeAll method to deregister all chat message listeners in a room:

  ```[javascript]
  await room.messages.unsubscribeAll();
  ```

blang[react,swift,kotlin].

blang[javascript].

  <aside data-type='note'>
  <p>There is a difference between unsubscribing from messages and detaching from a room that is important to understand. </p>
  <p>Messages are sent to users as soon as they "attach":/chat/rooms#attach to a room, irrespective of whether a listener has been registered by calling @subscribe()@. Calling @unsubscribe()@ only deregisters the listener.</p>
  <p>The "@detach()@":/chat/rooms#detach method detaches a user from the room. At that point a user will no longer receive any messages that are sent to the room.</p>
  </aside>

blang[react,swift,kotlin].

h2(#send). Send a message

blang[javascript,swift,kotlin].
  Use the <span lang="javascript">"@messages.send()@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat-js.Messages.html#send</span><span lang="swift">"@messages.send()@":https://sdk.ably.com/builds/ably/ably-chat-swift/main/AblyChat/documentation/ablychat/messages/send%28params%3A%29</span><span lang="kotlin">"@messages.send()@":https://sdk.ably.com/builds/ably/ably-chat-kotlin/main/dokka/chat-android/com.ably.chat/-messages/send.html</span> method to send a message in a chat room. All users that are "subscribed":#subscribe to messages on that room will receive it:

blang[react].
  Use the "@send()@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat-react.UseMessagesResponse.html#send method available from the response of the @useMessages@ hook to send a message to the room:

```[javascript]
await room.messages.send({text: 'hello'});
```

```[react]
import { useMessages } from '@ably/chat/react';

const MyComponent = () => {
  const { send } = useMessages();

  const handleMessageSend = () => {
    send({ text: 'Hello, World!' });
  };

  return (
    <div>
      <button onClick={handleMessageSend}>Send Message</button>
    </div>
  );
};
```

```[swift]
let message = try await room.messages.send(params: .init(text: "hello"))
```

```[kotlin]
room.messages.send(text = "hello")
```

h2(#update). Update a message

<aside data-type='new'>
<p>Message updates were added in version 0.3. They are only available in the JavaScript and React SDKs.</p>
</aside>

blang[javascript].
  Use the "@messages.update()@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat_js.Messages.html#update method to update a message in a chat room. All users that are "subscribed":#subscribe to messages on that room will receive the update:

blang[react].
  Use the "@update()@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat_react.UseMessagesResponse.html#update method available from the response of the @useMessages@ hook to update a message in the room:

```[javascript]
import { Message } from '@ably/chat';
const messageToUpdate: Message
await room.messages.update(messageToUpdate, { text: "my updated text" }, { description: "Message update by user" });
```

```[react]
import { useMessages } from '@ably/chat/react';
import { Message } from '@ably/chat';

const MyComponent = () => {
  const { update } = useMessages();
  const [message, setMessage] = useState<Message>();

  const handleMessageUpdate = (msg: Message) => {
    update(msg, { text: "my updated text" }, { description: "Message update by user" })
    .then((updatedMsg: Message) => {
    console.log('Message updated:', updatedMsg);
    })
    .catch((error) => {
      console.error('Error updating message: ', error);
    });
  };
  return (
    <div>
      <button onClick={() => handleMessageUpdate(message)}>Update Message</button>
    </div>
  );
};
```

h3(#filter-updates). Filter for updates

blang[javascript].
  Use the "@messages.subscribe()@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat_js.Messages.html#subscribe method to receive messages in a room. To filter for updated messages, provide a listener that checks the @type@ property of the message event:

blang[react].
  Use the "@useMessages@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/functions/chat_react.useMessages.html hook to subscribe to messages in a room. To filter for updated messages, provide a listener that checks the @type@ property of the message event:

```[javascript]
import { MessageEvents } from '@ably/chat';
const {unsubscribe} = room.messages.subscribe((event) => {
  switch (event.type) {
    case MessageEvents.Created:
      console.log('Received message: ', event.message);
      break;
    case MessageEvents.Updated:
      console.log('Message updated: ', event.message);
      break;
    default:
      break;
  }
});
```

```[react]
import { useMessages } from '@ably/chat/react';
import { MessageEvents } from '@ably/chat';

const MyComponent = () => {
  useMessages({
    listener: (event) => {
      switch (event.type) {
        case MessageEvents.Created:
          console.log('Received message: ', event.message);
          break;
        case MessageEvents.Updated:
          console.log('Message updated: ', event.message);
          break;
        default:
          break;
      }
    },
  });

  return <div>...</div>;
};
```

On rare occasions updates might arrive from the server out of order (in terms of the global order in which these events occur). An example of this is when messages are transiting between regions, and latencies between nearby regions is lower than those further away. To deterministically determine whether an update should supersede the current version, simply compare the @version@ strings using the standard string comparison operators. Alternatively, the @Message@ interface provides convenience methods to compare two instances of the same base message to determine which version is newer: @versionBefore()@, @versionAfter()@, and @versionEqual()@.

The same out-of-order situation can happen between updates received over realtime and HTTP responses (e.g. when updating a message). In the situation where two concurrent updates happen, both might be received via realtime before the HTTP response of the first one arrives. Always compare the message @version@ to determine which instance of a @Message@ is newer.

h3(#update-structure). Message update structure

The following is the structure of an updated message:

```[json]
{
  "serial": "01726232498871-001@abcdefghij:001",
  "clientId": "basketLover014",
  "roomId": "basketball-stream",
  "text": "What a shot! Edit: I meant to say 'What a dunk!'",
  "headers": {},
  "metadata": {},
  "createdAt": new Date("2024-06-12T11:37:59.988Z")S,
  "action": "message.update",
  "version": "01826232498871-001@abcdefghij:001",
  "timestamp": new Date("2024-11-21T15:49:25.425Z"),
  "operation": {
    "clientId": "basketLover014",
    "description": "Message updated by client",
    "metadata": {}
  },
}
```

The updated message response is identical to the structure of a message, with the following differences:

|_. Property |_. Description |
| action | Set to @message.update@. |
| version | Set to the serial of the update action. |
| timestamp | Set to the time the message was updated. |
| operation | Set to the details the actioning client provided in the request. |

h2(#delete). Delete a message

<aside data-type='new'>
<p>Message deletion was added in version 0.3. It is only available in the JavaScript and React SDKs.</p>
</aside>

blang[javascript].
  Use the "@messages.delete()@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat_js.Messages.html#delete method to delete a message in a chat room. All users that are "subscribed":#subscribe to messages on that room will receive the deletion:

blang[react].
  Use the "@deleteMessage()@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat_react.UseMessagesResponse.html#deleteMessage method available from the response of the @useMessages@ hook to delete a message from the room:

```[javascript]
import { Message } from '@ably/chat';
const messageToDelete: Message
await room.messages.delete(messageToDelete, { description: 'Message deleted by user' });
```

```[react]
import { useMessages } from '@ably/chat/react';
import { Message } from '@ably/chat';

const MyComponent = () => {
  const { deleteMessage } = useMessages();
  const [message, setMessage] = useState<Message>();

  const handleMessageDelete = (msg: Message) => {
    deleteMessage(msg, { description: 'Message deleted by user' })
    .then((deletedMessage: Message) => {
      console.log('Message deleted:', deletedMessage);
    })
    .catch((error) => {
      console.error('Error deleting message: ', error);
    });
  };

  return (
    <div>
      <button onClick={() => handleMessageDelete(message)}>Delete Message</button>
    </div>
  );
};
```

h3(#filter-deletes). Filter for deletes

blang[javascript].
  Use the "@messages.subscribe()@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/interfaces/chat_js.Messages.html#subscribe method to receive messages in a room. To filter for deleted messages, provide a listener that checks the @type@ property of the message event:

blang[react].
  Use the "@useMessages@":https://sdk.ably.com/builds/ably/ably-chat-js/main/typedoc/functions/chat_react.useMessages.html hook to subscribe to messages in a room. To filter for deleted messages, provide a listener that checks the @type@ property of the message event:

```[javascript]
import { MessageEvents } from '@ably/chat';
const {unsubscribe} = room.messages.subscribe((event) => {
  switch (event.type) {
    case MessageEvents.Created:
      console.log('Received message: ', event.message);
      break;
    case MessageEvents.Deleted:
      console.log('Message deleted: ', event.message);
      break;
    default:
      break;
  }
});
```

```[react]
import { useMessages } from '@ably/chat/react';
import { MessageEvents } from '@ably/chat';

const MyComponent = () => {
  useMessages({
    listener: (event) => {
      switch (event.type) {
        case MessageEvents.Created:
          console.log('Received message: ', event.message);
          break;
        case MessageEvents.Deleted:
          console.log('Message deleted: ', event.message);
          break;
        default:
          break;
      }
    },
  });

  return <div>...</div>;
};
```

On rare occasions, deletes and updates might arrive over realtime out of order. Again, should two concurrent actions happen in disparate regions, you will likely receive the action processed in the region closest to you first, for example.

When the second action arrives, you will need to determine the order of these actions; this is done deterministically by comparing the @version@ field of the messages, using the standard string comparison operators. For convenience, the @Message@ interface provides methods to compare two instances of the same base message to determine which action is newer: @versionBefore()@, @versionAfter()@, and @versionEqual()@.

The same out-of-order situation can happen between deletions received over realtime and HTTP responses, whereby both might be received via realtime before the HTTP response of the first one arrives.

h3(#deletion-structure). Message deletion structure

The following is the structure of a deleted message:

```[json]
{
  "serial": "01726232498871-001@abcdefghij:001",
  "clientId": "basketLover014",
  "roomId": "basketball-stream",
  "text": "What a shot!",
  "headers": {},
  "metadata": {},
  "createdAt": new Date("2024-06-12T11:37:59.988Z"),
  "action": "message.delete",
  "version": "01826232498871-001@abcdefghij:001",
  "timestamp": new Date("2024-11-21T15:49:25.425Z"),
  "operation": {
    "clientId": "basketLover014",
    "description": "Message deleted by client",
    "metadata": {}
  },
}
```

The deleted message response is identical to the structure of a message, with the following differences:

|_. Property |_. Description |
| action | Set to @message.delete@. |
| version | Set to the serial of the deletion action. |
| timestamp | Set to the time the message was deleted. |
| operation | Set to the details the actioning client provided in the request. |
