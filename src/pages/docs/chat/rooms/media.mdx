---
title: "Share media"
meta_description: "Share media such as images, videos, or files in a chat room."
meta_keywords: "image, file, media, sharing, Ably Chat, chat SDK, realtime messaging, dependability, cost optimization"
---

Share media such as images, videos and files with users in a chat room.

Upload the media to your own storage service, such as AWS S3, and then use the `metadata` field to reference the location of the media when a user [sends a message](/docs/chat/rooms/messages#send). On the receiving end, display the media to [subscribers](/docs/chat/rooms/messages#subscribe) that received the message.

## Access control

Ensure that you add a layer of authentication server-side if the media shouldn't be publicly available.

Do not add signed URLs to the message `metadata` because everyone who receives the message will have access to it. Additionally, signed URLs typically have expiration dates and chat messages may be stored for longer.

If you serve the media directly from a service, such as AWS S3, consider saving a file name in the `metadata` of the message. Then use a mechanism for the user to request a signed URL to the file.

## Upload media <a id="upload"/>

Users need to be able to choose which media to attach to their message in your app. Write an upload function and make it available in the chat app context.

You can use either a unique identifier for the media, or a URL to its location. Ensure that any identifier is unique and that URLs are validated when they are received.

The following is an example of an upload function:

<Code>
```javascript
async function uploadMedia() {
  // ask the user to choose their media
  // upload the media to your storage service
  // return a unique identifier for the media

  // mock implementation:
  let mediaId = 'abcd123abcd';

  // Some media metadata, useful for displaying the media in the UI
  let title = 'A beautiful image';
  let width = 1024;
  let height = 768;

  // Return the object
  return { id: mediaId, title, width, height };
}
```
</Code>

Use the `uploadMedia()` flow to save the resulting object. In your UI, the `mediaToAttach` array should be displayed so that users can see which which media will be attached to their message. It also enables users to add or remove selected media.

<Code>
```javascript
let mediaToAttach = [];
async function onMediaAttach() {
  const mediaData = await uploadMedia();
  mediaToAttach.push(mediaData);
}
```

```react
import { useState } from 'react';

const ChatComponent = () => {
  const [mediaToAttach, setMediaToAttach] = useState([]);

  const onMediaAttach = async () => {
    const mediaData = await uploadMedia();
    setMediaToAttach(prev => [...prev, mediaData]);
  };

  return (
    <div>
      <button onClick={onMediaAttach}>Attach Media</button>
      {mediaToAttach.map((mediaData, index) => (
        <div key={mediaData.id}>Media to attach: {mediaData.id} ({mediaData.title}, {mediaData.width}x{mediaData.height})</div>
      ))}
    </div>
  );
};
```

```swift
struct MediaData {
    let id: String
    let title: String
    let width: Int
    let height: Int
}

class ChatViewController {
    var mediaToAttach: [MediaData] = []

    func onMediaAttach() async {
        let mediaData = await uploadMedia()
        mediaToAttach.append(mediaData)
    }
}
```

```kotlin
data class MediaData(
    val id: String,
    val title: String,
    val width: Int,
    val height: Int
)

var mediaToAttach = mutableListOf<MediaData>()

suspend fun onMediaAttach() {
    val mediaData = uploadMedia()
    mediaToAttach.add(mediaData)
}
```

```jetpack
import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import kotlinx.coroutines.launch

data class MediaData(
    val id: String,
    val title: String,
    val width: Int,
    val height: Int
)

@Composable
fun MediaAttachmentComponent() {
    var mediaToAttach by remember { mutableStateOf<List<MediaData>>(emptyList()) }
    val coroutineScope = rememberCoroutineScope()

    Column {
        Button(onClick = {
            coroutineScope.launch {
                val mediaData = uploadMedia()
                mediaToAttach = mediaToAttach + mediaData
            }
        }) {
            Text("Attach Media")
        }

        mediaToAttach.forEach { mediaData ->
            Text("Media to attach: ${mediaData.id} (${mediaData.title}, ${mediaData.width}x${mediaData.height})")
        }
    }
}
```
</Code>

## Send a message <a id="send"/>

Once a user has ['attached'](#upload) their media to the message, use the `metadata` field of the message to store its reference. `metadata` is a key-value object that can also be used to associate additional information such as its title and dimensions.

<Code>
```javascript
async function send(text) {
  let metadata = {};
  if (mediaToAttach.length > 0) {
    metadata["media"] = mediaToAttach;
    mediaToAttach = [];
  }
  await room.messages.send({
    text: text,
    metadata: metadata
  });
}
```

```react
import { useState } from 'react';
import { useMessages } from '@ably/chat/react';

const MessageSender = () => {
  const [mediaToAttach, setMediaToAttach] = useState([]);
  const [messageText, setMessageText] = useState('');
  const { send } = useMessages();

  const handleSend = async () => {
    let metadata = {};
    if (mediaToAttach.length > 0) {
      metadata["media"] = mediaToAttach;
    }
    await send({
      text: messageText,
      metadata: metadata
    });
    setMediaToAttach([]);
    setMessageText('');
  };

  const onMediaAttach = async () => {
    const mediaId = await uploadMedia();
    setMediaToAttach(prev => [...prev, mediaId]);
  };

  return (
    <div>
      <input
        type="text"
        value={messageText}
        onChange={(e) => setMessageText(e.target.value)}
        placeholder="Type a message..."
      />
      <button onClick={onMediaAttach}>Attach Media</button>
      <button onClick={handleSend}>Send</button>
      {mediaToAttach.map((mediaData, index) => (
        <div key={index}>Media to attach: {mediaData.id} ({mediaData.title}, {mediaData.width}x{mediaData.height})</div>
      ))}
    </div>
  );
};
```

```swift
func send(text: String, mediaToAttach: [MediaData]) async throws {
    var metadata: MessageMetadata = [:]
    if !mediaToAttach.isEmpty {
        let mediaArray: [JSONValue] = mediaToAttach.map { media in
            .object([
                "id": .string(media.id),
                "title": .string(media.title),
                "width": .number(Double(media.width)),
                "height": .number(Double(media.height))
            ])
        }
        metadata["media"] = .array(mediaArray)
    }

    try await room.messages.send(params: .init(
        text: text,
        metadata: metadata
    ))
}
```

```kotlin
suspend fun send(text: String, mediaToAttach: List<MediaData>) {
    val metadata = if (mediaToAttach.isNotEmpty()) {
        buildJsonObject {
            put("media", buildJsonArray {
                mediaToAttach.forEach { media ->
                    add(buildJsonObject {
                        put("id", media.id)
                        put("title", media.title)
                        put("width", media.width)
                        put("height", media.height)
                    })
                }
            })
        }
    } else {
        null
    }

    room.messages.send(
        text = text,
        metadata = metadata
    )
}
```

```jetpack
import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import com.ably.chat.Room
import kotlinx.coroutines.launch
import kotlinx.serialization.json.buildJsonArray
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.put

@Composable
fun MessageSenderComponent(room: Room) {
    var mediaToAttach by remember { mutableStateOf<List<MediaData>>(emptyList()) }
    var messageText by remember { mutableStateOf("") }
    val coroutineScope = rememberCoroutineScope()

    Column {
        TextField(
            value = messageText,
            onValueChange = { messageText = it },
            placeholder = { Text("Type a message...") }
        )

        Button(onClick = {
            coroutineScope.launch {
                val mediaData = uploadMedia()
                mediaToAttach = mediaToAttach + mediaData
            }
        }) {
            Text("Attach Media")
        }

        Button(onClick = {
            coroutineScope.launch {
                val metadata = if (mediaToAttach.isNotEmpty()) {
                    buildJsonObject {
                        put("media", buildJsonArray {
                            mediaToAttach.forEach { media ->
                                add(buildJsonObject {
                                    put("id", media.id)
                                    put("title", media.title)
                                    put("width", media.width)
                                    put("height", media.height)
                                })
                            }
                        })
                    }
                } else null

                room.messages.send(
                    text = messageText,
                    metadata = metadata
                )

                mediaToAttach = emptyList()
                messageText = ""
            }
        }) {
            Text("Send")
        }

        mediaToAttach.forEach { mediaData ->
            Text("Media to attach: ${mediaData.id} (${mediaData.title}, ${mediaData.width}x${mediaData.height})")
        }
    }
}
```
</Code>

Be aware that message `metadata` is not validated by the server. Always treat it as untrusted user input.

## Display media to subscribers <a id="display"/>

When a message is received that contains media, you need to display it in your app.

Firstly, make sure that you validate the `metadata`. If you are using IDs then ensure they are in the correct format, or if using URLs then validate the schema, domain, path and query parameters are as expected.

Define a function to get the valid media from a message:

<Code>
```javascript
// assume IDs are 10-15 characters long and alphanumeric
const mediaIdRegex = /^[a-z0-9]{10,15}$/;

function getValidMedia(message) {
  if (message.metadata.media && message.metadata.media.length > 0) {
    return message.metadata.media.filter(mediaData => mediaIdRegex.test(mediaData.id));
  }
  return [];
}
```

```react
// assume IDs are 10-15 characters long and alphanumeric
const mediaIdRegex = /^[a-z0-9]{10,15}$/;

const getValidMedia = (message) => {
  if (message.metadata.media && message.metadata.media.length > 0) {
    return message.metadata.media.filter(mediaData => mediaIdRegex.test(mediaData.id));
  }
  return [];
};
```

```swift
import Foundation

// assume IDs are 10-15 characters long and alphanumeric
let mediaIdRegex = try! NSRegularExpression(pattern: "^[a-z0-9]{10,15}$")

func getValidMedia(message: Message) -> [MediaData] {
    guard case let .array(mediaArray) = message.metadata["media"] else {
        return []
    }

    return mediaArray.compactMap { mediaValue -> MediaData? in
        guard case let .object(mediaObj) = mediaValue,
              case let .string(id) = mediaObj["id"],
              case let .string(title) = mediaObj["title"],
              case let .number(width) = mediaObj["width"],
              case let .number(height) = mediaObj["height"] else {
            return nil
        }

        let range = NSRange(location: 0, length: id.utf16.count)
        guard mediaIdRegex.firstMatch(in: id, options: [], range: range) != nil else {
            return nil
        }

        return MediaData(id: id, title: title, width: Int(width), height: Int(height))
    }
}
```

```kotlin
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive

// assume IDs are 10-15 characters long and alphanumeric
val mediaIdRegex = Regex("^[a-z0-9]{10,15}$")

fun getValidMedia(message: Message): List<MediaData> {
    val mediaArray = message.metadata["media"]?.jsonArray ?: return emptyList()

    return mediaArray.mapNotNull { mediaValue ->
        val mediaObj = mediaValue.jsonObject
        val id = mediaObj["id"]?.jsonPrimitive?.content ?: return@mapNotNull null
        val title = mediaObj["title"]?.jsonPrimitive?.content ?: return@mapNotNull null
        val width = mediaObj["width"]?.jsonPrimitive?.content?.toIntOrNull() ?: return@mapNotNull null
        val height = mediaObj["height"]?.jsonPrimitive?.content?.toIntOrNull() ?: return@mapNotNull null

        if (mediaIdRegex.matches(id)) {
            MediaData(id, title, width, height)
        } else {
            null
        }
    }
}
```

```jetpack
import com.ably.chat.Message
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive

// assume IDs are 10-15 characters long and alphanumeric
val mediaIdRegex = Regex("^[a-z0-9]{10,15}$")

fun getValidMedia(message: Message): List<MediaData> {
    val mediaArray = message.metadata["media"]?.jsonArray ?: return emptyList()

    return mediaArray.mapNotNull { mediaValue ->
        val mediaObj = mediaValue.jsonObject
        val id = mediaObj["id"]?.jsonPrimitive?.content ?: return@mapNotNull null
        val title = mediaObj["title"]?.jsonPrimitive?.content ?: return@mapNotNull null
        val width = mediaObj["width"]?.jsonPrimitive?.content?.toIntOrNull() ?: return@mapNotNull null
        val height = mediaObj["height"]?.jsonPrimitive?.content?.toIntOrNull() ?: return@mapNotNull null

        if (mediaIdRegex.matches(id)) {
            MediaData(id, title, width, height)
        } else {
            null
        }
    }
}
```
</Code>

Use a function or component to display the message and its media:

<Code>
```javascript
function createMessageDOM(message) {
  const container = document.createElement("div");
  container.setAttribute('data-message-serial', message.serial)
  container.setAttribute('data-message-version', message.version.serial)

  const text = document.createElement("div");
  text.innerText = message.text;
  container.appendChild(text);
  const validMedia = getValidMedia(message);
  if (validMedia.length > 0) {
    const mediaContainer = document.createElement("div");
    for (let mediaData of validMedia) {
      const img = document.createElement("img");
      img.src = "https://example.com/images/"+mediaData.id;
      img.alt = mediaData.title;
      img.width = mediaData.width;
      img.height = mediaData.height;
      mediaContainer.appendChild(img);
    }
    container.appendChild(mediaContainer);
  }
  return container;
}
```

```react
const mediaIdRegex = /^[a-z0-9]{10,15}$/;

const getValidMedia = (message) => {
  if (message.metadata.media && message.metadata.media.length > 0) {
    return message.metadata.media.filter(mediaId => mediaIdRegex.test(mediaId));
  }
  return [];
};

const MessageDisplay = ({ message }) => {
  const validMedia = getValidMedia(message);

  return (
    <div>
      <div>{message.text}</div>
      {validMedia.length > 0 && (
        <div>
          {validMedia.map((media, index) => (
            <img
              key={media.id}
              src={`https://example.com/images/${media.id}`}
              alt={media.title}
              width={media.width}
              height={media.height}
            />
          ))}
        </div>
      )}
    </div>
  );
};
```

```swift
import UIKit

func createMessageView(message: Message) -> UIView {
    let container = UIStackView()
    container.axis = .vertical
    container.spacing = 8

    let textLabel = UILabel()
    textLabel.text = message.text
    container.addArrangedSubview(textLabel)

    let validMedia = getValidMedia(message: message)
    if !validMedia.isEmpty {
        let mediaContainer = UIStackView()
        mediaContainer.axis = .vertical
        mediaContainer.spacing = 4

        for media in validMedia {
            let imageView = UIImageView()
            imageView.contentMode = .scaleAspectFit

            if let url = URL(string: "https://example.com/images/\(media.id)") {
                // Load image from URL (using URLSession or an image loading library)
                // imageView.load(url: url)
            }

            imageView.translatesAutoresizingMaskIntoConstraints = false
            NSLayoutConstraint.activate([
                imageView.widthAnchor.constraint(equalToConstant: CGFloat(media.width)),
                imageView.heightAnchor.constraint(equalToConstant: CGFloat(media.height))
            ])

            mediaContainer.addArrangedSubview(imageView)
        }

        container.addArrangedSubview(mediaContainer)
    }

    return container
}
```

```kotlin
import android.view.View
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView

fun createMessageView(message: Message, context: android.content.Context): View {
    val container = LinearLayout(context).apply {
        orientation = LinearLayout.VERTICAL
    }

    val textView = TextView(context).apply {
        text = message.text
    }
    container.addView(textView)

    val validMedia = getValidMedia(message)
    if (validMedia.isNotEmpty()) {
        val mediaContainer = LinearLayout(context).apply {
            orientation = LinearLayout.VERTICAL
        }

        validMedia.forEach { media ->
            val imageView = ImageView(context).apply {
                // Load image from URL (using Coil, Glide, or Picasso)
                // load("https://example.com/images/${media.id}")
            }

            mediaContainer.addView(imageView)
        }

        container.addView(mediaContainer)
    }

    return container
}
```

```jetpack
import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import coil.compose.AsyncImage
import com.ably.chat.Message

@Composable
fun MessageDisplayComponent(message: Message) {
    val validMedia = getValidMedia(message)

    Column {
        Text(text = message.text)

        if (validMedia.isNotEmpty()) {
            Column {
                validMedia.forEach { media ->
                    AsyncImage(
                        model = "https://example.com/images/${media.id}",
                        contentDescription = media.title,
                    )
                }
            }
        }
    }
}
```
</Code>

### Add media to an existing message <a id="add"/>

You can also add media to an existing message by editing its `metadata`:

<Code>
```javascript
let mediaId = 'abcd123abcd'; // assume this is the media we want to add
let message = ...; // assume this is the message we want to edit

const newMetadata = structuredClone(message.metadata);
if (!newMetadata.media) {
  newMetadata.media = [];
}
newMetadata.media.push(mediaId);

room.messages.update(message.serial, message.copy({metadata: newMetadata}))
```

```react
import { useMessages } from '@ably/chat/react';

const AddMediaToMessage = ({ message }) => {
  const { update } = useMessages();

  const addMediaToMessage = async () => {
    const mediaId = 'abcd123abcd'; // assume this is the media we want to add

    const newMetadata = structuredClone(message.metadata);
    if (!newMetadata.media) {
      newMetadata.media = [];
    }
    newMetadata.media.push(mediaId);

    await update(message.serial, message.copy({metadata: newMetadata}));
  };

  return (
    <button onClick={addMediaToMessage}>
      Add Media to Message
    </button>
  );
};
```

```swift
func addMediaToMessage(message: Message, mediaData: MediaData) async throws {
    var newMetadata = message.metadata

    var mediaArray: [JSONValue]
    if case let .array(existingArray) = newMetadata["media"] {
        mediaArray = existingArray
    } else {
        mediaArray = []
    }

    mediaArray.append(.object([
        "id": .string(mediaData.id),
        "title": .string(mediaData.title),
        "width": .number(Double(mediaData.width)),
        "height": .number(Double(mediaData.height))
    ]))

    newMetadata["media"] = .array(mediaArray)

    try await room.messages.update(
        serial: message.serial,
        params: .init(
            text: message.text,
            metadata: newMetadata
        )
    )
}
```

```kotlin
import kotlinx.serialization.json.*

suspend fun addMediaToMessage(message: Message, mediaData: MediaData) {
    val existingMedia = message.metadata["media"]?.jsonArray ?: buildJsonArray { }

    val newMediaArray = buildJsonArray {
        existingMedia.forEach { add(it) }
        add(buildJsonObject {
            put("id", mediaData.id)
            put("title", mediaData.title)
            put("width", mediaData.width)
            put("height", mediaData.height)
        })
    }

    val newMetadata = buildJsonObject {
        message.metadata.forEach { (key, value) ->
            if (key != "media") {
                put(key, value)
            }
        }
        put("media", newMediaArray)
    }

    room.messages.update(
        serial = message.serial,
        text = message.text,
        metadata = newMetadata
    )
}
```

```jetpack
import androidx.compose.material.*
import androidx.compose.runtime.*
import com.ably.chat.Message
import com.ably.chat.Room
import kotlinx.coroutines.launch
import kotlinx.serialization.json.*

@Composable
fun AddMediaToMessageComponent(room: Room, message: Message) {
    val coroutineScope = rememberCoroutineScope()

    Button(onClick = {
        coroutineScope.launch {
            val mediaData = MediaData("abcd123abcd", "A beautiful image", 1024, 768)

            val existingMedia = message.metadata["media"]?.jsonArray ?: buildJsonArray { }

            val newMediaArray = buildJsonArray {
                existingMedia.forEach { add(it) }
                add(buildJsonObject {
                    put("id", mediaData.id)
                    put("title", mediaData.title)
                    put("width", mediaData.width)
                    put("height", mediaData.height)
                })
            }

            val newMetadata = buildJsonObject {
                message.metadata.forEach { (key, value) ->
                    if (key != "media") {
                        put(key, value)
                    }
                }
                put("media", newMediaArray)
            }

            room.messages.update(
                serial = message.serial,
                text = message.text,
                metadata = newMetadata
            )
        }
    }) {
        Text("Add Media to Message")
    }
}
```
</Code>

### Remove media from an existing message <a id="remove"/>

You can remove media from an existing message by updating its `metadata`:

<Code>
```javascript
let mediaId = 'abcd123abcd'; // assume this is the media we want to remove
let message = ...; // assume this is the message we want to edit

if (!message.metadata.media || message.metadata.media.length === 0) {
  //do nothing if there is no media
  return;
}
const newMetadata = structuredClone(message.metadata);
newMetadata.media = newMetadata.media.filter(id => mediaId !== id);

room.messages.update(message.serial, message.copy({metadata: newMetadata}))
```

```react
import { useMessages } from '@ably/chat/react';

const RemoveMediaFromMessage = ({ message }) => {
  const { update } = useMessages();

  const removeMediaFromMessage = async () => {
    const mediaId = 'abcd123abcd'; // assume this is the media we want to remove

    if (!message.metadata.media || message.metadata.media.length === 0) {
      // do nothing if there is no media
      return;
    }

    const newMetadata = structuredClone(message.metadata);
    newMetadata.media = newMetadata.media.filter(id => mediaId !== id);

    await update(message.serial, message.copy({metadata: newMetadata}));
  };

  return (
    <button onClick={removeMediaFromMessage}>
      Remove Media from Message
    </button>
  );
};
```

```swift
func removeMediaFromMessage(message: Message, mediaIdToRemove: String) async throws {
    guard case let .array(mediaArray) = message.metadata["media"],
          !mediaArray.isEmpty else {
        // do nothing if there is no media
        return
    }

    let newMediaArray = mediaArray.filter { mediaValue in
        guard case let .object(mediaObj) = mediaValue,
              case let .string(id) = mediaObj["id"] else {
            return true
        }
        return id != mediaIdToRemove
    }

    var newMetadata = message.metadata
    newMetadata["media"] = .array(newMediaArray)

    try await room.messages.update(
        serial: message.serial,
        params: .init(
            text: message.text,
            metadata: newMetadata
        )
    )
}
```

```kotlin
import kotlinx.serialization.json.*

suspend fun removeMediaFromMessage(message: Message, mediaIdToRemove: String) {
    val existingMedia = message.metadata["media"]?.jsonArray
    if (existingMedia == null || existingMedia.isEmpty()) {
        // do nothing if there is no media
        return
    }

    val newMediaArray = buildJsonArray {
        existingMedia.forEach { mediaValue ->
            val mediaObj = mediaValue.jsonObject
            val id = mediaObj["id"]?.jsonPrimitive?.content
            if (id != mediaIdToRemove) {
                add(mediaValue)
            }
        }
    }

    val newMetadata = buildJsonObject {
        message.metadata.forEach { (key, value) ->
            if (key != "media") {
                put(key, value)
            }
        }
        put("media", newMediaArray)
    }

    room.messages.update(
        serial = message.serial,
        text = message.text,
        metadata = newMetadata
    )
}
```

```jetpack
import androidx.compose.material.*
import androidx.compose.runtime.*
import com.ably.chat.Message
import com.ably.chat.Room
import kotlinx.coroutines.launch
import kotlinx.serialization.json.*

@Composable
fun RemoveMediaFromMessageComponent(room: Room, message: Message) {
    val coroutineScope = rememberCoroutineScope()

    Button(onClick = {
        coroutineScope.launch {
            val mediaIdToRemove = "abcd123abcd"

            val existingMedia = message.metadata["media"]?.jsonArray
            if (existingMedia == null || existingMedia.isEmpty()) {
                // do nothing if there is no media
                return@launch
            }

            val newMediaArray = buildJsonArray {
                existingMedia.forEach { mediaValue ->
                    val mediaObj = mediaValue.jsonObject
                    val id = mediaObj["id"]?.jsonPrimitive?.content
                    if (id != mediaIdToRemove) {
                        add(mediaValue)
                    }
                }
            }

            val newMetadata = buildJsonObject {
                message.metadata.forEach { (key, value) ->
                    if (key != "media") {
                        put(key, value)
                    }
                }
                put("media", newMediaArray)
            }

            room.messages.update(
                serial = message.serial,
                text = message.text,
                metadata = newMetadata
            )
        }
    }) {
        Text("Remove Media from Message")
    }
}
```
</Code>

## Media moderation

Ably [moderation feature](/docs/chat/moderation) is currently limited to text moderation. To add automatic or human moderation for media, you'll need to implement moderation server-side.

An example flow for this would be:

1. Upload the media to your storage service.
2. Asynchronously start the moderation process on the server.
3. Send a message with the `metadata` containing information about the media; either an ID or URL.
4. When a user requests the media from your server, check the moderation status and serve it or return an error.

This means you don't need to update the `metadata` field of the message to reflect its moderation status.
