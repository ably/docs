---
title: Batch operations
meta_description: "Group multiple objects operations into a single channel message to apply grouped operations atomically and improve performance."
---

<Aside data-type='experimental'>
LiveObjects is currently Experimental. Its features are still in development and subject to rapid change.

**Building with LiveObjects?** Help shape its future by [sharing your use case](https://44qpp.share.hsforms.com/2fZobHQA1ToyRfB9xqZYQmQ).
</Aside>

The Batching API in LiveObjects enables multiple updates to be grouped into a single channel message and applied atomically. It ensures that all operations in a batch either succeed together or are discarded entirely. Batching operations is essential when multiple related updates to channel objects must be applied as a single atomic unit, for example, when application logic depends on multiple objects being updated simultaneously. Without batching, if one operation succeeds while another fails, your application state could become inconsistent.

Note that this differs from ["Message batching"](/docs/messages/batch), the native Pub/Sub messages feature. The LiveObjects Batching API is a separate API specifically designed to enable you to group object operations into a single channel message, ensuring that the Ably system guarantees the atomicity of the applied changes.

Batching also provides cost efficiency: all operations in a batch are sent as one channel message and billed as such, regardless of how many individual operations are included (up to the message size limit).

## Create batch context <a id="create"/>

To batch object operations together, use the `channel.objects.batch()` method. This method accepts a callback function, which is provided with a batch context object. The batch context object provides a synchronous API to work with objects on a channel that stores operations inside the batch instead of applying them immediately.

Using the batch context ensures that operations are grouped and sent in a single channel message after the batch callback function has run. This guarantees that all changes are applied atomically by both the server and all clients.

<Aside data-type='important'>
The batch callback function must be synchronous because the batch method sends the grouped operations as soon as the callback function completes. If you need to perform asynchronous operations (such as fetching data to do operations inside a batch), do so outside the callback function before calling `channel.objects.batch()`.
</Aside>

<Code>
```javascript
await channel.objects.batch((ctx) => {
  const root = ctx.getRoot();

  root.set('foo', 'bar');
  root.set('baz', 42);

  const counter = root.get('counter');
  counter.increment(5);

  // Batched operations are sent to the Ably system when the batch callback has run.
});
```
</Code>

If an error occurs within the batch, all operations are discarded, preventing partial updates and ensuring atomicity.

### Batch context object <a id="context"/>

The batch context provides a synchronous API for objects operations inside the batch callback. It mirrors the asynchronous API found on `channel.objects`, including [LiveCounter](/docs/liveobjects/counter) and [LiveMap](/docs/liveobjects/map).

To access the batch API, call `BatchContext.getRoot()`, which synchronously returns a wrapper around the [root](/docs/liveobjects/concepts/objects#root-object) object instance. This wrapper enables you to access and modify objects within a batch.

<Aside data-type='note'>
Although the batch context provides a synchronous API, updates to objects are only applied _after_ the batch callback function has run and changes have been echoed back to the client, just like regular mutation operations.
</Aside>

<Code>
```javascript
await channel.objects.batch((ctx) => {
  // Note: .getRoot() call on a batch context is synchronous.
  // The returned root object is a special wrapper around a regular LiveMap instance,
  // providing a synchronous mutation API.
  const root = ctx.getRoot();

  // Mutation operations like LiveMap.set and LiveCounter.increment
  // are synchronous inside the batch and queue operations instead of applying them immediately.
  root.set('foo', 'bar');
  root.remove('baz');

  // Access other objects through the root object from the BatchContext.getRoot() method.
  const counter = root.get('counter');
  counter.increment(5);
});
```
</Code>

You cannot create new objects using the batch context. If you need to create new objects and add them to the channel as part of an atomic batch operation to guarantee atomicity, you must first create them using the regular `channel.objects` API. Once the objects have been created, you can then assign them to the object tree inside a batch function.

<Code>
```javascript
// First, create new objects outside the batch context
const counter = await channel.objects.createCounter();
const map = await channel.objects.createMap();

// Then, use a batch to assign them atomically to the channel objects
await channel.objects.batch((ctx) => {
  const root = ctx.getRoot();
  root.set('counter', counter);
  root.set('map', map);
});
```
</Code>

### When to batch operations <a id="use-cases"/>

Usually, you don't need to use batching for objects operations. It is only useful in situations where a group of operations must be applied together to maintain consistency in application state, or when there are multiple mutation operations that you might want to apply at the same time to improve the UI experience.

For example, in a task dashboard application, you might want to remove all tasks on a board in a single operation to prevent excessive UI updates that the user would otherwise experience.

<Code>
```javascript
await channel.objects.batch((ctx) => {
  const root = ctx.getRoot();
  const tasks = root.get('tasks');

  for (const key of tasks.keys()) {
    tasks.remove(key);
  }
});
```
</Code>

## Cancel batch operation <a id="cancel"/>

To explicitly cancel a batch before it is applied, throw an error inside the batch function. This prevents any queued operations from being applied.

<Code>
```javascript
await channel.objects.batch((ctx) => {
  const root = ctx.getRoot();
  root.set('foo', 'bar');

  // Throwing an error prevents any queued operations from being applied.
  throw new Error('Cancel batch');
});
```
</Code>

### Batch API cannot be used outside the callback function <a id="closed"/>

The Batch API provided by the batch context object cannot be used outside the callback function. Attempting to do so results in an error. This applies both to `BatchContext.getRoot()` and any object instances retrieved from it.

<Code>
```javascript
let root;
await channel.objects.batch((ctx) => {
  root = ctx.getRoot();
});

// Calling any Batch API methods outside the batch callback
// will throw an Error: Batch is closed.
root.set('foo', 'bar');
```
</Code>
