---
title: Reactor Functions
section: general
index: 22
---

Reactor Functions allow your server-less functions to be invoked following channel lifecycle events (such as channel creation), presence events (such as members entering or leaving) or messages being published. Reactor Functions are offered as part of our "Ably Reactor Event service":https://www.ably.io/reactor, a service available to all customers of the Ably platform.

p(tip). Reactor Functions are "rate limited":#transport and designed for low to medium volumes of updates. If you expect a high volume of events and messages (upwards of 20 per second), then you should consider using our "message queues":/general/queues or "firehose":/general/firehose instead as they are designed to scale without limits.

Generally, customers who want to receive events as they happen, use our "message queues":/general/queues or "firehose":/general/firehose, or alternatively our "realtime client libraries":/realtime and subscribe to events and messages published. However, some customers prefer a server-less architecture and want to have their code invoked when a user publishes a message, attaches to a channel, or enters the presence set on a channel. For example, a developer may want to send a welcome message to someone when they first enter a chat channel. A Reactor Function can be used to achieve this.

Reactor Functions are designed to trigger server-less functions on common cloud platforms such as Amazon, Google and Microsoft. If you are looking to trigger the execution of code on your own servers over HTTP when a message is published or an event occurs, see our "Reactor WebHooks":/general/webhooks or "contact us":https://www.ably.io/contact to discuss setting up a custom endpoint.

<a href="/images/diagrams/reactor-functions-intro.png" target="_blank">
  <img src="/images/diagrams/reactor-functions-intro.png" style="width: 100%" alt="Ably Reactor Functions diagram">
</a>

h2. Payload Encoding

The encoding of payloads sent is defined when setting up a Reactor Rule in the "Reactor tab of your app":https://support.ably.io/solution/articles/3000074406-how-to-reach-the-reactor-page. You can have the message sent in JSON format, or as a "MessagePack":https://msgpack.org payload.

* "JSON":https://www.json.org (JavaScript Object Notation): An efficient data-interchange format which is fairly standard and provides simple text based encoding.
* "MessagePack":https://msgpack.org: An efficient binary serialization format that is similar to JSON, but faster and smaller.

h2. Envelopes

Messages sent by Reactor Functions can be contained within an envelope. This can be useful for clients which are unable to access response headers or status codes, or wish to receive more metadata about the payload.

h2. Payload types

Ably currently supports two types of data that can be delivered via our Functions:

* "Messages":#messages - messages trigger function calls as soon as they are published on a channel
* "Presence events":#presence - presence events trigger function calls when clients enter, update their data, or leave channels

You can "configure functions":#configure from the "Reactor tab in your app":https://support.ably.io/solution/articles/3000074406-how-to-reach-the-reactor-page on a per app basis which can apply to one or more channels in that app. Reactor Functions can be filtered by channel naming using a regular expression, for example @^click_.*_mouse$@. This would match the string 'click_' followed by a string followed by '_mouse', for example, 'click_left_mouse'.

h2(#messages). Messages

If you are unfamiliar with how channels work in Ably, we recommend you first review the "realtime channel documentation":/realtime/channels-messages#channels.

When a "@Message@":/rest/channels-messages#message is published on a channel, a Reactor Function message event is triggered, which in turn will send a message to your server-less function.

Every request will contain your message within the "HTTP message body":https://en.wikipedia.org/wiki/HTTP_message_body part of the request. The contents of the @HTTP message body@ depends on whether you've used an envelope or not. If you don't use an envelope, the @HTTP message body@ will only contain the "@Message@":/rest/channels-messages#message payload from your message event.

@Enveloped@ - when the Reactor rule is configured to use an enveloper, the @HTTP message body@ will contain a bunch of extra attributes, which are the following:

- source := the source of the request, namely "@channel.message@"
- appId := the "ID of your application":https://support.ably.io/support/solutions/articles/3000063083-how-do-i-find-my-app-id on Ably
- channel := name of the channel on which the "@Message@":/rest/channels-messages#message was published
- site := an internal site identifier indicating the data center from which the message was published
- ruleId := an ID for the rule which has created this request
- messages := an @Array@ containing your "@Message@":/rest/channels-messages#message contents

h4. Decoding messages

Each member of @messages@ is a 'raw' message, with the contents of your "@Message@":/rest/channels-message#message within it. Messages sent "over the realtime service":/realtime/channels-messages are automatically decoded into the "@Message@":/realtime/types#message object by the Ably client library. With Reactor Functions you need to to do this explicitly, using "@Message.fromEncodedArray@":/realtime/channels-messages#message-from-encoded-array on the @messages@ array, or "@Message.fromEncoded@":/realtime/channels-messages#message-from-encoded on an individual member of that array. This will transform them into an array of "@Message@":/realtime/types#message (or in the case of @fromEncoded@, an individual "@Message@":/realtime/types#message). Using the Ably client library to decode messages has several advantages:

* It will fully decode any @data@ (using the @encoding@) back into the same datatype that it was sent in (or an equivalent in each client library's language)
* If you are using "encryption":/realtime/encryption, you can pass your encryption key to the method and it will decrypt the @data@ for you

We recommend you do this for all messages you receive through Reactor Functions. For example (using ably-js):

```[javascript]
  const messages = Ably.Realtime.Message.fromEncodedArray(request.body.messages);
  context.log(messages.toString());
```

h4. Example @channel.message@ JSON payload

```[json]
{
   "items":[
      {
         "source":"channel.message",
         "appId":"ABCDef"
         "channel":"your_channel",
         "site":"eu-west-2-A",
         "ruleId":"rUlEID",
         "messages":[
            {
               "id":"9qaOH1C4tO:2:0",
               "name":"foo",
               "connectionId":"9qaOH1C4tO",
               "timestamp":1479301189856,
               "data":"bar"
            }
         ]
      }
   ]
}
```

Please note that if you are planning to receive messages via Ably Functions, it is theoretically very easy to exceed the "transport rate limits":https://support.ably.io/support/solutions/articles/3000053845-do-you-have-any-connection-message-rate-or-other-limits-on-accounts we impose on Reactor Functions to prevent DoS attacks against your endpoints. We recommend you consider "message queues":/general/queues instead for a more scalable solution, or "firehose":/general/firehose.

h2(#presence). Presence events

If you are unfamiliar with how presence works in Ably and what events are supported, we recommend you first review the "realtime presence documentation":/realtime/presence.

When a member enters, updates, or leaves a channel, a presence event is triggered. Every Reactor Function request instigated by a presence event will contain details of the presence event within the @HTTP message body@ attribute, stored as an array.

Every request will contain your message within the "HTTP message body":https://en.wikipedia.org/wiki/HTTP_message_body part of the request. The contents of the @HTTP message body@ depends on whether you've used an envelope or not. If you don't use an envelope, the @HTTP message body@ will only contain the @PresenceMessage@ payload from the presence event.

@Enveloped@ - when the Reactor rule is configured to use an enveloper, the @HTTP message body@ will contain a bunch of extra attributes, which are the following:

- source := the source of the request, namely "@channel.presence@"
- appId := the ID of your application with Ably
- channel := name of the channel the "Ably message":/rest/channels-messages#message was published on
- site := an internal site identifier indicating the data center from which the message was published
- ruleId := an ID for the rule which has created this request
- presence := an @Array@ containing your "@PresenceMessage@":/realtime/types#presence-message contents

h4. Decoding presence events

Each member of @presence@ is a 'raw' presence event. Presence messages sent "over the realtime service":/realtime/channels-messages are automatically decoded into "@PresenceMessage@":/realtime/types#presence-message objects by the Ably client library. With Reactor Functions you need to to do this explicitly, using "@PresenceMessage.fromEncodedArray@":/realtime/presence#presence-from-encoded-array on the @presence@ array, or "@PresenceMessage.fromEncoded@":/realtime/presence#presence-from-encoded on an individual member of that array. This will transform them into an array of "@PresenceMessage@":/realtime/types#presence-message (or in the case of @fromEncoded@, an individual "@PresenceMessage@":/realtime/types#presence-message). Using the Ably client library to decode @presence@ has several advantages:

* It will decode the (numerical) action into a "@PresenceAction@":/realtime/presence#presence-action string (such as "@enter@", "@update@", or "@leave@")
* It will fully decode any @data@ (using the @encoding@) back into the same datatype that it was sent in (or an equivalent in each client library's language)
* If you are using "encryption":/realtime/encryption, you can pass your encryption key to the method and it will decrypt the @data@ for you

We recommend you do this for all presence messages you receive through Reactor Functions. For example (using ably-js):

```[javascript]
      const presMsgs = Ably.Realtime.PresenceMessage.fromEncodedArray(request.body.presence);
      console.log(presMsgs.toString());
```

h4. Example @channel.presence@ @enter@ JSON payload

```[json]
{
   "items":[
      {
         "source":"channel.presence",
         "appId":"ABCDef"
         "channel":"your_channel",
         "site":"eu-west-2-A",
         "ruleId":"rUlEID",
         "presence":[
            {
               "id":"9qaOH1C4tO:2:0",
               "clientId":"foo",
               "connectionId":"9qaOH1C4tO",
               "timestamp":1479301189856,
               "action":"2"
            }
         ]
      }
   ]
}
```

h2. Server-less platform support

We currently support the following:

* Amazon Lambda
* Google Cloud Function
* Azure Functions

We also offer custom endpoints to our "Enterprise":https://www.ably.io/pricing/enterprise customers.

h2(#troubleshooting). Troubleshooting Functions

If you are finding it hard to debug a problem with Reactor Functions, we recommend you review "our recommendations for debugging Functions":https://support.ably.io/solution/articles/3000074193-how-can-i-debug-reactor-function. If this does not help, please "get in touch with us":https://www.ably.io/contact so that we can help you with your problem.

h2. Next steps

* "Follow one of our Reactor Function step-by-step tutorials":/tutorials