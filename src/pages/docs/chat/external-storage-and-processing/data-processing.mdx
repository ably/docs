---
title: "Process and respond to messages"
meta_description: "Process chat messages through external systems and respond back to chat in real-time with AI, translation, moderation, and more."
meta_keywords: "chat processing, AI chat, translation, bidirectional integration, message processing, chat automation"
---

You can process chat messages through external systems like AI tools, translation services, or analytics, then respond back to the chat in real-time. This bidirectional integration pattern enables powerful features like chatbots, automated support, real-time translation, sentiment analysis, and more.

## Why process messages with external systems? <a id="why-process"/>

Integrating external systems with Ably Chat enables you to extend your chat application beyond simple message delivery:

* **AI-powered assistance**: Process commands or questions through language models and respond with helpful information
* **Real-time translation**: Automatically translate messages for multilingual chat rooms
* **Sentiment analysis**: Analyze the emotional tone of messages to gauge user or group sentiment
* **Notifications**: Detect mentions or keywords and trigger custom notification systems
* **Workflow automation**: Trigger external business processes based on chat activity
* **Command processing**: Handle slash commands that invoke server-side logic

## Understanding the bidirectional flow <a id="integration-flow"/>

The typical bidirectional integration flow works as follows:

1. A user sends a message to a chat room, optionally including [metadata or headers](#metadata-headers) for processing context
2. An integration rule evaluates the message based on room name pattern matching
3. If the rule matches, Ably forwards the message to your external system
4. Your external system processes the message (AI inference, translation, business logic, etc.)
5. The external system [sends a response](#responding) back to the chat room
6. All subscribed clients receive the response in real-time

This bidirectional flow enables powerful patterns like chatbots, automated support, real-time translation, and more.

## Choosing an integration method <a id="implementation-options"/>

Ably provides several different integration methods, each suited to different use cases. All integrations discussed below can be used to support this bidirectional pattern.

### Webhooks

[Outbound webhooks](/docs/platform/integrations/webhooks) are ideal for simple business logic and event-driven actions, particularly for processing @mentions or triggering custom notifications, executing lightweight business logic (lookup, validation, etc.), and serverless architectures (AWS Lambda, Cloud Functions, etc.).

**Learn more:** See [Extract messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#webhooks) for setup details and code examples.

### Ably Queues

[Ably Queues](/docs/platform/integrations/queues) provide strict ordering and fault-tolerant delivery, making them ideal for automated support flows where message order matters, processing sequential events (game moves, transaction steps), and fault-tolerant message processing with automatic retries.

**Learn more:** See [Extract messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#queues) for setup details and code examples.

### Streaming

[Outbound streaming](/docs/platform/integrations/streaming) enables massive scale and integration with existing infrastructure, making it ideal for high-throughput scenarios (large-scale chats, millions of messages), existing streaming infrastructure (Kafka, Kinesis, etc.), and complex data pipelines and analytics.

**Learn more:** See [Extract messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#streaming) for setup details and code examples.

## Using metadata for structured content <a id="metadata-headers"/>

Clients can provide context for your external services to use while processing by adding data in the [`metadata`](/docs/chat/external-storage-and-processing/data-extraction#metadata-headers) field. For example, when implementing a notification system, you might include the target user ID and notification type:

<Code>
```javascript
// Client sends message with metadata
await room.messages.send({
  text: '@john.123 Can you review this?',
  metadata: {
    targetClientId: 'john.123',
    notificationType: 'mention'
  }
});
```
</Code>

You can then [extract](/docs/src/pages/docs/chat/external-storage-and-processing/data-processing.mdx#decoding) the metadata in your integration to trigger business logic:

<Code>
```javascript
// use metadata in your integration to trigger notifications
const metadata = msg.data?.metadata || {};
if (metadata.notificationType === 'mention') {
  await sendNotification(metadata.targetClientId, {
    type: 'mention',
    text: msg.data.text,
    roomName: roomName
  });
}
```
</Code>

**Important:** Metadata is not server-validated. Always treat it as untrusted user input and validate it in your integration code.

## Processing messages in your integration <a id="processing"/>

When your integration receives messages, extract the metadata and headers to control processing logic.

<Code>
```javascript
const Ably = require('ably');

async function processIntegrationPayload(envelopeData) {
  // Decode messages using Ably SDK
  const decodedMessages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of decodedMessages) {
    // Extract text content
    const text = msg.data?.text;

    // Extract headers for routing
    const headers = msg.extras?.headers || {};
    const command = headers['x-command'];

    // Extract metadata for business context (treat as untrusted)
    const metadata = msg.data?.metadata || {};
    const intent = metadata.intent;

    // Extract room name for sending responses
    const roomName = envelopeData.channel.replace('::$chat', '');

    // Route based on headers or metadata
    if (command === 'translate') {
      await handleTranslation(text, headers['x-target-lang'], roomName);
    } else if (intent === 'weather-query') {
      await handleWeatherQuery(metadata.location, roomName);
    }
  }
}
```
</Code>

For complete details on message decoding and structure, see the section on [extracting messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#decoding).

## Responding back to chat <a id="responding"/>

After processing messages through your external system, you can then publish responses back to the chat room.

### Avoiding infinite loops

When your integration responds back to chat, ensure responses don't trigger the same integration rule. Use Ably's [skip integrations](/docs/platform/integrations/skip-integrations) feature to publish messages that bypass integration rules.

**Note:** Your API key or token must have the [`privileged-headers`](/docs/auth/capabilities#capability-operations) capability to skip integrations.

<Code>
```javascript
const { ChatClient } = require('@ably/chat');

async function sendResponseToChat(roomName, responseText) {
  // Initialize Chat client with privileged API key
  const chatClient = new ChatClient({ key: 'YOUR_API_KEY' });

  // Get the chat room
  const room = await chatClient.rooms.get(roomName);

  // Send response message skipping integration rules
  await room.messages.send({
    text: responseText
  }, {
    extras: {
      privileged: {
        skipRule: '*' // Skip all integration rules
      }
    }
  });
}
```
</Code>

Alternatively, you can skip only specific rules by providing the rule IDs as an array instead of `'*'`. The rule ID is available in the integration webhook envelope's `ruleId` field, or you can find it in your Ably [dashboard](https://ably.com/dashboard) under Integrations.

## Complete example: Live translation <a id="example"/>

The following example demonstrates an integration where messages are processed, translated, and responses are sent back to the chat.

### Step 1: Client sends message with metadata

<Code>
```javascript
// Client application
await room.messages.send({
  text: "Hello!",
  metadata: {
    intent: 'translate',
    targetLanguage: 'fr' // User specified target language
  }
});
```
</Code>

### Step 2: Integration rule forwards to webhook

Configure an integration rule in your dashboard:
- Channel filter: `^chat:.*` (matches all chat rooms)
- Event type: `channel.message`
- Endpoint: `https://your-domain.com/webhook`

### Step 3: Webhook processes and responds

<Code>
```javascript
const express = require('express');
const Ably = require('ably');
const { ChatClient } = require('@ably/chat');

const app = express();
app.use(express.json());

app.post('/webhook', async (req, res) => {
  const envelope = req.body;

  // Decode messages
  const messages = Ably.Realtime.Message.fromEncodedArray(envelope.messages);

  for (const msg of messages) {
    const text = msg.data?.text;
    const metadata = msg.data?.metadata || {};
    const roomName = envelope.channel.replace('::$chat', '');

    // Process based on metadata intent
    if (metadata.intent === 'translate') {
      const translation = await translateText(text, metadata.targetLanguage);
      await sendResponseToChat(roomName, `Translation: ${translation}`);
    }
  }

  res.status(200).send('OK');
});

async function translateText(text, targetLang) {
  // Call your translation service
  return `[Translated to ${targetLang}]: ${text}`;
}

async function sendResponseToChat(roomName, responseText) {
  const chatClient = new ChatClient({ key: process.env.ABLY_API_KEY });
  const room = await chatClient.rooms.get(roomName);

  await room.messages.send({
    text: responseText
  }, {
    extras: {
      privileged: {
        skipRule: '*' // Prevent infinite loop
      }
    }
  });
}

app.listen(3000);
```
</Code>

### Step 4: Clients receive the response

All clients subscribed to the room receive the translation in real-time:

<Code>
```javascript
room.messages.subscribe((event) => {
  console.log('Received:', event.message.text);
  // Output: "Translation: [Translated to fr]: Bonjour!"
});
```
</Code>

## Key considerations <a id="key-considerations"/>

Consider the following when integrating external systems with Ably Chat:

* **Avoiding infinite loops:** Always use the [skip integrations flag](#responding) when responding back to chat to prevent your response from triggering the integration again
* **Scale and reliability:** Different integration methods offer different reliability guarantees. See [choosing an integration method](#implementation-options) for guidance
* **External system limitations:** Your external service may have rate limits, processing constraints, or availability issues. Implement retry logic, circuit breakers, and caching to handle these limitations gracefully
* **Cost optimization:** Only process messages that require processing. Use channel filters and metadata/headers to route messages efficiently
* **Security:** Always validate and sanitize client-provided metadata before using it in your integration logic
* **Error handling:** Handle external system failures gracefully - consider fallback responses or queuing failed requests for retry
