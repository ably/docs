---
title: Delta compression
section: realtime
index: 3
languages:
  - javascript
  - nodejs
  - java
  - objc
  - dotnet
jump_to:
  Help with:
    - Overview#overview
    - Delta processing#delta-processing
    - Using deltas#using-deltas
    - Examples#examples
---

h2(#overview). Overview

The @delta@ parameter enables delta compression. It is applied on the channel you are subscribing to, enabling delta mode.

Delta mode is a way for a client to subscribe to a channel so that message payloads sent contain only the difference (ie the delta) between the present message and the previous message on the channel.

This is useful for channels that carry messages representing a series of updates to a particular object or document with a significant degree of similarily between successive messages. The client can apply the delta to the previous message to obtain the full payload. Using delta mode can signficantly reduce the encoded size of each message in the case that message payloads change by differences that are small relative to the size of the value. This reduction in size can reduce bandwidth costs, reduce transit latencies, and enable greater message throughput on a connection.

The delta mode implementation supports a single representation of a delta, "VCDIFF":https://tools.ietf.org/html/rfc3284.

Subscribing in delta mode is enabled for a given channel by specifying a @delta@ "channel parameter":/realtime/channels/channel-parameters/overview with the value @vcdiff@. This will cause delta messages to be generated by the server and sent to the client, and the library reconstitutes the original message payload. Messages on the channel are delivered to the subscriber's listener in the same way as with a normal subscription.

h2(#delta-processing). Delta processing

Deltas apply to the principal payload of a @Message@ published via Ably, which is the @data@ member. Other elements of a message, such as @clientId@, @name@, or @extras@ are unchanged by use of deltas and are not compressed.

Deltas are supported for realtime subscriptions only. Messages retrieved via "history":/realtime/history, and messages delivered to "Reactor integrations":https://www.ably.io/reactor, are not compressed.

Delta compression via @vcdiff@ is supported for all payloads, whether string, binary, or JSON-encoded. The delta algorithm processes message payloads as opaque binaries and has no dependency on the stucture of the payload - it does not process line-oriented diffs, for example. In principle, @vcdiff@ deltas can be applied to encrypted message payloads, but in practice this provides no benefit because there is no similarity between successive encrypted payloads even on identical or near-identical plaintext message payloads.

Delta compression is a subscriber-specified option only - the publisher has no control over whether or not deltas are generated for any given message; the processing is performed if there is at least one subscriber on a channel that has requested a delta-mode subscription.

There is no constraint on how many publishers or subscribers there are. If there are multiple publishers, then deltas can still be generated, and they will be determined based on the order of messages in the channel in question, for the region in question. When there are multiple publishers in multiple regions, publishing messages nearly simultaneously, the ordering of messages delivered to subscribers can be different in different regions, depending on actual region-to-region transit latencies; in this case, deltas are generated based on the actual message order in each region, and subscribers are delivered a sequence of delta messages that reflects that regional order.

Delta mode, when activated on a channel, is performed for all messages on a channel, and deltas are calculated strictly based on the message ordering in that channel. The effectiveness of delta mode - that is, whether or not there is a material saving in payload size - is dependent on the level of similarity between successive payloads. Therefore, if a channel carries messages from multiple sources or streams that are dissimilar, then delta processing might not result in a useful size reduction, even if the messages in each individual stream are similar; it depends on the specific sequence of messages that occurs in the channel, in the region in question.

If a delta is generated and it results in a difference that is not appreciably smaller than the original message, or is even larger than the original message (which can happen if successive messages are completely different), then the delta will not be sent and clients will receive the original, unprocessed message. Therefore, the sequence of messages that will be delivered to a client for any given channel will be a combination of regular messages and delta-compressed messages.

A channel subscriber can experience a discontinuity in the sequence of messages it receives on a given channel for the following reasons:

* The connection can drop, and there will be a discontinuity of the client is unable to reconnect within the two-minute window it is allowed to preserve connection continuity.
* The outbound connection might have been rate-limited, which causes some messages to be dropped.
* There might have been some internal error in the Ably system which leads to the server being unable to preserve continuity on the channel.

In these cases, the service indicates the discontinuity to the client, together with the reason, and this is usually visible to the subscriber in a channel @UPDATE@ event.

If a subscriber has a delta-mode subscription and the channel in question experiences a discontunity, then a non-delta message will be delivered to the client as the first message after the discontinuity. This ensures that lost messages do not prevent the client from reconstituting messages from deltas.

h2(#using-deltas). Using deltas

h3(#using-deltas-ably). Via an Ably library

The most common way to subscribe to Ably channels is via a realtime connection, using an Ably realtime library.

For many libraries this requires no change on the part of the caller except to specify the @delta@ "channel parameter":/realtime/channels/channel-parameters/overview when subscribing to the channel. In some libraries, the @vcdiff@ delta decoding library is excluded from the default library distribution in order to avoid bloating the library. In these cases, it is also necessary to supply the delta decoder plugin when instancing the Ably library.

```[js](code-editor:realtime/channel-deltas)
  /* Make sure to include <script src="//cdn.ably.io/lib/vcdiff-decoder.min-1.js"></script> in your head */
  var realtime = new Ably.Realtime({key: '{{API_KEY}}', plugins: {vcdiffDecoder: vcdiffDecoder}});
  realtime.channels.get('{{RANDOM_CHANNEL_NAME}}', {
    delta: 'vcdiff'
  }).subscribe(msg => console.log("Received message: ", msg));
```

```[nodejs]
  var vcdiffPlugin = require('@ably/vcdiff-decoder');
  var realtime = new Ably.Realtime({key: '{{API_KEY}}', plugins: {vcdiffDecoder: vcdiffDecoder}});
  realtime.channels.get('{{RANDOM_CHANNEL_NAME}}', {
    delta: 'vcdiff'
  }).subscribe(msg => console.log("Received message: ", msg));
```

```[java]
  AblyRealtime ably = new AblyRealtime("{{API_KEY}}")
  Channel channel = ably.channels.get("{{RANDOM_CHANNEL_NAME}}", new ChannelOptions{{params = Map.of("delta", "vcdiff")}});
  channel.subscribe(new MessageListener() {
    @Override
    public void onMessage(Message message) {
      System.out.println("Received `" + message.name + "` message with data: " + message.data);
    }
  });
```

```[obj-c]
TBD
```

```[swift]
TBD
```

```[dotnet]
TBD
```

h3(#using-deltas-non-ably). Via a subscription that does not use an Ably library

If subscribing to a channel in delta mode using "SSE":/sse or one of the protocol adaptors such as "MQTT":/mqtt, then you will need to decode any received delta messages yourself. There are decoder libraries available to do this for several platforms; see the "download":https://www.ably.io/download section for details. If you need to decode @vcdiff@-formatted delta messages in languages for which there is no decoder available from Ably, then any compliant open-source implementation of the standard will work.

Messages that contain a @vcdiff@ delta have that delta payload in their @data@ attribute; in the case of @vcdiff@ deltas this will be a binary value, even if the @data@ in the original meessage was text. in addition, there is metadata in the message @extras@ attribute that indicate that the payload is a delta, and which message the delta is relative to. The format of the `extras` attribute is as follows:

```[jsall]
extras: {
  format: 'vcdiff',
  from: '{{previous message id}}'
}
```

In order to reconstruct the original message, the @vcdiff@ decoder algorithm needs to be applied to the given @data@ @vcdiff@ value, together with the @data@ for the previous message (on the assumption that that message had already been decoded if it itself was also a delta). If the original form of the present message was text, then this is indicated in the `encoding` attribute of the message, so the original text can be reconstructed by @utf-8@ decoding, once the @vcdiff@ decoding is complete. The decoder libraries that are available to download simplify this process, and more detailed information can be found in the @README@ of each of those libraries.

When subscribing without an Ably library, then the channel @delta@ parameter must be specified using a "qualified channel name":/realtime/channels/channel-parameters/overview. In the case of SSE, it is also possible to specify channel parameters as regular query parameters on the connection URL.

Some transports provide raw message payloads - that is, the content of the @data@ attribute of a @Message@ - without the accompanying metadata. That means that the recipient of the message does not have access to the @extras@ or @encoding@ attributes of the message that would ordinarily be used to decode delta message payloads.

Examples of such transports are MQTT, and SSE in non-enveloped mode. In order to assist applications that use these transports, the @vcdiff@ decoder libraries can check for the @vcdiff@ header at the start of the message payload as an inexact method of determining whether or not the message is a regular message or a delta. Note that, in order to rely on that check, you need to know that that header will not be present in any valid (uncompressed) message in your app. No valid JSON value, for example, will match the @vcdiff@ header check, so it is safe to perform this sniffing on JSON message payloads.

h4(#delta-example-sse). Delta example with SSE

You can subscribe to messages in delta mode, using the SSE transport, as follows.

```[js]
(() => {
    var key = '{{API_KEY}}';
    var channel = 'sample-app-sse';
    var url = `https://realtime.ably.io/event-stream?channels=${channel}&v=1.1&key=${key}&delta=vcdiff`;
    var eventSource = new EventSource(url);
    var channelDecoder = new DeltaCodec.CheckedVcdiffDecoder();

    eventSource.onmessage = (event) => {
        /* event.data is JSON-encoded Ably Message
           (see https://www.ably.io/documentation/realtime/types#message) */
        var message = JSON.parse(event.data);
        var { id, extras } = message;
        var { data } = message;

        try {
            if (extras && extras.delta) {
                data = channelDecoder.applyBase64Delta(data, id, extras.delta.from).asUtf8String();
            } else {
                channelDecoder.setBase(data, id);
            }
        } catch(e) {
            /* Delta decoder error */
            console.log(e);
        }

        /* Process decoded data */
        console.log(data);
    };
})();
```

h4(#delta-example-unenv-sse). Delta example with unenveloped SSE

For more information on enveloped and uneveloped SSE, please see the "SSE API":/sse#sse

```[js]
(() => {
    var key = '{{API_KEY}}';
    var channel = 'sample-app-sse';
    var url = `https://realtime.ably.io/event-stream?channels=${channel}&v=1.1&key=${key}&delta=vcdiff&enveloped=false`;
    var eventSource = new EventSource(url);
    var channelDecoder = new DeltaCodec.VcdiffDecoder();

    eventSource.onmessage = (event) => {
        var data = event.data;

        try {
            if (DeltaCodec.VcdiffDecoder.isBase64Delta(data)) {
                data = channelDecoder.applyBase64Delta(data).asUtf8String();
            } else {
                channelDecoder.setBase(data);
            }
        } catch(e) {
            /* Delta decoder error */
            console.log(e);
        }

        /* Process decoded data */
        console.log(data);
    };
})();
```

h4(#delta-example-mqtt). Delta example with MQTT

```[js]
var mqtt = require('mqtt');
var { VcdiffDecoder } = require('./lib');

var options = {
  keepalive: 30,
  username: 'FIRST_HALF_OF_API_KEY',
  password: 'SECOND_HALF_OF_API_KEY',
  port: 8883
};
var client = mqtt.connect('mqtts:mqtt.ably.io', options);
var channelName = 'sample-app-mqtt';
var channelDecoder = new VcdiffDecoder();

client.on('message', (_, payload) => {
  var data = payload;

  try {
    if (VcdiffDecoder.isDelta(data)) {
      data = channelDecoder.applyDelta(data).asUint8Array();
    } else {
      channelDecoder.setBase(data);
    }
  } catch(e) {
    /* Delta decoder error */
    console.log(e);
  }

  /* Process decoded data */
  console.log(data);
});

client.subscribe(`[?delta=vcdiff]${channelName}`);
```

