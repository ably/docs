daemon off;
worker_processes auto;

events {
<% unless RbConfig::CONFIG['host_os'] =~ /darwin/ %>
  use epoll;
<% end %>
  accept_mutex on;
  worker_connections <%= ENV['NGINX_WORKER_CONNECTIONS'] || 1024 %>;
}

<% if pid_file = ENV['NGINX_PID_FILE'] %>
# Be explicit about the pid file location
pid <%= pid_file %>;
<% end %>

http {
  gzip on;
  gzip_comp_level 6;
  gzip_min_length 512;
  gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss font/woff font/woff2 image/svg+xml;
  gzip_vary on;
  gzip_proxied any; # Heroku router sends Via header

  server_tokens off;

  log_format l2met 'measure#nginx.service=$request_time request_id=$http_x_request_id';
  access_log <%= ENV['NGINX_ACCESS_LOG_PATH'] || 'logs/nginx/access.log' %> l2met;
  error_log <%= ENV['NGINX_ERROR_LOG_PATH'] || 'logs/nginx/error.log' %> notice;

  include mime.types;
  default_type application/octet-stream;
  sendfile on;

  # Must read the body in 5 seconds.
  client_body_timeout 5;

  map_hash_max_size 8192;
  map_hash_bucket_size 8192;

  # Creates a map of redirects for us
  map $uri $redirected_url {
    default "none";
    include website-redirects.conf;
    include client-lib-development-guide-redirects.conf;
    <% if File.exist?(File.dirname(__FILE__) + '/nginx-redirects.conf') %>
    include nginx-redirects.conf;
    <% end %>
  }

  ##
  # CORS CONFIGURATION

  # We can't use the `hostnames` directive because of the layers of proxying and varying hostnames.
  # If the origin of the request is in the list below we'll get that value set as
  # $cors_origin and we can use it further down the line.
  map $http_origin $cors_origin {
    https://ably.com $http_origin;
    https://ably-dev.com $http_origin;
    https://ik.imagekit.io $http_origin;
    https://ably-docs.herokuapp.com $http_origin;
    ~*https://website-[a-z0-9\-]*\.herokuapp\.com $http_origin;
    ~*https://ably-docs-[a-z0-9\-]*\.herokuapp\.com $http_origin;
    ~http://localhost:\d+ $http_origin;
    ~https?://ably\.test $http_origin;
  }

  # Further down in the configs where we can expect CORS requests we combine
  # $request_method checks and $cors_origin to set the correct headers,
  # including the Vary header to ensure the browser know we'll change the response
  # based on the Origin request header. We make use of an ERB snippet to make it
  # easier to maintain the shared configs

  <%
    cors_headers = <<~ERB
        more_set_headers 'Access-Control-Allow-Origin: $cors_origin';
        more_set_headers 'Access-Control-Allow-Headers: sentry-trace, baggage';
        more_set_headers 'Access-Control-Allow-Methods: GET, OPTIONS';
        more_set_headers 'Access-Control-Allow-Credentials: true';
        more_set_headers 'Vary: Origin';
    ERB
  %>

  # / CORS CONFIGURATION

  ##
  # PROTECTED CONTENT REQUESTS
  <%
    # By setting CONTENT_REQUEST_AUTH_TOKENS, we can protect content requests
    # to the site. This is useful for preventing bad crawlers (the slop feeders
    # that don't respect robots.txt) from crawling the content while still
    # allowing the website to fetch and serve the content.
    #
    # The tokens are set as a comma-separated list of Bearer tokens in the
    # CONTENT_REQUEST_AUTH_TOKENS environment variable.
    #
    # The CONTENT_REQUEST_CANONICAL_HOST environment variable can be set to
    # redirect the request to a canonical host if the request is not authenticated.
    #
    content_request_auth_tokens = (ENV['CONTENT_REQUEST_AUTH_TOKENS'] || '').split(',').map(&:strip).reject(&:empty?)
    content_request_protected = content_request_auth_tokens.any?
  %>

  <% if content_request_protected %>
  # Define a variable to check if the bearer token in the Authorization header is valid
  map $http_authorization $token_auth_status {
    <% content_request_auth_tokens.each do |token| %>
    "Bearer <%= token %>" "allowed";
    <% end %>
  }
  <% end %>

  # / PROTECTED CONTENT REQUESTS

  server {
    listen <%= ENV["PORT"] %>;
    charset UTF-8;
    port_in_redirect off;
    keepalive_timeout 5;

    root <%= ENV['NGINX_ROOT'] || '/app/public' %>;

    # Use our error page instead of the nginx default
    error_page 404 500 /docs/404/index.html;

    # Serve pre-gzipped versions of assets
    gzip_static on;

    <% if ENV['ENABLE_BASIC_AUTH'] == 'true' %>
    # Basic Authentication
    auth_basic "Restricted Access";
    auth_basic_user_file .htpasswd;
    <% end %>

    # Removes trailing slashes everywhere (by redirecting)
    rewrite ^/(.*)/$ <%= ENV['SKIP_HTTPS'] == 'true' ? '$scheme' : 'https' %>://$host/$1 permanent;

    <% unless ENV['SKIP_HTTPS'] == 'true' %>
    # Enforce HTTPS
    if ($http_x_forwarded_proto != "https") {
      return 301 https://$host$request_uri;
    }
    <% end %>

    # Apply our redirects before rewriting
    if ($redirected_url != "none") {
      rewrite ^ $redirected_url permanent;
    }

    location ~* \.(json|yaml)$ {
      # Only do CORS checks on preflight requests
      if ($request_method = OPTIONS) {
        <%= cors_headers %>
        return 204;
      }

      more_set_headers 'Access-Control-Allow-Origin: *';
    }

    # Optimize for pre-compiled assets scattered all over the place
    location ~* \.(js|css|jpg|jpeg|gif|svg|png|woff|woff2)$ {
      expires 1y;
      more_set_headers 'Cache-Control: public';

      # Some browsers still send conditional-GET requests if there's a
      # Last-Modified header or an ETag header even if they haven't
      # reached the expiry date sent in the Expires header.
      more_clear_headers 'Last-Modified';
      more_clear_headers 'ETag';

      # This sets headers for our fonts to be served from any domain, and makes
      # CDN access seamless. The wildcard is 'acceptable', because we restrict the
      # type to font files only.
      location ~* \.(woff|woff2)$ {
        more_set_headers 'Access-Control-Allow-Origin: *';
      }

      # Set explicit allowed origin for svg/png that are requested by methods that need
      # explicit headers like "fetch"
      location ~* \.(svg|png)$ {
        <%= cors_headers %>
      }

      # Stop processing here and 404 if the asset/pack doesn't exist
      break;
    }

    # Optimize for pre-compiled assets in the static directory
    location ~ ^/static/ {
      expires 1y;
      more_set_headers 'Cache-Control: public';

      # Some browsers still send conditional-GET requests if there's a
      # Last-Modified header or an ETag header even if they haven't
      # reached the expiry date sent in the Expires header.
      more_clear_headers 'Last-Modified';
      more_clear_headers 'ETag';

      # Stop processing here and 404 if the asset/pack doesn't exist
      break;
    }

    location / {
      # Remove the .html extension here so it can fall through to the @html_auth location
      rewrite ^/(.*)\.html$ /$1 break;

      <% if content_request_protected %>
      # Serve the file if it exists, otherwise try to authenticate
      # (.html requests won't match here, they'll go to the @html_auth location)
      try_files $uri @html_auth;
      <% else %>
      # Serve the file if it exists, try index.html for paths without a trailing slash, otherwise 404
      try_files $uri $uri/index.html $uri/ =404;
      <% end %>
    }

    <% if content_request_protected %>
    # Authenticate .html requests by checking the token_auth_status variable
    # which is set in the map block earlier in this file.
    location @html_auth {
      if ($token_auth_status != "allowed") {
        # .html request without authentication, so handle it here by 404ing or redirecting to the canonical host
        # depending on whether CONTENT_REQUEST_CANONICAL_HOST is set or not
        <% if host = ENV['CONTENT_REQUEST_CANONICAL_HOST'] %>
        return 301 <%= ENV['SKIP_HTTPS'] == 'true' ? '$scheme' : 'https' %>://<%= host %>$uri;
        <% else %>
        return 404;
        <% end %>
      }

      # If the request is authenticated, break out of the location block and serve the file
      try_files $uri.html $uri/index.html $uri/ =404;
    }

    # Don't serve files with the .html extension here, send them to the canonical location
    location ~* \.html$ {
      # If the request is authenticated, break out of the location block and serve the file
      if ($token_auth_status = "allowed") {
        break;
      }

      # .html request without authentication, so handle it here by 404ing or redirecting to the canonical host
      # depending on whether CONTENT_REQUEST_CANONICAL_HOST is set or not
      <% if host = ENV['CONTENT_REQUEST_CANONICAL_HOST'] %>
      return 301 <%= ENV['SKIP_HTTPS'] == 'true' ? '$scheme' : 'https' %>://<%= host %>$uri;
      <% else %>
      return 404;
      <% end %>
    }
    <% end %>
  }
}
