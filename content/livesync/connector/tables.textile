---
title: Tables
product: Livesync
---

h2(#outbox-table). Outbox Table

The Ably Database Connector uses the "outbox pattern":https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/transactional-outbox.html to send realtime, application-defined change events via Ably's global edge messaging platform. The outbox pattern enables  you to reliably publish an ordered sequence of change event messages over Ably, providing  exactly-once delivery guarantees.

The outbox pattern uses an outbox table that you create in your database.

The Database Connector automatically observes new records written to the outbox table and publishes them as messages over Ably channels.

When your backend server processes a request to update data in your database, it should write a corresponding change event to the outbox table in the same transaction as the underlying mutation.

```
BEGIN;
-- mutate your data, e.g.:
INSERT INTO posts (title) VALUES ('New post!');
-- write change event to outbox, e.g.:
INSERT INTO outbox (channel, name, ...) VALUES ('posts', 'create', ...);
COMMIT;
```

The Database Connector will publish the change event, written to the outbox, to the Ably channel in the exact order in which the underlying change to the data is committed to the database.

The Database Connector automatically deletes records from the table when records are successfully processed.

Note: the Database Connector will always keep at least one outbox record in the table, specifically the  one with the largest @sequence_id@. This record is still marked as processed via a tombstone and will be deleted when subsequent records are written to the outbox. This approach ensures  that the backend endpoint called by your @sync function@ can always obtain the @sequence_id@ at the time that the state is read from the database. For more information, see "Sync:"/livesync/models/sync.

h3(#why-outbox-pattern). Why Use an Outbox Pattern?

Clients using the Models SDK observe changes to database state by consuming a stream of ordered database change events.An update to the data in the database must happen atomically with broadcasting the corresponding change event to ensure that all clients see a consistent view of the data.

The Database Connector uses an outbox table to capture change events like this. When you update data in the database, you write a change event record to the outbox in the same database transaction as the update. This process ensures that change event records are written atomically to the outbox with the underlying update in the correct order.

The Database Connector automatically retries failed publishes and only marks records as processed in the outbox after successfully publishing. It uses idempotent publishing to ensure that messages are delivered without duplication (exactly-once).

An additional  benefit of the outbox pattern is that it decouples the underlying database schema from the change event schema published over Ably. This separation lets you adapt your database schema and data models without altering the code of your subscribing applications.

With explicit outbox writes, you maintain complete control over which data changes trigger publishes, enabling you to synchronise only the changes required by your application.

You also have total authority over the channels to which change events are published:

* You can distribute change notifications across various channels according to the requirements of your application.
* Channels provide a mechanism for data access control via channel "capabilities":/docs/auth/capabilities.

Finally, the Database Connector only needs to interact with the outbox and nodes tables and does not rely on any other state in the database. This simplifies the security model as the Database Connector’s permissions can be locked down to specific tables. For more information, see "Permissions/livesync/connector/setup".


h3(#schema). Schema

This table describes the schema of the outbox table in your database:


|_. Field |_. Type |_. Required on write? |_. Example Value |_. Description |
| sequence_id | Serial integer (primary key) | No (automatically assigned) | 1 | Monotonically increasing identifier that determines publish order within the scope of the channel. |
| mutation_id | String | Yes | 680f3f78-21ec-49a0-be99-25f89a84f232 | The ID of the mutation, used for correlating outbox events with client-side changes. |
| channel | String | Yes | documents | The Ably channel name on which to publish this change. |
| name | String | Yes | edit | The message event name to use when publishing the message. |
| rejected | Boolean | No (defaults to FALSE) | FALSE | True if the event rejects a client side change, false to confirm the change. Defaults to false (confirming the change). |
| data | JSON | Yes | { "read": false, "data": { "timestamp": 1674744488658, "body": "Lorem ipsum" } } | The message payload to use when publishing the message. |
| headers | JSON | No (optional) | { "id": 123, "type": "document", "author": "socrates", "pages": [1, 5, 7] } | A set of message attributes, provided under the headers key in the message extras. These are optional properties that may contain metadata and/or ancillary payloads. |
| locked_by | String | No (implementation detail) | 0d6c0277-e88a-4dba-a854-e80a4bd75317 | The ID of the node that has locked this record. This is an implementation detail of how the Database Connector processes records and you should not set a value for this column when inserting an outbox record. |
| lock_expiry | Timestamp | No (implementation detail) | 2023-06-12 16:24:27 | The timestamp at which the lock will expire. This is an implementation detail of how the Database Connector processes records and you should not set a value for this column when inserting an outbox record. |

h3(#change-detection). Change Detection

By default, the Database Connector currently uses a “poll on change” strategy to query for new records to process when inserted into the outbox. This is the strategy used with the ADBC_POLL_FIXED_RATE configuration option is set to false (which is the default), achieved through the use of a "trigger":https://www.postgresql.org/docs/current/sql-createtrigger.html configured on the outbox table. The trigger invokes a "function":https://www.postgresql.org/docs/current/sql-createfunction.html#:~:text=Use%20CREATE%20OR%20REPLACE%20FUNCTION%20to%20change%20a%20function%20definition,the%20owner%20of%20the%20function. which uses "NOTIFY:https://www.postgresql.org/docs/current/sql-notify.html" to broadcast a notification to the Database Connector, which it receives using "LISTEN":https://www.postgresql.org/docs/current/sql-listen.html. For more information, see "Applying Migrations Manually":livesync/connector/setup.

Internally, the Database Connector debounces notifications within a window determined by the @ADBC_POLL_INTERVAL@ configuration option.

This approach avoids imposing additional load on the database due to polling when there are no new records to process.

Alternatively, you can configure the Database Connector to periodically poll for new records with an interval determined by the @ADBC_POLL_INTERVAL@ configuration option by setting @ADBC_POLL_FIXED_RATE@ to @true@.

Check the available "configuration options":livesync/connector/configuration for more information about how to tune the change detection behaviour.

To avoid polling or triggers, the intention is  intend to support a "WAL":https://www.postgresql.org/docs/current/wal-intro.html-based approach to change data capture in the future. If this is a feature that is of interest to you, please "reach out":https://docs.google.com/forms/d/e/1FAIpQLSd00n1uxgXWPGvMjKwMVL1UDhFKMeh3bSrP52j9AfXifoU-Pg/viewform.

h2(#nodes-table). Nodes Table

The Database Connector can operate as a cluster to provide fault tolerance. Work is automatically re-distributed across available nodes in the event of failures.

Each node within the cluster must receive information about all other nodes to process outbox records efficiently across the available Database Connector nodes. 

The nodes table must also exist in your database, but as an application developer, you do not need to interact with this table directly.

For more information about creating the nodes table in your database, see "Creating the Tables":livesync/connector/setup.

h3(#nodes-discovery). Node Discovery

Nodes discover one another using a *nodes table* that contains a row for each node in the cluster.

When a node starts up, it generates a unique ID and adds to the nodes table. When the node shuts down, it removes itself from the table.

Each node in the table includes an expiry timestamp, set to a time in the future according to the @ADBC_HEARTBEAT_TIMEOUT@ configuration option. Periodically, each node sends a heartbeat to the database by updating its expiry in the nodes table. It will eventually expire if a node cannot communicate with the database. The Database Connector automatically removes expired nodes from the table.

h3(#nodes-schema). Schema

This table describes the schema of the nodes table in your database:

|_. Field |_. Type |_. Description |
| id | Text (primary key) | UUID for the node in the table. |
| expiry | Timestamp | Timestamp after which the node is considered no longer active. |

