---
title: Channels
meta_description: "Channels are used to organize message traffic within Ably."
languages:
  - csharp
  - flutter
  - java
  - javascript
  - nodejs
  - objc
  - php
  - python
  - ruby
  - swift
  - go
redirect_from:
  - /rest/channels
  - /rest/versions/v1.1/channels
  - /rest/versions/v1.0/channels
  - /rest/versions/v0.8/channels
  - /rest/channels-messages
  - /rest/versions/v0.8/channels-messages
  - /rest/beta
  - /rest/batch
  - /realtime/channels
  - /realtime/versions/v1.1/channels
  - /realtime/versions/v1.0/channels
  - /realtime/versions/v0.8/channels
  - /realtime/channels-messages
  - /realtime/versions/v0.8/channels-messages
  - /core-features/channels
  - /core-features/versions/v1.1/channels
  - /core-features/pubsub
  - /core-features/versions/v1.1/pubsub
  - /general/channel-rules-namespaces
  - /general/versions/v1.1/channel-rules-namespaces
  - /general/versions/v1.0/channel-rules-namespaces
  - /general/versions/v0.8/channel-rules-namespaces
---

Channels are used to separate "messages":/channels/messages into different topics. They provide a way to implement the Publish-Subscribe (Pub/Sub) architectural pattern. Pub/Sub enables any number of publishers to publish messages to a channel, and any number of subscribers to be subscribed to a channel to receive them, with publishers and subscribers completely decoupled from one another.

Clients can subscribe to channels and publish messages using the realtime interface of an Ably SDK. Clients can only publish messages when using the REST interface.

<aside data-type='note'>
<ul><li>Channel names are case sensitive</li>
<li>They can't start with @[@ or @:@</li>
<li>They can't be empty</li>
<li>They can't contain newline characters</li></ul>
<p>While Ably doesn't limit the length of channel names, we recommend you keep them under 2048 characters, since some older browsers have trouble with long URLs.</p>
</aside>


h2(#namespaces). Channel namespaces

Channel namespaces enable channels to be grouped together based on a prefix that is included as part of the channel name. A colon @:@ is used to delimit a channel namespace, that is, a namespace is the first segment of a channel name up until the first colon. If a channel name does not contain a colon, the namespace is the entire channel name.

The following are examples of channels that are all part of the 'customer' namespace:

* @customer@
* @customer:tracking-id@
* @customer:order:update@

Namespaces can be used to apply operations to all channels within the namespace, such as "capabilities":/auth/capabilities, "channel rules":#rules and "integration rules":/general/integrations. Namespaces are not required to refer to a set of channels within a capability. A resource specifier, such as @foo:*@, a glob expression, will match a channel named @foo:bar@, even without a @foo@ namespace.

<aside data-type='note'>
In addition to the restrictions on channel names above, a namespace cannot contain the wildcard character @*@.
</aside>

h3(#batch-publish). Batch publish

It is possible to publish messages to multiple channels with a single request. A batch request queries an API multiple times with single HTTP request. A batch request has a single set of request details containing the request body, parameters and headers. These are converted into an array of requests to the underlying API. Each individual request to the underlying API is performed in parallel and may succeed or fail independently.

The following is an example of a batch publish request using the "@request()@":/api/rest-sdk#request method to query the "batch REST API":/api/rest-api#batch-publish

```[rest_javascript]
const ablyRest = new Ably.Rest({ key: '{{API_KEY}}' })
const content = { 'channels': [ 'test1', 'test2' ], 'messages': { 'data': 'myData' } }
const batchPublish = await ablyRest.request('post', '/messages', null, content, null);

console.log('Success! status code was ' + batchPublish.statusCode)
```

```[rest_python]
ably_rest = AblyRest(key='{{API_KEY}}')

content = {
    "channels": ["test1", "test2"],
    "messages": {
        "data": 'myData'
    }
}

response = await ably_rest.request('POST', '/messages', body=content)

if response.is_success:
    print('Success! status code was', response.status_code)
else:
    print('An error occurred; err =', response.error_message)
```

```[rest_java]
ClientOptions options = new ClientOptions("{{API_KEY}}");
AblyRest ablyRest = new AblyRest(options);

JsonObject content = new JsonObject();
Gson gson = new Gson();

content.add("channels", gson.toJsonTree(new String[]{"test1", "test2"}));
JsonObject messages = new JsonObject();
messages.addProperty("data", "myData");
content.add("messages", messages);

final HttpCore.RequestBody body = HttpUtils.requestBodyFromGson(content, ablyRest.options.useBinaryProtocol);
HttpPaginatedResponse response = ablyRest.request("POST", "/messages", null, body, null);

System.out.println("Success! Status code was " + response.statusCode);
```

```[rest_php]
$rest = new Ably\AblyRest(
    ['key' => '{{API_KEY}}']
);
$content = ['channels' => ['test1', 'test2'], 'messages' => ['data' => 'myData']];
$batchPublish = $rest->request('POST', '/messages', [], $content);

echo('Success! status code was ' . $batchPublish->statusCode);
```

```[rest_go]
rest, err := ably.NewREST(
  ably.WithKey("{{API_KEY}}"),
)
if err != nil {
  log.Fatalf("Error creating Ably client: %v", err)
}

type Message struct {
  Data string `json:"data"`
}

type Content struct {
  Channels []string `json:"channels"`
  Messages Message  `json:"messages"`
}

// Create an instance of the Content structure
content := Content{
  Channels: []string{"test1", "test2"},
  Messages: Message{
    Data: "myData",
  },
}

response, err := rest.Request(
  "POST",
  "/messages",
  ably.RequestWithBody(content)).Pages(context.Background())

if err != nil {
  log.Fatalf("An error occurred; err = %v", err)
}
log.Printf("Success! status code was = %v", response.StatusCode())
```

h4(#batch-requests). Batch requests

Each batch publish request can contain a single @BatchSpec@ object, or an array of @BatchSpec@ objects. Each @BatchSpec@ object contains a single channel name or an array of channel names in the @channels@ property. The @messages@ property then contains a single message or an array of messages. Each @BatchSpec@ will then publish each of its messages to each of its channels.

For each channel, the messages grouped into a single @BatchSpec@ are published atomically. This means that:

* Either they will all be successfully published or none of them will
* The "max message size":/pricing/limits#message limit applies to the total size of all messages in in a @BatchSpec@
* Each @BatchSpec@ will only count as a single message for the purpose of the "per-channel rate limit":/pricing/limits#message

So if you do not need the atomicity guarantee and might be in danger of exceeding the max message size limit, you can put each message into its own @BatchSpec@ (relative ordering will still be preserved). Conversely, if you are publishing many hundreds of small messages and are in danger of exceeding the max per-channel message rate, you group them into a fewer @BatchSpecs@.

The batch request as a whole is subject to the following limits:

* Each request can only include 100 different channels. If the same channel name appears in multiple @BatchSpec@ objects within a single request, it only counts as one channel towards the 100 channel limit per batch request.
* Each request has a maximum body size of 2MiB.

The following is an example of a single @BatchSpec@ object publishing a single message to 2 channels:

```[text]
{
  channels: ['channel1', 'channel2'],
  messages: {data: 'My message contents'}
}
```

The following is an example of an array of @BatchSpec@ objects. The first publishes a single message to two channels and the second publishes two messages to a single channel:

```[text]
[
  {
    channels: ['channel1', 'channel2'],
    messages: {data: 'My message contents'}
  },
  {
    channels: 'channel3',
    messages: [
      {data: 'My message contents'},
      {name: 'an event', data: 'My event message contents'},
    ]
  }
]
```

The following is an example curl request, querying the "REST API":/api/rest-api#batch-publish directly:

```[sh]
curl -X POST https://rest.ably.io/messages \
    -u "{{API_KEY}}" \
    -H "Content-Type: application/json" \
    --data '{ "channels": [ "test1", "test2"],
"messages": {"data": "My test message text" } }'
```

h4(#batch-responses). Batch responses

Once all requests have been completed in a batch request, a batch response is returned with three possible outcomes:

- Success := If all of the individual requests were successful then an array containing the response of each query is returned in request order.
- Failure := If the batch request itself failed before the individual requests were made, then an error response is returned with a status code and error response body. Examples of why the batch request can fail include an authorization failure or an invalid request.
- Partial success := If one or more of the individual requests failed the response body contains an error object with the error code @40020@ and a status code of @400@. The error body contains a @batchResponse@ array of each individual response in request order. The @batchResponse@ can be inspected if there is a need to know the details of each outcome. If you only need to know whether or not the batch request was completely successful then the status code is sufficient.

The examples for each possible outcome will use the following @BatchSpec@ object as the request data:

```[text]
{
  channels: ['channel0', 'channel1', 'channel2'],
  messages: {data: 'My test message text'}
}
```

The following is an example of a successful batch publish response. The response body contains the @messageId@ of each published message and the @channel@ it was published to. The status code is @201@:

```[json]
[
  {
    "channel":"channel0",
    "messageId":"w234r5t-fr5"
  },
  {
    "channel":"channel1",
    "messageId":"vde4sfc0p"
  },
  {
    "channel":"channel2",
    "messageId":"nh3exv8ih"
  }
]
```

The following is an example of a batch publish failure response. The response body contains the details of the @error@, in this example that the token used for the request has expired. The status code is @401@:

```[json]
{
  "error": {
    "message":"Token expired",
    "statusCode":401,
    "code":40140
  }
}
```

The following is an example of a batch publish partial success response. The successful requests contain the @messageId@ of each published message and the @channel@ they were published to. The failed request contains the @channel@ the request failed for and the details of the @error@, in this example that the credentials used didn't have the capability to publish to that channel. The status code for a partial success is always @400@:

```[json]
{
  "error": {
    "message": "Batched response includes errors",
    "statusCode":400,
    "code":40020
  }
  "batchResponse": [
    {
      "channel":"channel0",
      "messageId":"w234r5t-fr5"
    },
    {
      "channel":"channel1",
      "messageId":"vde4sfc0p"
    },
    {
      "channel":"channel2",
      "error": {
        "message": "Given credentials do not have the required capability",
        "statusCode": 401,
        "code": 40160
      }
    }
  ]
}
```

h3(#server-side-batching). Server-side batching

Server-side batching optimizes message processing and delivery by grouping multiple messages into batches before sending them to subscribers. This feature reduces the overall message count, lowers costs, and mitigates the risk of hitting rate limits during high-throughput scenarios.

Server-side batching is currently in beta status.

h4. Key benefits

* Cost efficiency.
* Message rate limit mitigation.

h4. Use cases

The following use cases explain the benefits of server-side batching:

* *High-volume chat applications*
** Chat platforms experience large spikes in message volumes during live events like sports games or concerts. This scenario increases costs and risks hitting message rate limits.
** Server-side batching groups multiple chat messages and reactions into single batches before delivery, reducing the number of individual messages processed and maintaining a seamless user experience.
* *Fan engagement platforms*
** Sports fan apps see surges in reactions during key moments, like goals, causing spikes in message volume.
** Server-side batching combines multiple reactions into batches before sending them, managing high volumes efficiently and preventing rate limits from being exceeded.

h4. How server-side batching works

The server-side batching process works through a *batching policy* and a *batching interval:*

h5. Batching policy

The batching policy defines the rules and behaviors for aggregating messages during the batching interval. The supported *_simple_* policy groups multiple incoming messages into a single batch without altering their content or metadata.

A batch can contain up to 200 messages by count or total data size. For example, if you have 210 messages, they will be split into two batches: one with 200 messages and another with 10 messages. If the combined data size of 200 messages exceeds the batch data limit, the excess bytes will be allocated to a new batch as separate messages.

h5. Batching interval

The batching interval is a configurable period specified in milliseconds _ranging from 20ms to 1s_, during which incoming messages are collected and grouped into a batch. Messages sent to the server during this interval are temporarily held and aggregated. Once the interval elapses, the collected messages are combined into a single batch and delivered to subscribers as one message.

h5. Choose the right interval for your app

* Longer intervals are preferred for cost efficiency.
* Align the interval with the expected user experience.

h4. Configure server-side batching

The following steps take you through the server-side configuration process:

# On your "dashboard":https://ably.com/accounts/any, select one of your apps.
# Go to *settings*.
# Under "channel rules":#rules, add a *new rule*.
# Enter the *namespace* or *channel ID* to which you want to add a new rule.
# Select *server-side batching enabled*.
# Choose a batching policy (only *simple* is supported in beta).
# Choose an interval range value from 20ms to 1s.
# Click *create channel rule* to save.

h5. Configuration defaults

The following defaults apply when no configuration settings are specified:

# If no batching policy is specified, *simple* is used.
# If no interval value is specified, the default is 20ms.

h2(#options). Channel options

"Channel options":/channels/options can be used to customize the functionality of channels. This includes enabling features such as "encryption":/channels/options/encryption and "deltas":/channels/options/deltas, or for a client to retrieve messages published prior to it attaching to a channel using "rewind":/channels/options/rewind.

h2(#metadata). Channel metadata

"Metadata":/metadata-stats/metadata provides additional information about apps or channels. It includes uses such as enabling clients to be aware of how many other clients are attached to a channel without the need to use the "presence":/presence-occupancy/presence feature. Examples of channel metadata available include the status and occupancy of specific channels.

h2(#rules). Channel rules

Channel rules can be used to enforce settings for specific channels, or channel namespaces. They can be broadly categorized into three different types:

* For message storage
* For client security and identification
* To enable features for a channel or namespace

The channel rules related to message storage are:

- Persist last message := if enabled, the very last message published on a channel will be stored for a year. This message is retrievable using "rewind":/channels/options/rewind by attaching to the channel with @rewind=1@. If you send multiple messages in a single protocol message, for example calling @publish()@ with an array of messages, you would receive all of them as one message. Be aware that presence messages are not stored and that messages stored in this manner are not accessible using "history":/storage-history/history. Note that for each message stored using this rule, an additional message is deducted from your monthly allocation.
- Persist all messages := if enabled, all messages published on a channel will be stored according to the storage rules for your account. This is 24 hours for free accounts and 72 hours for paid accounts. Messages stored in this manner are accessible using "history":/storage-history/history. Note that for each message stored using this rule, an additional message is deducted from your monthly allocation.
- Server-side batching := if enabled, messages are grouped into batches before being sent to subscribers. "Server-side batching":#server-side-batching reduces the overall message count, lowers costs, and mitigates the risk of hitting rate limits during high-throughput scenarios.

The channel rules related to security and client identity are:

- Identified := if enabled, clients will not be permitted to use (including to attach, publish, or subscribe) matching channels unless they are "identified":/auth/identified-clients (they have an assigned client ID). Anonymous clients are not permitted to join these channels. Find out more about "authenticated and identified clients":/auth/identified-clients.
- TLS only := if enabled, only clients who have connected to Ably over TLS will be allowed to use matching channels. By default all of Ably's client libraries use TLS when communicating with Ably over REST or when using our Realtime transports such as Websockets.

The channel rules related to enabling features are:

- Push notifications enabled := If checked, publishing messages with a push payload in the @extras@ field is permitted. This triggers the delivery of a "Push Notification":/push to devices registered for push on the channel.

<!-- DASHBOARD-INSTRUCTION: Setting a channel rule -->
To set a channel rule in the Ably dashboard:

1. Sign in to your Ably account.
2. Select an app.
3. Go to **Settings** tab.
4. Click **Add new rule**.
5. Select channel name or namespace to apply rules to.
6. Check required rules.

h2(#history). Channel history

Channel "history":/storage-history/history enables clients to retrieve messages that have been previously published on the channel. Messages can be retrieved from history for up to 72 hours in the past, depending on the "persistence":/storage-history/storage configured for the channel.

h2(#presence). Presence

The "presence":/presence-occupancy/presence feature enables clients to be aware of other clients that are 'present' on the channel. Client status is updated as they enter or leave the presence set. Clients can also provide an optional payload describing their status or attributes, and trigger an update event at any time.
