---
title: Queues
meta_description: "Configure and manage message queues for your Ably application to ensure reliable message processing and delivery."
meta_keywords: "Ably queues, message queues, reliable messaging, queue configuration, message processing"
redirect_from:
  - /docs/account/app/queues
---

Configure and manage message queues for your Ably application to ensure reliable message processing and delivery.

Message queues provide reliable, ordered message delivery with durability guarantees, perfect for critical business processes and workflows.

## Accessing queue management

To manage queues for your application:

1. Navigate to your application dashboard
2. Click the Queues tab
3. View existing queues and create new ones

## Understanding Ably queues

### What are message queues

Ably queues provide:

- Reliable delivery - Messages are persisted until successfully processed
- Ordered processing - Messages are delivered in the order they were published
- Durability - Messages survive network issues and service restarts
- Scalable processing - Multiple consumers can process messages in parallel

### Queue vs. channels

Key differences between queues and channels:

| Feature | Channels | Queues |
| ------- | -------- | ------ |
| Delivery guarantee | At most once | At least once |
| Message persistence | Temporary (minutes to hours) | Until processed |
| Processing model | Pub/Sub (broadcast) | Point-to-point (single consumer) |
| Ordering | No guarantee | First-in-first-out (FIFO) |
| Use case | Real-time updates | Reliable workflows |

### Queue architecture

Queues consist of:

- Publishers - Applications that send messages to queues
- Queue storage - Persistent storage for unprocessed messages
- Consumers - Applications that receive and process messages
- Dead letter handling - Management of failed messages

## Queue configuration

### Creating a new queue

To create a queue:

1. Click Create new queue on the queues page
2. Configure queue settings:
   - Queue name - Unique identifier for the queue
   - Region - Geographic location for optimal performance
   - Message TTL - How long messages remain in the queue
   - Max length - Maximum number of messages to store
   - Dead letter policy - How to handle failed messages

### Queue settings

| Setting | Description | Options |
| ------- | ----------- | ------- |
| Name | Unique queue identifier | Alphanumeric with dashes/underscores |
| Region | Geographic placement | us-east-1, eu-west-1, ap-southeast-1, etc. |
| TTL (Time To Live) | Message expiration time | 1 minute to 14 days |
| Max length | Queue capacity limit | 1 to 10,000 messages |
| Dead letter queue | Failed message handling | Enable/disable with retry limits |

### Dead letter queues

Configure handling for failed messages:

- Retry attempts - How many times to retry failed messages
- Dead letter destination - Where failed messages are moved
- Failure reasons - Track why messages failed processing
- Recovery options - Ability to reprocess dead letter messages

## Publishing to queues

### Publishing messages

Send messages to queues using the REST API:

<Code>
```bash
curl -X POST https://rest.ably.io/queues/your-queue-name/messages \
  -H "Authorization: Basic YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"name": "event-name", "data": {"key": "value"}}'
```
</Code>

### Message format

Queue messages include:

| Field | Description | Required |
| ----- | ----------- | -------- |
| name | Event name or message type | No |
| data | Message payload | Yes |
| id | Unique message identifier | No (auto-generated) |
| timestamp | Message creation time | No (auto-generated) |

### Publishing patterns

Common publishing approaches:

- Direct publishing - Send messages directly to queues
- Channel to queue - Route channel messages to queues via rules
- Batch publishing - Send multiple messages in a single request
- Conditional publishing - Publish based on specific conditions

## Consuming from queues

### Setting up consumers

Configure message consumption:

1. Consumer endpoint - URL that receives messages
2. Authentication - Headers for secure message delivery
3. Concurrency - Number of parallel message deliveries
4. Retry policy - How to handle delivery failures

### Consumer configuration

| Setting | Description |
| ------- | ----------- |
| Endpoint URL | HTTPS URL that receives queue messages |
| HTTP method | Request method (typically POST) |
| Headers | Authentication and custom headers |
| Timeout | Maximum time to wait for response |
| Concurrent deliveries | Number of parallel message sends |

### Message acknowledgment

Handle message processing confirmation:

- Automatic acknowledgment - Messages acknowledged on successful HTTP response
- Manual acknowledgment - Explicit confirmation required
- Negative acknowledgment - Reject messages for retry
- Processing timeouts - Automatic retry after timeout

### Consumer best practices

Design effective consumers:

- Idempotent processing - Handle duplicate message delivery safely
- Fast processing - Minimize processing time to improve throughput
- Error handling - Distinguish between temporary and permanent failures
- Monitoring - Track consumer health and performance

## Queue monitoring

### Queue metrics

Monitor queue performance:

| Metric | Description |
| ------ | ----------- |
| Queue length | Number of messages waiting for processing |
| Message rate | Messages published and consumed per second |
| Processing latency | Time from publish to successful consumption |
| Error rate | Percentage of failed message deliveries |
| Consumer status | Health and availability of message consumers |

### Monitoring dashboard

The queue dashboard shows:

- Real-time metrics - Current queue state and activity
- Historical data - Trends over time for capacity planning
- Alert thresholds - Warnings for unusual queue behavior
- Consumer health - Status of configured message consumers

### Setting up alerts

Configure notifications for:

- Queue length thresholds - When queues become too full
- Consumer failures - When message delivery fails repeatedly
- Processing delays - When message latency exceeds thresholds
- Dead letter accumulation - When failed messages pile up

## Queue management operations

### Scaling queues

Manage queue capacity:

- Increase max length - Allow more messages in the queue
- Add consumers - Increase processing capacity
- Regional distribution - Use multiple queues across regions
- Load balancing - Distribute messages across multiple queues

### Queue maintenance

Regular maintenance tasks:

- Monitor queue length - Ensure queues don't become overwhelmed
- Review dead letter messages - Investigate and resolve failures
- Update consumer endpoints - Maintain healthy message processing
- Optimize queue settings - Adjust TTL and capacity based on usage

### Queue cleanup

Manage old or failed messages:

- Purge messages - Clear all messages from a queue
- Delete expired messages - Remove messages past their TTL
- Reprocess dead letters - Retry failed messages after fixes
- Archive old queues - Remove unused queues to reduce clutter

## Advanced queue patterns

### Queue chaining

Connect multiple queues for complex workflows:

1. Primary processing - Initial message handling
2. Secondary processing - Additional workflow steps
3. Final processing - Completion and cleanup
4. Error handling - Failed message recovery

### Priority queues

Implement message prioritization:

- Multiple queues - Separate queues for different priorities
- Consumer routing - Direct consumers to process high-priority first
- Message tagging - Include priority information in messages
- Dynamic routing - Route based on message content or source

### Queue patterns for reliability

Design for high reliability:

- Duplicate detection - Handle duplicate messages gracefully
- Message ordering - Maintain processing order when required
- Failure isolation - Prevent failed messages from blocking others
- Recovery procedures - Plan for queue and consumer failures

## Troubleshooting common issues

### Queue performance problems

| Issue | Cause | Solution |
| ----- | ----- | -------- |
| Growing queue length | Consumer too slow or down | Scale consumers or fix consumer issues |
| High message latency | Queue overloaded | Add more consumers or optimize processing |
| Message delivery failures | Consumer endpoint problems | Check endpoint health and configuration |
| Dead letter accumulation | Permanent processing errors | Investigate and fix root cause |

### Consumer issues

Common consumer problems:

- Authentication failures - Verify consumer endpoint credentials
- Timeout errors - Increase timeout or optimize processing
- HTTP errors - Check consumer endpoint implementation
- Network issues - Verify connectivity and DNS resolution

### Message processing errors

Handle processing failures:

- Temporary failures - Implement retry with exponential backoff
- Permanent failures - Move to dead letter queue for investigation
- Duplicate processing - Design idempotent message handlers
- Ordering violations - Ensure single-threaded processing when order matters

Message queues provide reliable, durable message processing capabilities that complement Ably's real-time pub/sub messaging for building robust, scalable applications.