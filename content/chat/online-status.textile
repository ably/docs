---
title: Online status
meta_description: "Display the online status of members to indicate whether they are currently active in a channel, or not."
product: chat
languages:
  - javascript
---

Indicate within a chat application, whether members are online, or not with a visual indicator.

<img src="/images/products/chat/member-list.png" alt="Example of a column of members categorised by their role, also displaying their online status.">

h2(#events). Online status

When a member enters, leaves, or updates their data in a channel's presence set, an event is emitted to all subscribers in that channel's presence set.

The following presence events are emitted:

- Enter := a new member has entered the channel.
- Leave := a member who was present has now left the channel. This may result from an explicit request to leave or implicitly when detaching from the channel. Alternatively, if a member's connection is abruptly disconnected and they do not resume their connection within a minute, Ably treats this as a leave event as the client is no longer present.
- Update := an already present member has updated their "member data":#member-data. Being notified of member data updates can be very useful. For example, it can update a member's status when they are typing a message.
- Present := when subscribing to presence events on a channel with members present, this event is emitted for every member already present on the channel before the subscribe listener was registered.

Any client using a member's online status must have been "identified":/auth/identified-clients by having a @ClientId@ to be present on a channel. The client also requires the @presence@ "capability":/auth/capabilities to enter the online status presence set and the @subscribe@ capability to subscribe to online status events.

h3(#enter). Enter

The @enter@ method is intentionally initiated by the member, allowing them to signify actions such as marking themselves as online upon logging into the platform. For instance, when dealing with a member represented by a member object featuring a @status@ field, the @enter@ event can be triggered using the provided code snippet below. This code sets the status of the member to @online@, indicating their entry to the chat.

```[javascript]
channel.presence.enter((err) => {
  // Custom functionality to update UI for member that they are now online.
});
```

h3(#leave). Leave

The @leave@ event occurs either when the member explicitly calls the "@leave()@":/api/realtime-sdk/presence#leave function, implicitly detaches from the channel, or if the member's connection is disconnected and they don't resume their connection within a minute. Providing a means to signify actions such as marking themselves as offline or logging out of the platform. For instance, when managing a member represented by a user object featuring a @status@ field, the @leave@ event can be triggered using the provided code snippet below. This code snippet sets the status of the member to @offline@, indicating their departure from the chat platform.

```[javascript]
channel.presence.leave((err) => {
  // Custom functionality to update UI for member that they are no longer online
});
```

h3(#update). Update

The @update@ method is called by the member, updating a string value of their status. For example, if you have a member object (user) with the @statusMessage@ field, you can trigger an @update@ event using the code sample below to update this user with a new text-based string. Another possible feature using @update@ is implementing "typing indicators":/chat/typing into your chat application.

```[javascript]
channel.presence.update('status', (err) => {
  user.statusMessage = 'busy';
});
```

h2(#subscribe). Subscribe members to events

Subscribe members to the presence set to receive realtime updates on other member's statuses and update the UI accordingly. For example, displaying online status icons.

When a member calls the @enter@ method, realtime notifications are dispatched to all subscribers of the associated presence channel. This functionality enables subscribers to promptly update the visual online status of the member, ensuring that everyone in the channel is informed of the current online presence.

```[javascript]
channel.presence.subscribe('enter', (member) => {
  user.online = true
  user.lastOnline = null
});
```

When a member calls the @update@ method, realtime notifications are dispatched to all subscribers of the associated presence channel. This functionality enables subscribers to promptly update their member's status, ensuring that everyone in the channel is informed of the current status.

```[javascript]
channel.presence.subscribe('update', (memberUpdate) => {
  user.status = memberUpdate.data
});
```

When a member calls the @leave@ method, realtime notifications are dispatched to all subscribers for this associated presence channel. This functionality enables subscribers to promptly update the status of the member as offline.

```[javascript]
channel.presence.subscribe('leave', (member) => {
  user.online = false
  user.lastOnline = member.timestamp

  // Custom functionality to update display for member that another member is no longer online
});
```

The message count within a presence set, such as the, online status, can surge as the member number grows. For example, with 200 members rapidly joining and leaving, the potential messages for online status alone could reach 80,400. The breakdown includes:

200 member messages published for the @enter@ event.
200 × 200 (40,000) messages subscribed to for the @enter@ events.
200 member messages published for the @leave@ event.
200 × 200 (40,000) presence messages subscribed to for the @leave@ event.

For improved scalability, consider making your backend server the exclusive subscriber to members online status updates if your chat application anticipates a large number of members. In this scenario, frontend clients can periodically request updates from the backend.

h3(#batch-presence). Batch presence retrieval

You can reduce the amount of traffic between members and realtime presence updates in cases such as a large-scale, live-streaming chat. You can use the @request()@ function available in the REST API. Within a batch response is an array of presence states, where each presence state update contains information about the members in the presence set, including their @clientId@, member data, and "presence action":/docs/api/realtime-sdk/types#presence-action .

The following is an example of a batch presence request using the "request()":/docs/api/rest-sdk#request method to query the "batch REST API":/docs/api/rest-api#batch-presence :

```[rest_javascript]
var ablyRest = new Ably.Rest({ key: '{{API_KEY}}' })
var content = { "channel": "channel1,channel2" }
ablyRest.request('GET', '/presence', content, null, {}, function(err, response) {
  If (err) {
    alert('An error occurred; err = ' + err.toString());
  } else {
    alert('Success! status code was ' + response.statusCode);
  }
});
```

h4(#batch-responses). Batch presence responses

On completion of the batch request, one of three possible responses are returned:

- Success := if all of the individual requests were successful, then an array containing the response of each query is returned in request order.
- Failure := if the batch request failed before the individual requests were made, then an error response is returned with a status code and error response body. Examples of why the batch request can fail include an authorization failure or an invalid request.
- Partial success := if one or more of the individual requests failed, the response body contains an error object with the error code @40020@ and a status code of @400@. The error body contains a @batchResponse@ array of each individual response in request order. The @batchResponse@ can be inspected if there is a need to know the details of each outcome. If you only need to know whether or not the batch request was completely successful, then the status code is sufficient.

The following is an example of a successful batch presence response. The response body contains details of each member present on the channel and the channel they are present on. The status code for a successful response is always @200@:

```[json]
[
  {
    "channel":"channel0",
    "presence":[
      {"clientId": "user1", "action": "1"},
      {"clientId": "user2", "action": "1"}
    ]
  },
  {
    "channel":"channel1",
    "presence":[]
  },
  {
    "channel":"channel2",
    "presence":[
      {"clientId": "user2", "action": "1"},
      {"clientId": "user3", "action": "1"}
    ]
  }
]
```

For more information making batch presence requests please refer to the "Presence documentation":/docs/presence-occupancy/presence#batch


h3(#channel-separation). Channel separation

You can separate channels to avoid a high volume of unnecessary messages. For example, in a large-scale, live-streaming chat application, you can separate all messages, status updates, and typing indicators. For example, one channel for a specific chat ("general") while having another channel for the members' status ("status-general") updates. Your application could then periodically retrieve the members' online status updates from your backend (the exclusive subscriber). When issuing API keys to clients, assign the clients the following "capabilities":/auth/capabilities :

```
{
  "status-general": ["presence"],
  "general": ["publish", "history", "subscribe"],
}
```

Meanwhile the server can also subscribe to the members channel with an api key having the following capabilities:

```
{
  "status-general": ["presence", "subscribe"],
  "general": ["publish", "history", "subscribe"],
}
```

h2(#last-seen). Last seen

Track the last seen timestamp of members in a channel by storing the @leave()@ event. This can be done either locally on each member's client or remotely on the backend server, especially if the chat application has a member database. In large-scale live streaming applications, for example, locally storing the @leave()@ event timestamp on the client is common. The presence set initially displays online members, and as time progresses, it updates with new joiners and leavers. The member list retains leavers' records, indicating their last seen time and offline status.

h2(#remain-present-for). Member timeout

To prevent repeated leave and enter events during unstable connections, clients in a member presence set, by default, remain present for 15 seconds after an abrupt disconnection. This disconnection could occur due to sudden internet dropouts or network changes. The delay avoids sending repeated @leave@ and @enter@ events when a client is experiencing an unstable connection. You can customize the disconnection timeout in the @remainPresentFor@ client configuration.

Any clients that explicitly call @channel.presence.leave@ will immediately be removed from the member presence set.

The following example code demonstrates establishing a connection to Ably with @remainPresentFor@ set to 15 seconds:

```[javascript]
const ably = new Ably.Realtime(
  {
    key: '{{API_KEY}}',
    transportParams: { remainPresentFor: 15000 }
  }
);
```

For more information on handling unstable connections, please refer to the "Presence documentation":/docs/presence-occupancy/presence?lang=javascript#unstable-connections
