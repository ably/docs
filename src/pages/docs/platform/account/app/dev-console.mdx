---
title: Dev console
meta_description: "Use the Ably dev console for real-time development, debugging, and testing of your application's messaging, presence, and connection features."
meta_keywords: "Ably dev console, debugging, real-time testing, development tools, message testing"
redirect_from:
  - /docs/account/app/console
---

Use the Ably dev console for real-time development, debugging, and testing of your application's messaging, presence, and connection features.

The dev console provides interactive tools for testing your Ably integration, debugging connection issues, and monitoring real-time activity during development.

## Accessing the dev console

To use the development console:

1. Navigate to your application dashboard
2. Click the **Dev console** tab
3. Use the interactive tools for testing and debugging

## Console overview

### Development tools available

The dev console provides:

| Tool | Purpose |
| ---- | ------- |
| Connection tester | Establish and test connections to Ably |
| Message publisher | Send test messages to channels |
| Message subscriber | Receive and monitor channel messages |
| Presence manager | Enter, leave, and monitor presence |
| Channel inspector | View channel state and activity |
| Event logger | Monitor all events in real-time |

### Real-time monitoring

The console shows live data for:

- Active connections - Current connections to your application
- Message activity - Messages flowing through channels
- Presence events - Users entering and leaving channels
- Channel lifecycle - Channel attachments and detachments
- Error events - Connection and message errors

### Console interface

The dev console interface includes:

- Connection status - Shows current connection state
- Channel selector - Choose which channel to work with
- Message composer - Create and send test messages
- Event feed - Real-time stream of all activity
- Presence panel - Current presence members and states

## Testing connections

### Establishing connections

Test connection functionality:

1. **Select API key** - Choose which API key to use for testing
2. **Configure options** - Set client ID and connection parameters
3. **Connect** - Establish connection to Ably
4. Monitor status - Watch connection state changes

### Connection parameters

Configure test connections:

| Parameter | Description |
| --------- | ----------- |
| API key | Which API key to use for authentication |
| Client ID | Identifier for the test client |
| Connection options | Additional connection parameters |
| Transport | Preferred connection transport method |

### Connection states

Monitor connection lifecycle:

| State | Description |
| ----- | ----------- |
| Connecting | Attempting to establish connection |
| Connected | Successfully connected to Ably |
| Disconnected | Connection lost or terminated |
| Failed | Connection attempt failed |
| Suspended | Temporarily interrupted connection |

## Message testing

### Publishing messages

Send test messages through the console:

1. **Select channel** - Choose target channel for messages
2. **Compose message** - Enter event name and data
3. **Publish** - Send the message
4. Monitor delivery - Watch for delivery confirmation

### Message composition

Create test messages with:

| Component | Description |
| --------- | ----------- |
| Event name | Optional name for the message event |
| Message data | Payload content (JSON, text, or binary) |
| Client ID | Override client ID for the message |
| Extras | Additional message metadata |

### Message formats

Test different message types:

<Code>
```javascript
// Simple text message
{
  "name": "chat-message",
  "data": "Hello, world!"
}

// JSON data message
{
  "name": "user-update",
  "data": {
    "userId": 123,
    "status": "online",
    "location": "New York"
  }
}

// Binary data message
{
  "name": "file-chunk",
  "data": "[binary data]",
  "encoding": "base64"
}
```
</Code>

### Subscribing to messages

Monitor channel activity:

1. **Attach to channel** - Connect to specific channels
2. **Subscribe to events** - Listen for specific message types
3. **View messages** - See incoming messages in real-time
4. **Filter events** - Show only relevant message types

## Presence testing

### Managing presence

Test presence functionality:

| Action | Description |
| ------ | ----------- |
| Enter presence | Join a channel's presence set |
| Update presence | Modify presence data while present |
| Leave presence | Exit the channel's presence set |
| Get presence | Retrieve current presence members |

### Presence data

Include custom data with presence:

<Code>
```javascript
// Enter presence with custom data
{
  "status": "available",
  "location": "Office",
  "activity": "Working on project"
}

// Update presence data
{
  "status": "busy",
  "activity": "In meeting"
}
```
</Code>

### Monitoring presence events

Track presence activity:

| Event Type | Description |
| ---------- | ----------- |
| Enter | Member joins presence |
| Update | Member updates presence data |
| Leave | Member leaves presence |
| Present | Initial presence state when subscribing |

## Channel management

### Channel operations

Test channel functionality:

| Operation | Description |
| --------- | ----------- |
| Attach | Connect to a channel |
| Detach | Disconnect from a channel |
| Subscribe | Listen for messages on a channel |
| Unsubscribe | Stop listening for messages |
| Get history | Retrieve past messages |

### Channel states

Monitor channel lifecycle:

| State | Description |
| ----- | ----------- |
| Initialized | Channel created but not attached |
| Attaching | Attempting to attach to channel |
| Attached | Successfully attached to channel |
| Detaching | Disconnecting from channel |
| Detached | No longer connected to channel |
| Failed | Attachment failed |

### Channel options

Configure channel behavior:

| Option | Description |
| ------ | ----------- |
| Persist messages | Store messages for history retrieval |
| Presence subscribe | Automatically subscribe to presence events |
| Delta compression | Enable delta compression for efficiency |
| Cipher key | Encrypt channel messages |

## Event monitoring

### Real-time event feed

The console displays all events:

- Message events - Published and received messages
- Presence events - Presence enter, update, and leave
- Connection events - Connection state changes
- Channel events - Channel attach, detach, and errors
- Error events - All error conditions and failures

### Event filtering

Filter events by type:

| Filter | Shows |
| ------ | ----- |
| Messages | Only message publish and receive events |
| Presence | Only presence-related events |
| Connections | Only connection state changes |
| Channels | Only channel lifecycle events |
| Errors | Only error and failure events |

### Event details

Each event displays:

- Timestamp - When the event occurred
- Event type - Category of event
- Channel - Which channel the event relates to
- Client ID - Which client generated the event
- Data - Event payload and metadata
- Status - Success or failure indication

## Debugging tools

### Connection debugging

Diagnose connection issues:

| Tool | Purpose |
| ---- | ------- |
| Connection logs | Detailed connection attempt information |
| Transport fallback | See which transports are attempted |
| Authentication debugging | Verify API key and token issues |
| Network diagnostics | Test network connectivity |

### Message debugging

Troubleshoot message issues:

- Delivery confirmation - Verify messages are published successfully
- Subscription status - Check if clients are properly subscribed
- Message routing - Trace message path through the system
- Error analysis - Investigate failed message operations

### Common debugging scenarios

| Issue | Debugging Approach |
| ----- | ------------------ |
| Messages not received | Check subscription status and channel attachment |
| Connection failures | Review authentication and network connectivity |
| Presence not updating | Verify presence enter/update operations |
| Slow message delivery | Monitor connection quality and message size |

## Development workflows

### Testing new features

Use the console to test new functionality:

1. Plan test scenarios - Define what you want to test
2. Set up test data - Create appropriate test messages and presence
3. Execute tests - Run through scenarios step by step
4. Monitor results - Watch for expected behavior and errors
5. Document findings - Record issues and successful patterns

### Integration debugging

Debug application integration:

1. Replicate issues - Use console to reproduce problems
2. Isolate variables - Test individual components separately
3. Compare behavior - Check console vs. application behavior
4. Identify root cause - Determine source of issues
5. Validate fixes - Test solutions using console

### Performance testing

Test application performance:

- Message throughput - Send high-frequency test messages
- Connection stability - Test long-running connections
- Resource usage - Monitor memory and CPU impact
- Scalability limits - Test with multiple concurrent operations

## Console best practices

### Development workflow integration

Incorporate console into development:

- Regular testing - Use console throughout development process
- Feature validation - Test each new feature before deployment
- Debugging first - Check console before investigating code issues
- Documentation - Record successful test patterns for reuse

### Security considerations

Use console securely:

- Test API keys - Use development keys, not production keys
- Sensitive data - Avoid testing with real user data
- Access control - Limit console access to development team
- Clean up - Remove test data and connections after testing

### Efficiency tips

Use console effectively:

- Bookmark scenarios - Save useful test configurations
- Multiple tabs - Use separate tabs for different test scenarios
- History review - Check previous test results for patterns
- Automated testing - Use console patterns to build automated tests
- CLI integration - Combine console testing with CLI automation

## Console vs CLI testing

### When to use dev console

The dev console is ideal for:

- Interactive testing and debugging
- Visual real-time monitoring
- Quick prototyping and exploration
- Team collaboration and demonstration

### When to use CLI testing

CLI testing is better for:

- Automated test scenarios
- CI/CD pipeline integration
- Performance and load testing
- Scripted testing workflows

The dev console provides essential tools for developing, testing, and debugging real-time applications, helping you build robust integrations with Ably's platform.