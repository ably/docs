---
title: "Getting started: Chat with Jetpack Compose"
meta_description: "A getting started guide for Ably Chat Android that steps through some of the key features using Jetpack Compose."
meta_keywords: "Ably, realtime, quickstart, getting started, basics, Chat, Android, Kotlin, Jetpack Compose"
languages:
  - kotlin
---

This guide will help you get started with Ably Chat in a new Android application
built with Jetpack Compose.

It will take you through the following steps:

* Creating a client and establishing a realtime connection to Ably
* Creating a room and subscribing to its messages
* Sending messages to the room and editing messages
* Retrieving historical messages to provide context for new joiners
* Displaying online status of clients in the room
* Subscribing to and sending reactions
* Disconnecting and resource cleanup

h2(#prerequisites). Prerequisites

h3(#prerequisites-ably). Ably
* Sign up for an Ably account
* Create a new app and get your API key
** You can use the root API key that is provided by default to get started.

* Install the Ably CLI:

```[sh]
npm install -g @ably/cli
```

* Run the following to log in to your Ably account and set the default app and API key:

```[sh]
ably login

ably apps switch
ably auth keys switch
```

<aside data-type='note'>
<p>The code examples in this guide include a demo API key. If you wish to interact with the Ably CLI, ensure that you replace them with your own API key.</p>
</aside>


h3(#prerequisites-create-project). Create a new project

Create a new Android project with Jetpack Compose. For detailed instructions, refer to the "Android Studio documentation":https://developer.android.com/jetpack/compose/setup.

* Create a new Android project in Android Studio
* Select "Empty Activity" as the template
* Name project "Chat Example" and place it in the @com.example.chatexample@ package
* Set minimum SDK level to API 24 or higher
* Use Kotlin as the programming language
* Add the Ably dependencies to your app-level @build.gradle.kts@ file:

```[kotlin]
implementation("com.ably.chat:chat-android:<latest-version>")
// This package contains extension functions for better Jetpack Compose integration.
// It’s experimental for now (safe to use, but the API may change later). You can always use its code as a reference.
implementation("com.ably.chat:chat-extensions-compose:<latest-version>")
```

h2(#providers-setup). Step 1: Setting up the Ably

* Replace the content of your @MainActivity.kt@ file with the following code to set up Ably client:

```[kotlin]
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.Colum
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import java.util.UUID
import com.example.chatexample.ui.theme.ChatExampleTheme
import com.ably.chat.*
import io.ably.lib.realtime.AblyRealtime
import io.ably.lib.types.ClientOptions

class MainActivity : ComponentActivity() {
    private lateinit var realtimeClient: AblyRealtime
    private lateinit var chatClient: ChatClient

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        realtimeClient = AblyRealtime(
            ClientOptions().apply {
                key = "{{API_KEY}}"
                clientId = "my-first-client"
            },
        )

        chatClient = ChatClient(realtimeClient) { logLevel = LogLevel.Info }

        enableEdgeToEdge()
        setContent {
            ChatExampleTheme {
                App(chatClient)
            }
        }
    }
}

@Composable
fun App(chatClient: ChatClient) {
    Scaffold { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            Text("Hello Chat App")
        }
    }
}
```

h2(#step-1). Step 2: Connect to Ably

Clients establish a connection with Ably when they instantiate an SDK. This enables them to send and receive messages in realtime across channels.

* In your @MainActivity.kt@ file, add the following @ConnectionStatusUi@ composable component:

```[kotlin]
// This component will display the current connection status
@Composable
fun ConnectionStatusUi(connection: Connection) {
    val connectionStatus = connection.collectAsStatus()
    Text(
        text = "Connection Status: ${connectionStatus}",
        style = MaterialTheme.typography.bodyMedium,
        modifier = Modifier.padding(start = 8.dp)
    )
}
```

* Then, update the @App@ component to display the connection status using the new @ConnectionStatusUi@ component:

```[kotlin]
@Composable
fun App(chatClient: ChatClient) {
    Scaffold { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            ConnectionStatusUi(connection = chatClient.connection)
        }
    }
}
```

Now run your application by pressing Run button.

h2(#step-2). Step 3: Create a room

Now that you have a connection to Ably, you can create a room. Use rooms to separate and organize clients and messages into different topics, or 'chat rooms'. Rooms are the entry point for Chat, providing access to all of its features, such as messages, presence and reactions.

* In your project, open @MainActivity.kt@, and add a new component called @RoomStatusUi@:

```[kotlin]
@Composable
fun RoomStatusUi(roomName: String, room: Room?) {
    val roomStatus = room?.collectAsStatus()
    Text(
        text = "Room Name: ${roomName}, Room Status: ${roomStatus ?: ""}",
        style = MaterialTheme.typography.bodyMedium,
        modifier = Modifier.padding(start = 8.dp)
    )
}
```

* Then, update your main app component to get and attach to the room and nest the @RoomStatusUi@ component inside it:

```[kotlin]
@Composable
fun App(chatClient: ChatClient) {
    val connectionStatus = chatClient.connection.collectAsStatus()
    val roomName = "my-first-room"
    var room by remember { mutableStateOf<Room?>(null) }
    LaunchedEffect(roomName) {
        val chatRoom = chatClient.rooms.get(roomName)
        chatRoom.attach()
        room = chatRoom
    }
    Scaffold { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            ConnectionStatusUi(connection = chatClient.connection)
            RoomStatusUi(roomName = roomName, room = room)
        }
    }
}
```

The above code creates a room with the ID @my-first-room@ and sets up a listener to monitor the room status. It also displays the room ID and current status in the UI.

<aside data-type='note'>
<p>Monitoring the room status is useful for deciding when to show a loading spinner or other UI elements while waiting for the room to be created or joined.</p>
</aside>

h2(#step-3). Step 4: Send a message

Messages are how your clients interact with one another.

* In your project, open @MainActivity.kt@, and add a new component called @ChatBox@, like so:

```[kotlin]
@Composable
fun ChatBox(room: Room?) {
    val scope = rememberCoroutineScope()
    var textInput by remember { mutableStateOf(TextFieldValue("")) }
    var sending by remember { mutableStateOf(false) }
    val messages = remember { mutableStateListOf<Message>() }

    DisposableEffect(room) {
        val subscription = room?.messages?.subscribe { event ->
            when (event.type) {
                MessageEventType.Created -> messages.add(0, event.message)
            }
        }

        onDispose {
            subscription?.unsubscribe()
        }
    }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
    ) {
        Card(
            modifier = Modifier
                .weight(1f)
                .fillMaxWidth(),
        ) {
            if (messages.isNullOrEmpty()) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = "No messages yet",
                        color = Color.Gray
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(8.dp),
                    reverseLayout = true,
                ) {
                    items(messages.size, key = { messages[it].serial }) {
                        val message = messages[it]
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 4.dp)
                        ) {
                            Text(
                                text = "${message.clientId}: ${message.text}",
                                style = MaterialTheme.typography.bodyMedium
                            )
                            Text(
                                text = SimpleDateFormat("HH:mm:ss", Locale.getDefault())
                                    .format(Date(message.timestamp)),
                                style = MaterialTheme.typography.labelSmall,
                                color = Color.Gray,
                                modifier = Modifier.align(Alignment.End)
                            )
                            HorizontalDivider(modifier = Modifier.padding(top = 4.dp))
                        }
                    }
                }
            }
        }

        Spacer(modifier = Modifier.height(8.dp))

        // Message input
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            OutlinedTextField(
                value = textInput,
                onValueChange = { textInput = it },
                modifier = Modifier.weight(1f),
                placeholder = { Text("Type a message") },
                maxLines = 3
            )

            Spacer(modifier = Modifier.width(8.dp))

            Button(
                onClick = {
                    sending = true
                    if (textInput.text.isNotBlank()) {
                        scope.launch {
                            try {
                              room?.messages?.send(textInput.text)
                            } catch (e: Exception) {
                              Log.e("APP", e.message, e)
                            }
                            textInput = TextFieldValue("")
                            sending = false
                        }
                    }
                },
                enabled = textInput.text.isNotBlank() && !sending
            ) {
                Icon(
                    imageVector = Icons.AutoMirrored.Filled.Send,
                    contentDescription = "Send"
                )
            }
        }
    }
}
```

* Next, add the @ChatBox@ component to your main app component:

```[kotlin]
@Composable
fun App(chatClient: ChatClient) {
    val roomName = "my-first-room"
    var room by remember { mutableStateOf<Room?>(null) }
    LaunchedEffect(roomName) {
        val chatRoom = chatClient.rooms.get(
            roomName,
        )
        chatRoom.attach()
        room = chatRoom
    }

    Scaffold { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            ConnectionStatusUi(connection = chatClient.connection)
            RoomStatusUi(roomName = roomName, room = room)

            HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))

            ChatBox(room = room)
        }
    }
}
```

The UI should automatically render the new component, and you should be able to send messages to the room.

* Type a message in the input box and click the send button. You'll see the message appear in the chat box.

You can also use the Ably CLI to send a message to the room from another environment:

```[sh]
  ably rooms messages send my-first-room 'Hello from CLI!'
```

You'll see the message in your app's chat box UI. If you have sent a message via CLI, it should appear in a different color to the one you sent from the app.

h2(#step-4). Step 5: Edit a message

If your client makes a typo, or needs to update their original message then they can edit it. To do this, you can extend the functionality of the @ChatBox@ component to allow updating of messages.

Add edited state variable that will contain edited now message or null if message is not edited:

```[kotlin]
var edited: Message? by remember { mutableStateOf(null) }
```
Update Send button code

```[kotlin]
Button(
    onClick = {
        sending = true
        if (textInput.text.isNotBlank()) {
            scope.launch {
                 try {
                    edited?.let {
                        room?.messages?.update(it.copy(text = textInput.text))
                    } ?: room?.messages?.send(textInput.text)
                } catch (e: Exception) {
                    Log.e("APP", e.message, e)
                }
                edited = null
                textInput = TextFieldValue("")
                sending = false
            }
        }
    },
    enabled = textInput.text.isNotBlank() && !sending
) {
    Icon(
        imageVector = Icons.AutoMirrored.Filled.Send,
        contentDescription = if (edited != null) "Edit" else "Send"
    )
}
```

* Update the rendering of messages in the chat box to enable the update action in the UI:

```[kotlin]
Column(
    modifier = Modifier
        .fillMaxWidth()
        .padding(8.dp)
) {
    Card(
        modifier = Modifier
            .weight(1f)
            .fillMaxWidth(),
    ) {
        if (messages.isNullOrEmpty()) {
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = "No messages yet",
                    color = Color.Gray
                )
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(8.dp),
                state = messagesState.listState
            ) {
                items(messages.size, key = { messages[it].serial }) {
                    val message = messages[it]
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(
                            modifier = Modifier
                                .weight(1f)
                                .padding(vertical = 4.dp)
                        ) {
                            Text(
                                text = "${message.clientId}: ${message.text}",
                                style = MaterialTheme.typography.bodyMedium
                            )
                            Text(
                                text = SimpleDateFormat("HH:mm:ss", Locale.getDefault())
                                    .format(Date(message.timestamp)),
                                style = MaterialTheme.typography.labelSmall,
                                color = Color.Gray,
                                modifier = Modifier.align(Alignment.End)
                            )
                            HorizontalDivider(modifier = Modifier.padding(top = 4.dp))
                        }
                        Box {
                            IconButton(onClick = { expanded = true }) {
                                Icon(Icons.Default.MoreVert, contentDescription = "More Options")
                            }

                            DropdownMenu(
                                expanded = expanded,
                                onDismissRequest = { expanded = false },
                            ) {
                                DropdownMenuItem(
                                    text = { Text("Edit") },
                                    onClick = {
                                        expanded = false
                                        edited = message
                                        textInput = TextFieldValue(message.text)
                                    },
                                )
                            }
                        }
                    }
                }
            }
        }
    }

    Spacer(modifier = Modifier.height(8.dp))

    // Message input
    Row(
        modifier = Modifier.fillMaxWidth(),
        verticalAlignment = Alignment.CenterVertically
    ) {
        OutlinedTextField(
            value = textInput,
            onValueChange = { textInput = it },
            modifier = Modifier.weight(1f),
            placeholder = { Text("Type a message") },
            maxLines = 3
        )

        Spacer(modifier = Modifier.width(8.dp))

        Button(
            onClick = {
                sending = true
                if (textInput.text.isNotBlank()) {
                    scope.launch {
                        try {
                            edited?.let {
                                room?.messages?.update(it.copy(text = textInput.text))
                            } ?: room?.messages?.send(textInput.text)
                        } catch (e: Exception) {
                            Log.e("APP", e.message, e)
                        }
                        textInput = TextFieldValue("")
                        sending = false
                    }
                }
            },
            enabled = textInput.text.isNotBlank() && !sending
        ) {
            Icon(
                imageVector = if (edited != null) Icons.Default.Edit
                         else Icons.AutoMirrored.Filled.Send,
                contentDescription = if (edited != null) "Edit" else "Send"
            )
        }
    }
}
```

* Next, you must update the listener provided to the @DisposableEffect@ to handle the @MessageEventType.Updated@ event:

```[kotlin]
DisposableEffect(room) {
    val subscription = room?.messages?.subscribe { event ->
        when (event.type) {
            MessageEventType.Created -> messages.add(0, event.message)
            MessageEventType.Updated -> messages.replaceFirstWith(event.message) {
                it.serial == event.message.serial
            }
            else -> Unit
        }
    }

    onDispose {
        subscription?.unsubscribe()
    }
}
```

* @replaceFirstWith@ function can be implemented:

```[kotlin]
inline fun <T> MutableList<T>.replaceFirstWith(replacement: T, predicate: (T) -> Boolean) {
    val index = indexOfFirst(predicate)
    if (index != -1) set(index, replacement)
}
```

* Now, when you click on the edit button, modify text and resend it.

h2(#step-5). Step 6: Message history and continuity

Ably Chat enables you to retrieve previously sent messages in a room. This is useful for providing conversational context when a user first joins a room, or when they subsequently rejoin it later on. The message subscription object exposes the "getPreviousMessages()":https://sdk.ably.com/builds/ably/ably-chat-kotlin/main/dokka/chat-android/com.ably.chat/-messages-subscription/get-previous-messages.html method to enable this functionality. This method returns a paginated response, which can be queried further to retrieve the next set of messages.
To do this, you need to extend the @ChatBox@ component to include a method to retrieve the last 10 messages when the component mounts.

* In your @MainActivity.kt@ file, add the @DisposableEffect@ in your @ChatBox@ component:

```[kotlin]
fun ChatBox(room: Room?) {
  val componentScope = rememberCoroutineScope()
  DisposableEffect(room) {
      val subscription = room?.messages?.subscribe { event ->
          when (event.type) {
              MessageEventType.Created -> messages.add(0, event.message)
              MessageEventType.Updated -> messages.replaceFirstWith(event.message) {
                  it.serial == event.message.serial
              }
              else -> Unit
          }
      }

      componentScope.launch {
        val previousMessages = subscription?.getPreviousMessages(10) ?: emptyList()
        messages += previousMessages
      }

      onDispose {
          subscription?.unsubscribe()
      }
  }
  /* rest of your code */
}
```

The above code will retrieve the last 10 messages when the component mounts, and set them in the state.

You also can use @collectAsPagingMessagesState@ to automatically subscribe to new messages
and lazily load previous messages as you scroll through the message list.

```[kotlin]
@Composable
fun ChatBox(room: Room?, onSendMessage: suspend (String) -> Unit) {
    val scope = rememberCoroutineScope()
    var textInput by remember { mutableStateOf(TextFieldValue("")) }
    val messagesState = room?.collectAsPagingMessagesState()
    var sending by remember { mutableStateOf(false) }
    var edited by remember { mutableStateOf<Message?>(null) }
    val messages = messagesState?.loaded

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
    ) {
        Card(
            modifier = Modifier
                .weight(1f)
                .fillMaxWidth(),
        ) {
            if (messages.isNullOrEmpty()) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = "No messages yet",
                        color = Color.Gray
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(8.dp),
                    state = messagesState.listState
                ) {
                    items(messages.size, key = { messages[it].serial }) {
                        val message = messages[it]
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Column(
                                modifier = Modifier
                                    .weight(1f)
                                    .padding(vertical = 4.dp)
                            ) {
                                Text(
                                    text = "${message.clientId}: ${message.text}",
                                    style = MaterialTheme.typography.bodyMedium
                                )
                                Text(
                                    text = SimpleDateFormat("HH:mm:ss", Locale.getDefault())
                                        .format(Date(message.timestamp)),
                                    style = MaterialTheme.typography.labelSmall,
                                    color = Color.Gray,
                                    modifier = Modifier.align(Alignment.End)
                                )
                                HorizontalDivider(modifier = Modifier.padding(top = 4.dp))
                            }
                            IconButton(onClick = {
                                edited = message
                                textInput = TextFieldValue(message.text)
                            }) {
                                Icon(Icons.Default.Edit, contentDescription = "Edit")
                            }
                        }
                    }
                }
            }
        }

        Spacer(modifier = Modifier.height(8.dp))

        // Message input
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            OutlinedTextField(
                value = textInput,
                onValueChange = { textInput = it },
                modifier = Modifier.weight(1f),
                placeholder = { Text("Type a message") },
                maxLines = 3
            )

            Spacer(modifier = Modifier.width(8.dp))

            Button(
                onClick = {
                    sending = true
                    if (textInput.text.isNotBlank()) {
                        scope.launch {
                            try {
                                edited?.let {
                                    room?.messages?.update(it.copy(text = textInput.text))
                                } ?: room?.messages?.send(textInput.text)
                            } catch (e: Exception) {
                                Log.e("APP", e.message, e)
                            }
                            edited = null
                            textInput = TextFieldValue("")
                            sending = false
                        }
                    }
                },
                enabled = textInput.text.isNotBlank() && !sending
            ) {
                Icon(
                    imageVector = if (edited != null) Icons.Default.Edit
                             else Icons.AutoMirrored.Filled.Send,
                    contentDescription = if (edited != null) "Edit" else "Send"
                )
            }
        }
    }
}
```

Try the following to test this feature:

1. Use the ably CLI to simulate sending some messages to the room from another client.
2. Refresh the page, this will cause the @ChatBox@ component to mount again and call the @getPreviousMessages()@ method.
3. You should see the last 10 messages appear in the chat box.

h2(#step-6). Step 7: Display who is present in the room

Display the online status of clients using the presence feature. This enables clients to be aware of one another if they are present in the same room. You can then show clients who else is online, provide a custom status update for each, and notify the room when someone enters it, or leaves it, such as by going offline.

* In your @MainActivity.kt@ file, create a new component called @PresenceStatusUi@ like so:

```[kotlin]
@Composable
fun PresenceStatusUi(room: Room?) {
    val members = room?.collectAsPresenceMembers()

    LaunchedEffect(room) {
        room?.presence?.enter()
    }

    Text(
        text = "Online: ${members?.size ?: 0}",
        style = MaterialTheme.typography.bodyMedium,
        modifier = Modifier.padding(start = 8.dp)
    )
}
```

* Then add the @PresenceStatusUi@ component to your main app component like so:

```[kotlin]
@Composable
fun App(chatClient: ChatClient) {
    val roomName = "my-first-room"
    var room by remember { mutableStateOf<Room?>(null) }
    LaunchedEffect(roomName) {
        val chatRoom = chatClient.rooms.get(
            roomName,
        )
        chatRoom.attach()
        room = chatRoom
    }

    Scaffold { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            ConnectionStatusUi(connection = chatClient.connection)
            RoomStatusUi(roomName = roomName, room = room)
            PresenceStatusUi(room = room)

            HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))

            ChatBox(room = room)
        }
    }
}
```

You'll now see your current client ID in the list of present users.

* You can also use the Ably CLI to enter the room from another client by running the following command:

```[sh]
  ably rooms presence enter my-first-room --client-id "my-cli"
```

h2(#step-7). Step 8: Send a reaction

Clients can send a reaction to a room to show their sentiment for what is happening, such as a point being scored in a sports game.
These are short-lived (ephemeral) and are not stored in the room history.

* In your @MainActivity.kt@ file, add a new component called @ReactionBar@, like so:

```[react]
@Composable
fun ReactionBar(room: Room?) {
    val scope = rememberCoroutineScope()
    val availableReactions = listOf("👍", "❤️", "💥", "🚀", "👎", "💔")
    val receivedReactions = remember { mutableStateListOf<Reaction>() }

    LaunchedEffect(room) {
        room?.reactions?.asFlow()?.collect {
            receivedReactions.add(it)
        }
    }

    Column(
        modifier = Modifier.fillMaxWidth(),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // Reaction send buttons
        LazyRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly,
            contentPadding = PaddingValues(vertical = 4.dp)
        ) {
            items(availableReactions) { emoji ->
                Button(
                    onClick = {
                        scope.launch {
                            room?.reactions?.send(emoji)
                        }
                    },
                    colors = ButtonDefaults.buttonColors(containerColor = Color.LightGray)
                ) {
                    Text(
                        text = emoji,
                        fontSize = 12.sp
                    )
                }
            }
        }

        // Display received reactions
        if (receivedReactions.isNotEmpty()) {
            Spacer(modifier = Modifier.height(4.dp))
            Text(
                text = "Received Reactions",
                modifier = Modifier.padding(vertical = 2.dp)
            )

            LazyRow(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Center,
                contentPadding = PaddingValues(vertical = 4.dp)
            ) {
                items(receivedReactions) { reaction ->
                    Box(
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Text(
                                text = reaction.type,
                                fontSize = 12.sp
                            )
                        }
                    }
                }
            }
        }
    }
}
```

* Next, add the @ReactionBar@ component to your main app component:

```[kotlin]
@Composable
fun App(chatClient: ChatClient) {
    val roomName = "my-first-room"
    var room by remember { mutableStateOf<Room?>(null) }
    LaunchedEffect(roomName) {
        val chatRoom = chatClient.rooms.get(
            roomName,
        )
        chatRoom.attach()
        room = chatRoom
    }

    Scaffold { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            ConnectionStatusUi(connection = chatClient.connection)
            RoomStatusUi(roomName = roomName, room = room)
            PresenceStatusUi(room = room)
            ReactionBar(room = room)

            HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))

            ChatBox(room = room)
        }
    }
}
```

The above code should display a list of reactions that can be sent to the room. When you click on a reaction, it will send it to the room and display it in the UI.

* You can also send a reaction to the room via the Ably CLI by running the following command:

```[sh]
  ably rooms reactions send my-first-room 👍
```

h2(#step-8). Step 9: Disconnection and clean up resources

To gracefully close connection and clean up resources, you can subscribe to activity lifecycle events and close connection
when activity on pause or stop, and reconnect when activity is restarts. To do this modify @MainActivity@ class like this:

```[kotlin]
class MainActivity : ComponentActivity() {
    private lateinit var realtimeClient: AblyRealtime
    private lateinit var chatClient: ChatClient

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        realtimeClient = AblyRealtime(
            ClientOptions().apply {
                key = "{{API_KEY}}"
                clientId = "my-first-client"
            },
        )

        chatClient = ChatClient(realtimeClient) { logLevel = LogLevel.Info }

        enableEdgeToEdge()
        setContent {
            ChatExampleTheme {
                App(chatClient)
            }
        }
    }

    override fun onRestart() {
        super.onRestart()
        realtimeClient.connect()
    }

    override fun onResume() {
        super.onResume()
        realtimeClient.connect()
    }

    override fun onPause() {
        super.onPause()
        realtimeClient.close()
    }

    override fun onStop() {
        super.onStop()
        realtimeClient.close()
    }
}
```

h2(#next). Next steps

Continue exploring Ably Chat with Kotlin:

Read more about the concepts covered in this guide:
* Read more about using "rooms":/docs/chat/rooms and sending "messages":/docs/chat/rooms/messages?lang=react.
* Find out more regarding "online status":/docs/chat/rooms/presence?lang=kotlin.
* Understand how to use "typing indicators":/docs/chat/rooms/typing?lang=kotlin.
* Send "reactions":/docs/chat/rooms/reactions?lang=kotlin to your rooms.
* Read into pulling messages from "history":/docs/chat/rooms/history?lang=kotlin and providing context to new joiners.
* Understand "token authentication":/docs/authentication/token-authentication before going to production.

Explore the Ably CLI further,
or check out the "Chat Kotlin API references":https://sdk.ably.com/builds/ably/ably-chat-kotlin/main/dokka/chat-android/com.ably.chat/ for additional functionality.
