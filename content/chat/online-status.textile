---
title: Online status
meta_description: "Display the online status of members to indicate whether they are currently active in a channel, or not."
product: chat
languages:
  - javascript
---

Indicate within a chat application, whether members are online, or not with a visual indicator.

<img src="/images/products/chat/member-list.png" alt="Example of a column of members categorised by their role, also displaying their online status.">

h2(#events). Online status

Whenever a member enters or leaves a channel's presence set, or updates their member data within that set, an event is emitted to all presence subscribers on that channel's presence set.

The following presence events are emitted:

- Enter := A new member has entered the channel
- Leave := A member who was present has now left the channel. This may be a result of an explicit request to leave or implicitly when detaching from the channel. Alternatively, if a member's connection is abruptly disconnected and they do not resume their connection within a minute, Ably treats this as a leave event as the client is no longer present
- Update := An already present member has updated their "member data":#member-data. Being notified of member data updates can be very useful, for example, it can be used to update the status of a member when they are typing a message
- Present := When subscribing to presence events on a channel that already has members present, this event is emitted for every member already present on the channel before the subscribe listener was registered

Any client that uses member's online statuses must have been "identified":/auth/identified-clients by having a @ClientId@ to be present on a channel. The client also requires the @presence@ "capability":/auth/capabilities to enter the online status presence set, and the @subscribe@ capability to subscribe to online status events.

h3(#enter). Enter

The @enter@ method is intentionally initiated by the member, allowing them to signify actions such as marking themselves as online upon logging into the platform. For instance, when dealing with a member represented by a member object featuring a @status@ field, the @enter@ event can be triggered using the provided code snippet below. This code serves the purpose of setting the status of the member to @online@, indicating their entry to the chat.

```[javascript]
channel.presence.enter((err) => {
  // Custom functionality to update UI for member that they are now online.
});
```

h3(#leave). Leave

The @leave@ event occurs either when the member explicitly calls the "@leave()@":/api/realtime-sdk/presence#leave function, implicitly detatches from the channel, or if the member's connection is disconnected and they don't resume their connection within a minute. Providing a means to signify actions such as marking themselves as offline or logging out of the platform. For instance, when managing a member represented by a user object featuring a @status@ field, the @leave@ event can be triggered using the provided code snippet below. This code snippet serves the purpose of setting the status of the member to @offline@, indicating their departure from the chat platform.

```[javascript]
channel.presence.leave((err) => {
  // Custom functionality to update UI for member that they are no longer online
});
```

h3(#update). Update

The @update@ method is called by the member, updating a string value of their status. For example, if you have a member object (user) with the @statusMessage@ field, you can trigger an @update@ event using the code sample below to update this user with a new text-based string. Another possible feature using @update@ is implementing "typing indicators":/chat/typing into your chat application.

```[javascript]
channel.presence.update('status', (err) => {
  user.statusMessage = 'busy';
});
```

h2(#subscribe). Subscribe members to events

Subscribe members to the presence set to receive realtime updates on other member's statuses and update the UI accordingly. For example, displaying online status icons.

When a member calls the @enter@ method, realtime notifications are dispatched to all subscribers of the associated presence channel. This functionality enables subscribers to promptly update the visual online status of the member, ensuring that everyone in the channel is informed of the current online presence.

```[javascript]
channel.presence.subscribe('enter', (member) => {
  user.online = true
  user.lastOnline = null
});
```

When a member calls the @update@ method, realtime notifications are dispatched to all subscribers of the associated presence channel. This functionality enables subscribers to promptly update the status of the member, ensuring that everyone in the channel is informed of the current statuses.

```[javascript]
channel.presence.subscribe('update', (memberUpdate) => {
  user.status = memberUpdate.data
});
```

When a member calls the @leave@ method, realtime notifications are dispatched to all subscribers for this associated presence channel. This functionality enables subscribers to promptly update the status of the member as offline.

```[javascript]
channel.presence.subscribe('leave', (member) => {
  user.online = false
  user.lastOnline = member.timestamp

  // Custom functionality to update display for member that another member is no longer online
});
```

The message count within a presence set, like online status, can surge as the member number grows. For instance, with 200 members rapidly joining and leaving, the potential messages for online status alone could reach 80,400. The breakdown includes:

200 member messages published for the @enter@ event.
200 × 200 (40,000) messages subscribed to for the @enter@ events.
200 member messages published for the @leave@ event.
200 × 200 (40,000) presence messages subscribed to for the @leave@ event.

For improved scalability, consider making your backend server the exclusive subscriber to members online status updates if your chat application anticipates a large number of members. In this scenario, frontend clients can periodically request updates from the backend.

h3(#batch-presence). Batch presence retrieval

In use cases such as a large-scale, live streaming chat it may not be desirable or efficient to send individual presence updates, you can reduce realtime presence updates received and traffic between members by introducing batches using the @request()@ in the REST API. Within a batch response is an array of presence states, where each presence state update contains information about the members in the presence set, including their @clientId@, member data, and "presence action":/docs/api/realtime-sdk/types#presence-action .

The following is an example of a batch presence request using the "request()":/docs/api/rest-sdk#request method to query the "batch REST API":/docs/api/rest-api#batch-presence :

```[rest_javascript]
var ablyRest = new Ably.Rest({ key: '{{API_KEY}}' })
var content = { "channel": "channel1,channel2" }
ablyRest.request('GET', '/presence', content, null, {}, function(err, response) {
  If (err) {
    alert('An error occurred; err = ' + err.toString());
  } else {
    alert('Success! status code was ' + response.statusCode);
  }
});
```

h4(#batch-responses). Batch presence responses

On completion of the batch request, one of three possible responses are returned:

- Success := If all of the individual requests were successful then an array containing the response of each query is returned in request order.
- Failure := If the batch request itself failed before the individual requests were made, then an error response is returned with a status code and error response body. Examples of why the batch request can fail include an authorization failure or an invalid request.
- Partial success := If one or more of the individual requests failed the response body contains an error object with the error code @40020@ and a status code of @400@. The error body contains a @batchResponse@ array of each individual response in request order. The @batchResponse@ can be inspected if there is a need to know the details of each outcome. If you only need to know whether or not the batch request was completely successful then the status code is sufficient.

The following is an example of a successful batch presence response. The response body contains details of each member present on the channel and the channel they are present on. The status code for a successful response is always @200@:

```[json]
[
  {
    "channel":"channel0",
    "presence":[
      {"clientId": "user1", "action": "1"},
      {"clientId": "user2", "action": "1"}
    ]
  },
  {
    "channel":"channel1",
    "presence":[]
  },
  {
    "channel":"channel2",
    "presence":[
      {"clientId": "user2", "action": "1"},
      {"clientId": "user3", "action": "1"}
    ]
  }
]
```

For more information making batch presence requests please refer to the "Presence documentation":/docs/presence-occupancy/presence#batch


h3(#channel-separation). Channel separation

To avoid a potentially high volume of unnecessary messages, for example, in a large-scale, live streaming chat application, having all messages, status updates, and typing indicators in one channel. You could have separate channels for specific purposes. An example of this is to have one channel for a specific chat ("general") while having another channel for the members' status ("status-general") updates. Your application could then periodically retrieve the members' online status updates from your backend (the exclusive subscriber). When issuing API keys to clients, assign the clients the following "capabilities":/auth/capabilities :

```
{
  "status-general": ["presence"],
  "general": ["publish", "history", "subscribe"],
}
```

Meanwhile the server can also subscribe to the members channel with an api key having the following capabilities:

```
{
  "status-general": ["presence", "subscribe"],
  "general": ["publish", "history", "subscribe"],
}
```

h2(#last-seen). Last seen

Track the last seen timestamp of members in a channel by storing the @leave()@ event. This can be done either locally on each member's client or remotely on the backend server, especially if the chat application has a member database. In large-scale live streaming applications, for example, locally storing the @leave()@ event timestamp on the client is common. The presence set initially displays online members, and as time progresses, it updates with new joiners and leavers. The member list retains leavers' records, indicating their last seen time and offline status.

h2(#remain-present-for). Member timeout

Clients that are part of a member presence set remain present, by default, for 15 seconds after they are abruptly disconnected. For example, when the internet connection suddenly drops or the client is changing networks. This delay is to avoid repeated @leave@ and @enter@ events being sent when a client is experiencing an unstable connection. A different disconnection timeout can be defined in the @remainPresentFor@ client configuration.

Any clients that explicitly call @channel.presence.leave@ will immediately be removed from the member presence set.

The following example code demonstrates establishing a connection to Ably with @remainPresentFor@ set to 15 seconds:

```[javascript]
const ably = new Ably.Realtime(
  {
    key: '{{API_KEY}}',
    transportParams: { remainPresentFor: 15000 }
  }
);
```

For more information handling unstable connections please refer to the "Presence documentation":/docs/presence-occupancy/presence?lang=javascript#unstable-connections
