---
title: Channels
meta_description: "Realtime Client Library SDK API reference section for the channels and channel objects."
meta_keywords: "Ably, Ably realtime, API Reference, Realtime SDK, channel, channel, channels, publish, subscribe"
section: api
index: 15
languages:
  - javascript
  - nodejs
  - ruby
  - java
  - swift
  - objc
  - csharp
  - flutter
jump_to:
  Channel API properties:
    - state
    - errorReason#error-reason
    - name
    - presence
  Channel API methods:
    - publish
    - subscribe
    - unsubscribe
    - history
    - attach
    - detach
    - on#on
    - once
    - off#off
  Types:
    - Related Types#related-types
---

inline-toc.
  Channels Methods:
    - get#get
    - release#release
  Channel Properties:
    - state#state
    - errorReason#error-reason
    - name#name
    - presence#presence
    - push#push
  Channel Methods:
    - publish#publish
    - subscribe#subscribe
    - unsubscribe#unsubscribe
    - history(options)#history
    - attach()#attach
    - detach()#detach
    - on#on-state-listener
    - once#once-state-listener
    - off#off-state-listener
  Related types:
    - ChannelState#channel-state
    - ChannelEvent#channel-event
    - ChannelStateChange#channel-state-change
    - Message#message
    - ChannelOptions#channel-options
    - ChannelStateListener#channel-state-listener
    - CompletionListener#completion-listener
    - MessageListener#message-listener
    - PaginatedResult#paginated-result
    - Param

h2(#channels-object).
  default: Channels

The @Channels@ object, accessed from the "realtime library client constructor":/api/realtime-sdk#channels, is used to create and destroy @Channel@ objects. It exposes the following public methods:

h3(#channels-methods). Channels Methods

h6(#get).
  default: get
  csharp: Get

bq(definition).
  default:  "Channel":#properties get(String channelName, "ChannelOptions":#channel-options channelOptions)
  csharp:   "Channel":#properties Get(String channelName, "ChannelOptions":#channel-options channelOptions)
  objc,swift: "ARTRealtimeChannel":#properties get(String channelName, "ARTChannelOptions":#channel-options channelOptions);

Creates a new "Channel":#properties object if none for the channel exists, or returns the existing channel object.

h6(#release).
  default: release
  csharp: Release

bq(definition).
  default:  release(String channelName)
  java,objc,swift,flutter:  void release(String channelName)
  csharp:   bool Release(string channelName)

Releases a "Channel":#properties object, deleting it and enabling it to be garbage collected. It also removes any listeners associated with the channel.

<span lang="jsall, csharp">**Note**: To release a channel, the "channel state":/channels#states must be @initialized@, @detached@ or @failed@.</span>

h2(#channel-object). Channel

The Channel object, created via the "Channels":#channels-object object, is used to interact with a specific channel.

h3(#properties).
  default: Channel Properties
  objc,swift: ARTRealtimeChannel Properties
  ruby: Ably::Realtime::Channel Attributes
  java: io.ably.lib.realtime.Channel Members
  csharp: IO.Ably.Realtime.RealtimeChannel Properties

The @Channel@ object exposes the following public <span lang="default">properties</span><span lang="ruby">attributes</span><span lang="java">members</span>:

h6(#state).
  default: state
  csharp: State

The current <span lang="java">"@io.ably.lib.realtime.ChannelState@":#channel-state @state@</span><span lang="csharp">"@IO.Ably.Realtime.ChannelState@":#channel-state @state@</span><span lang="ruby">"@Ably::Realtime::Channel::STATE@":#channel-state @state@</span><span lang="objc,swift">"@ARTRealtimeChannelState@":#channel-state</span><span lang="default">"@ChannelState@":#channel-state</span> of this @Channel@. See the supported "channel states":/channels#states for more information.

h6(#error-reason).
  default: errorReason
  java:    reason
  ruby:    error_reason
  csharp:  ErrorReason

When a channel failure occurs this <span lang="default,ruby">attribute</span><span lang="java">member</span><span lang="jsall">property</span><span lang="objc,swift,csharp">property</span> is populated.
The type is <span lang="default">"@ErrorInfo@":/api/realtime-sdk/types#error-info</span><span lang="java,ruby">"@AblyException@":/api/realtime-sdk/types#ably-exception</span>.

h6(#name).
  default: name
  csharp: Name

The name @String@ unique to this channel.

h6(#presence).
  default: presence
  csharp: Presence

Provides access to the "Presence":/presence-occupancy/presence object for this channel which can be used to access members present on the channel, or participate in presence.

h6(#push).
  default: push

Provides access to the "PushChannel":/api/realtime-sdk/push#push-channel object for this channel which can be used to access members present on the channel, or participate in presence.

h3. Methods

h6(#publish).
  default: publish
  csharp: Publish

There are two overloaded versions of this method:

bq(definition#publish-data).
  default:  publish(String name, Object data, callback("ErrorInfo":/api/realtime-sdk/types#error-info err))
  ruby:     "Deferrable":/api/realtime-sdk/types#deferrable publish(String name, Object data) -> yields
  java:     void publish(String name, Object data, "CompletionListener":#completion-listener listener)
  csharp:   void Publish(string name, object data, Action<bool, ErrorInfo> callback = null, string clientId = null)
  objc,swift: publish(name: String?, data: AnyObject?, callback: (("ARTErrorInfo":/api/realtime-sdk/types#error-info?) -> Void)?)
  flutter:  Future<void> publish(name: String name, data: Object data, message: "Message":#message message)

Publish a single message on this channel based on a given event name and payload. A <span lang="default">callback</span><span lang="java">listener</span> may optionally be passed in to this call to be notified of success <span lang="default">or failure</span><span lang="ruby"></span> of the operation. When publish is called with this client library, it "won't attempt to implicitly attach to the channel":/channels#transient-publish, so long as "transient publishing":/channels#transient-publish is available in the library. Otherwise, the client will implicitly attach.

bq(definition#publish-msg-array).
  default: publish(Object[] messages, callback("ErrorInfo":/api/realtime-sdk/types#error-info err))
  ruby:    "Deferrable":/api/realtime-sdk/types#deferrable publish(Message[] messages) -> yields
  java:    void publish(Message[] messages, "CompletionListener":#completion-listener listener)
  csharp:  void Publish(IEnumerable<"Message":#message> messages, Action<bool, "ErrorInfo":/api/realtime-sdk/types#error-info> callback = null)
  objc,swift: publish(messages: [ "ARTMessage":#message ], callback: (("ARTErrorInfo":/api/realtime-sdk/types#error-info?) -> Void)?)
  flutter:  Future<void> publish(messages: List<"Message":#message> messages)

Publish several messages on this channel. A <span lang="default">callback</span><span lang="java">listener</span><span lang="ruby">block</span> may optionally be passed in to this call to be notified of success <span lang="default">or failure</span><span lang="ruby"></span> of the operation.<span lang="jsall,ruby,swift"> When publish is called with this client library, it "won't attempt to implicitly attach to the channel":/channels#transient-publish.</span><span lang="default"> If the channel is @initialized@ (i.e. no attempt to attach has yet been made for this channel), then calling @publish@ will implicitly attach the channel.</span>

h4. Parameters

- <div lang="default">name</div> := event name for the published message<br>__Type: @String@__

- <div lang="jsall">data</div> := data payload for the message. The supported payload types are Strings, objects or arrays capable of JSON representation, buffers containing arbitrary binary data, and null. (Note that if sending a binary, that binary should be the entire payload; an object with a binary field within it may not be correctly encoded)<br>__Type: @Object@__
- <div lang="java">data</div> := data payload for the message. The supported payload types are Strings, JsonObject, binary data as byte arrays, and null.<br>__Type: @Object@__
- <div lang="csharp">data</div> := data payload for the message. The supported payload types are Strings, binary data as byte arrays, any plain c# class that can be serialized to Json, and null.<br>__Type: @Object@__
- <div lang="ruby">data</div> := data payload for the message. The supported payload types are Strings, Hash or Array objects that can be serialized to JSON using @to_json@, binary data as @ASCII-8BIT@ byte arrays, and null. (Note that if sending a byte array, it should be the entire payload; a hash or array with a bytearray field within it may not be correctly encoded)<br>__Type: @Object@__
- <div lang="objc,swift">data</div> := data payload for the message. The supported payload types are <span lang="objc">@NS@</span>@String@, <span lang="objc">@NS@</span>@Dictionary@ or <span lang="objc">@NS@</span>@Array@ objects that can be serialized to JSON, binary data as @NSData@, and @nil@.<br>__Type: @Object@__
- <div lang="flutter">data</div> := data payload for the message. The supported payload types are String, Map, List, and null.<br>__Type: @Object@__

- <span lang="default">message</span> := A message object to publish<br>__Type: "@Message@":#message__

- <span lang="default">messages</span> := An array of message objects to publish<br>__Type: "@Message []@":#message__

- <div lang="jsall">callback</div> := is a function of the form @function(err)@ which is called upon completion
- <div lang="java">listener</div> := Listener to be notified on completion<br>__Type: "@CompletionListener@":#completion-listener__
- <div lang="csharp">callback</div> := is an action of the form @Action<bool, ErrorInfo>@ which is called upon completion
- <div lang="ruby">&block</div> := yields upon successfully publishing the message
- <div lang="objc,swift">callback</div> := called upon publishing the message, or with an error

blang[jsall,swift,objc].
  h4. Callback result

  On successful publish of the message, @err@ is null. On failure to publish the message, @err@ contains an "@ErrorInfo@":#error-info object describing the failure reason.

blang[csharp].
  h4. Callback result

  On successful publish of the message, @error@ is null. On failure to publish the message, @error@ contains an "@ErrorInfo@":#error-info object describing the failure reason.

blang[java].
  h4. Listener result

  On successful publish of the message, the @onSuccess@ method of the "CompletionListener":#completion-listener is called. On failure to publish the message, the @onError@ method is called with an "@ErrorInfo@":#error-info argument describing the failure reason.

blang[ruby].
  h4. Returns

  A "@Deferrable@":/api/realtime-sdk/types#deferrable object is returned from the method.

  On successful publish of the message, the registered success blocks for the "@Deferrable@":/api/realtime-sdk/types#deferrable and any block provided to the method are executed. On failure to publish the message, the @errback@ callbacks of the "@Deferrable@":/api/realtime-sdk/types#deferrable are called with an "@ErrorInfo@":#error-info argument describing the failure reason.

blang[flutter].
  h4. Returns

  @Future<void>@

  On successful publish of the message, no exception will be thrown. On failure to publish the message, an @AblyException@ will be thrown with an `"@errorInfo@":#error-info` property describing the failure reason.

h6(#subscribe).
  default: subscribe
  csharp: Subscribe

There are overloaded versions of this method:

bq(definition#subscribe-listener).
  default:  subscribe(listener("Message":#message))
  java:     void subscribe("MessageListener":#message-listener listener)
  csharp:   void Subscribe(Action<"Message":#message> handler)
  ruby:     subscribe → yields "Message":#message
  objc,swift: subscribe(callback: ("ARTMessage":#message) -> Void) -> ARTEventListener?
  flutter:  StreamSubscription<"ably.Message":#message> subscribe().listen(("ably.Message":#message) -> void)

Subscribe to messages on this channel. The caller supplies <span lang="default">a listener function</span><span lang="csharp">a lambda expression</span><span lang="java">an implementation of the "MessageListener":#message-listener interface</span><span lang="ruby">a block</span>, which is called each time one or more messages arrives on the channel.

bq(definition#subscribe-event).
  default: subscribe(String name, listener("Message":#message))
  java:    void subscribe(String name, "MessageListener":#message-listener listener)
  csharp:  void Subscribe(string name, Action<"Message":#message> handler)
  ruby:    subscribe(String name) → yields "Message":#message
  objc,swift: subscribe(name: String, callback: ("ARTMessage":#message) -> Void) -> ARTEventListener?
  flutter:  StreamSubscription<"ably.Message":#message> subscribe(name: String).listen(("ably.Message":#message) -> void)

Subscribe to messages with a given event @name@ on this channel. The caller supplies <span lang="default">a listener function</span><span lang="csharp">a lambda expression</span><span lang="java">an implementation of the "MessageListener":#message-listener interface</span><span lang="ruby">a block</span>, which is called each time one or more matching messages arrives on the channel.

<div lang="objc,swift,csharp"></div>
<div lang="default">
bq(definition#subscribe-event-array).
  default: subscribe(String[] names, listener("Message":#message))
  java:    void subscribe(String[] names, "MessageListener":#message-listener listener)
  ruby:    subscribe(String *names) → yields "Message":#message
  flutter:  StreamSubscription<"ably.Message":#message> subscribe(names: List<String>).listen(("ably.Message":#message) -> void)

Subscribe a single listener to messages on this channel for multiple event @name@ values.
</div>

h4. Parameters

- name := The event name to subscribe to<br>__Type: @String@__

<div lang="objc,swift,csharp"></div>
<div lang="default">
- names := An <span lang="ruby">argument</span> array of event names to subscribe to<br>__Type: <span lang="default">@String[]@ </span><span lang="ruby">@*argument@</span>__
</div>

- <div lang="jsall">listener</div> := is a function of the form @function(message)@ to be called for each message
- <div lang="java">"MessageListener":#message-listener listener</div> := Message listener to be notified for matching messages
- <div lang="ruby">&block</div> := yields each matching message when received on the channel
- <div lang="swift,objc">callback</div> := called with each matching "@message@":#message when received on the channel
- <div lang="csharp">handler</div> := called with each matching "@message@":#message when received on the channel

h4. Considerations

* If the channel is @initialized@ (i.e. no attempt to attach has yet been made for this channel), then calling @subscribe@ will implicitly attach the channel. However, regardless of the implicit attach outcome, the <span lang="default">listener</span><span lang="ruby">block</span><span lang="csharp">handler</span> will still be registered
* Calling subscribe with an event name is a convenient way to subscribe only to messages matching that event name. But this is purely a clientside filter, for convenience. It has no effect on what messages are actually sent by the server to the client. All clients attached to a given channel receive every message sent on that channel (that their capabilities allow them to receive); the channel is the unit of distribution.
* If @subscribe@ is called more than once with the same <span lang="default">listener</span><span lang="ruby">block</span><span lang="csharp">handler</span>, then duplicates will be registered. For example, if you @subscribe@ twice with the same <span lang="default">listener</span><span lang="ruby">block</span><span lang="csharp">handler</span> and a message is later received, the same <span lang="default">listener</span><span lang="ruby">block</span><span lang="csharp">handler</span> will be invoked twice
* The registered <span lang="default">listener</span><span lang="ruby">block</span><span lang="csharp">handler</span> remains active on the channel regardless of the current channel state. For example, if you call @subscribe@ when a channel is @attached@ and it later becomes @detached@ or even @failed@, when the channel is reattached and a message is received, the <span lang="default">listeners</span><span lang="ruby">blocks</span><span lang="csharp">handlers</span> originally registered will still be invoked. Listeners are only removed when calling <span lang="default">"@unsubscribe@":#unsubscribe</span><span lang="flutter">@streamSubscription.close@</span> or when a channel is @released@ using the <span lang="default">@Realtime.channels.release(name)@</span><span lang="csharp">@Realtime.Channels.Release(name)@</span> method
* If an exception is thrown in the subscribe listener and bubbles up to the event emitter, it will be caught and logged at @error@ level, so as not to affect other listeners for the same event

h6(#unsubscribe).
  default: unsubscribe
  csharp: Unsubscribe

<div lang="default">
There are <span lang="jsall">six</span><span lang="default">three</span> overloaded versions of this method:

bq(definition#unsubscribe-event).
  default: unsubscribe(String name, listener)
  java:    void unsubscribe(String name, "MessageListener":#message-listener listener)
  csharp:  bool Unsubscribe(string eventName, Action<"Message":#message> handler)
  ruby:    unsubscribe(String name, &listener_proc)
  objc,swift: unsubscribe(name: String, listener: ARTEventListener)

Unsubscribe the given listener for the specified event name. This removes an earlier event-specific subscription.

bq(definition#unsubscribe-listener).
  default: unsubscribe(listener)
  java:    void unsubscribe("MessageListener":#message-listener listener)
  csharp:  bool Unsubscribe(Action<"Message":#message> handler)
  ruby:    unsubscribe(&listener_proc)
  objc,swift: unsubscribe(listener: ARTEventListener)

Unsubscribe the given listener (for any/all event names). This removes an earlier subscription.

<div lang="jsall">
bq(definition). unsubscribe(String[] names, listener)

Unsubscribe the given listener from all event names in the array.

bq(definition). unsubscribe(String name)

Unsubscribe all listeners for a given event name.

bq(definition). unsubscribe(String[] names)

Unsubscribe all listeners for all event names in the array.
</div>

bq(definition#unsubscribe-all).
  default: unsubscribe()
  java:    void unsubscribe()
  csharp:  void Unsubscribe()
  objc,swift: unsubscribe()

Unsubscribes all listeners to messages on this channel. This removes all earlier subscriptions.

h4. Parameters

- name := The event name to unsubscribe from<br>__Type: @String@__
- <div lang="jsall">names</div> := An array of event names to unsubscribe from<br>__Type: @String[]@__
- <div lang="jsall">listener</div> := is the callback listener function that was previously subscribed
- <div lang="java">listener</div> := previously registered listener<br>__Type: "@MessageListener@":#message-listener__
- <div lang="ruby">&listener_block</div> := previously registered listener block
- <div lang="swift,objc">listener</div> := previous return value from a @subscribe@ call
- <div lang="csharp">handler</div> := is the lambda expression that was previously subscribed
</div><div lang="flutter">
@streamSubscription@ obtained from a subscription can be used to cancel a listener by calling @streamSubscription.cancel@.

</div>

h6(#history).
  default: history
  csharp: History

bq(definition).
  default: history(Object options, callback("ErrorInfo":/api/realtime-sdk/types#error-info err, "PaginatedResult":#paginated-result<"Message":#message> resultPage))
  ruby:    "Deferrable":/api/realtime-sdk/types#deferrable history(Hash options) -> yields "PaginatedResult":#paginated-result<"Message":#message>
  java:    "PaginatedResult":#paginated-result<"Message":#message> history("Param []":#param options)
  csharp:  Task<"PaginatedResult<Message>":#paginated-result> HistoryAsync("PaginatedRequestParams":#paginated-request-params dataQuery, bool untilAttach = false)
  objc,swift: history(query: ARTRealtimeHistoryQuery?, callback: ("ARTPaginatedResult":#paginated-result<"ARTMessage":#message>?, ARTErrorInfo?) -> Void) throws

Gets a "paginated":#paginated-result set of historical messages for this channel. If the "channel is configured to persist messages to disk":https://faqs.ably.com/how-long-are-messages-stored-for, then message history will "typically be available for 24 - 72 hours":https://faqs.ably.com/how-long-are-messages-stored-for. If not, messages are only retained in memory by the Ably service for two minutes.

h4. Parameters

- <span lang="default">options</span><span lang="objc,swift">query</span><span lang="csharp">dataQuery</span> := <span lang="default">an optional object containing the query parameters</span><span lang="ruby">an optional set of key value pairs containing the query parameters</span>, as specified in the "message history API documentation":/api/realtime-sdk/history#channel-history.<br>__Type: <span lang="default">@Object@</span><span lang="objc,swift">@ARTRealtimeHistoryQuery@</span><span lang="csharp">@PaginatedRequestParams@</span><span lang="ruby">@Hash@</span><span lang="java">"@Param []@":#param</span>__

- <div lang="jsall">callback</div> := is a function of the form: @function(err, resultPage)@
- <div lang="ruby">&block</div> := yields a @PaginatedResult<Message>@ object
- <div lang="swift,objc">callback</div> := called with a "ARTPaginatedResult":#paginated-result<"ARTMessage":#message> object or an error

Further details of the supported @options@ params, see "message history API documentation":/api/realtime-sdk/history#channel-history.

blang[jsall,objc,swift].
  h4. Callback result

  On success, @resultPage@ contains a "@PaginatedResult@":#paginated-result encapsulating an array of "@Message@":#message objects corresponding to the current page of results. "@PaginatedResult@":#paginated-result supports pagination using "@next()@":#paginated-result and "@first()@":#paginated-result methods.

  On failure to retrieve message history, @err@ contains an "@ErrorInfo@":#error-info object with the failure reason.

blang[java].
  h4. Returns

  On success, the returned "@PaginatedResult@":#paginated-result encapsulates an array of "@Message@":#message objects corresponding to the current page of results. "@PaginatedResult@":#paginated-result supports pagination using "@next@":#paginated-result and "@first@":#paginated-result methods.

  Failure to retrieve the message history will raise an "@AblyException@":/api/realtime-sdk/types#ably-exception

blang[csharp].
  h4. Returns

  The return value is @Task<PaginatedResult<Message>>@ which needs to be awaited.

  On success, the returned "@PaginatedResult@":#paginated-result encapsulates an array of "@Message@":#message objects corresponding to the current page of results. "@PaginatedResult@":#paginated-result supports pagination using "@NextAsync@":#paginated-result and "@FirstAsync@":#paginated-result methods.

  Failure to retrieve the message history will raise an "@AblyException@":/api/realtime-sdk/types#ably-exception

blang[ruby].
  h4. Returns

  A "@Deferrable@":/api/realtime-sdk/types#deferrable object is returned from the method.

  On success, the registered success blocks for the "@Deferrable@":/api/realtime-sdk/types#deferrable and any block provided to the method yield a "PaginatedResult":#paginated-result that encapsulates an array of "@Message@":#message objects corresponding to the current page of results. "@PaginatedResult@":#paginated-result supports pagination using "@next()@":#paginated-result and "@first()@":#paginated-result methods.

  Failure to retrieve the message history will trigger the @errback@ callbacks of the "@Deferrable@":/api/realtime-sdk/types#deferrable with an "@ErrorInfo@":#error-info object with the failure reason.

h6(#attach).
  default: attach
  csharp: Attach

bq(definition).
  default:  attach(callback("ErrorInfo":/api/realtime-sdk/types#error-info err))
  java:     void attach()
  csharp:   void Attach(Action<TimeSpan, "ErrorInfo":/api/realtime-sdk/types#error-info?> callback = null)
  ruby:     "Deferrable":/api/realtime-sdk/types#deferrable attach -> yields
  objc,swift: attach(callback: (("ARTErrorInfo":/api/realtime-sdk/types#error-info?) -> Void)?)
  flutter:  Future<void> attach()

Attach to this channel ensuring the channel is created in the Ably system and all messages published on the channel will be received by any channel listeners registered using <span lang="default">@subscribe()@</span><span lang="csharp">@Subscribe()@</span><span lang="ruby">@subscribe@</span>. Any resulting channel state change will be emitted to any listeners registered using the "<span lang="default">@on@</span><span lang="csharp">@On@</span>":#on or "<span lang="default">@once@</span><span lang="csharp">@Once@</span>":#once methods.

As a convenience, <span lang="default">@attach()@</span><span lang="csharp">@Attach()@</span><span lang="ruby">@attach@</span> will be called implicitly if "<span lang="default">@subscribe()@</span><span lang="csharp">@Subscribe()@</span><span lang="ruby">@subscribe@</span>":#subscribe for the @Channel@ is called, or "<span lang="default">@enter()@</span><span lang="csharp">@Enter()@</span><span lang="ruby">@enter@</span>":/api/realtime-sdk/presence#enter or "<span lang="default">@subscribe()@</span><span lang="csharp">@Subscribe()@</span><span lang="ruby">@subscribe@</span>":/api/realtime-sdk/presence#subscribe is called on the "@Presence@":/presence-occupancy/presence for this @Channel@.

<div lang="default">
h4. Parameters

- <div lang="jsall">callback</div> := is a function of the form @function(err)@ and is called once the channel attach succeeds or fails
- <div lang="ruby">&block</div> := yields once the channel becomes attached
- <div lang="csharp">callback</div> := is a lambda expression of the form @Action<TimeSpan, ErrorInfo>@ and is called once the channel attach succeeds or fails
- <div lang="swift,objc">callback</div> := called once the channel becomes attached or if an error occurs
</div><div lang="flutter"></div>

blang[ruby].
  h4. Returns

  A "@Deferrable@":/api/realtime-sdk/types#deferrable object is returned from the attach method.

  On successful attachment, the success callbacks for the "@Deferrable@":/api/realtime-sdk/types#deferrable are called and any block provided to the method is yielded. Failure to attach will trigger the @errback@ callbacks of the "@Deferrable@":/api/realtime-sdk/types#deferrable with an "@ErrorInfo@":#error-info object with the failure reason.

blang[flutter].
  h4. Returns

  @Future<void>@

  Failure to attach will throw an @AblyException@ with an "errorInfo":/api/realtime-sdk/types#error-info property with the failure reason.

h6(#detach).
  default: detach
  csharp: Detach

bq(definition).
  default: detach(callback("ErrorInfo":/api/realtime-sdk/types#error-info err))
  java:    void detach()
  csharp:  void Detach(Action<TimeSpan, ErrorInfo> callback = null)
  ruby:     "Deferrable":/api/realtime-sdk/types#deferrable detach -> yields
  objc,swift: detach(callback: (("ARTErrorInfo":/api/realtime-sdk/types#error-info?) -> Void)?)
  flutter:  Future<void> detach()

Detach from this channel. Any resulting channel state change will be emitted to any listeners registered using the "<span lang="default">@on@</span><span lang="csharp">@On@</span>":#on or "<span lang="default">@once@</span><span lang="csharp">@Once@</span>":#once methods.

Please note: Once all clients globally have detached from the channel, the channel will be released in the Ably service within two minutes.

<div lang="default">
h4. Parameters

- <div lang="jsall">callback</div> := is a function of the form @function(err)@ and is called once the channel detach succeeds or fails
- <div lang="csharp">callback</div> := is a lambda expression in the form @Action<TimeSpan, ErrorInfo>@ and is called once the channel detach succeeds or fails
- <div lang="ruby">&block</div> := yields once the channel becomes detached
- <div lang="swift,objc">callback</div> := called once the channel becomes detached or if an error occurs
</div><div lang="flutter"></div>

blang[ruby].
  h4. Returns

  A "@Deferrable@":/api/realtime-sdk/types#deferrable object is returned from the detach method.

  On successful detachment, the registered success blocks for the "@Deferrable@":/api/realtime-sdk/types#deferrable and any block provided to the method are executed. Failure to detach will trigger the @errback@ callbacks of the "@Deferrable@":/api/realtime-sdk/types#deferrable with an "@ErrorInfo@":#error-info object with the failure reason.

blang[flutter].
  h4. Returns

  @Future<void>@

  Failure to detach will throw an @AblyException@ with an "errorInfo":/api/realtime-sdk/types#error-info property with the failure reason.

h6(#on).
  default: on
  csharp: On

There are <span lang="jsall">three</span><span lang="default">two</span> overloaded versions of this method:

bq(definition#on-state-listener).
  default: on(String event, listener("ChannelStateChange":#channel-state-change stateChange))
  ruby:    on("ChannelEvent":#channel-event *event) -> yields "ChannelStateChange":#channel-state-change
  java:    void on("ChannelEvent":#channel-event event, "ChannelStateListener":#channel-state-listener listener)
  csharp:  void On("ChannelEvent":#channel-event event, Action<"ChannelStateChange":#channel-state-change> action)
  objc,swift: on(event: "ARTChannelEvent":#channel-event, call: ("ARTChannelStateChange?":#channel-state-change) -> Void) -> ARTEventListener
  flutter: Stream<"ChannelEvent":#channel-event> on("ChannelEvent":#channel-event channelEvent)

<div lang="flutter">
The Stream returned can be subscribed for with a listener.

bq(definition). final streamSubscription = stream.listen(listener)

</div>
Register the given listener <span lang="ruby">block</span><span lang="swift,objc">function</span> for the specified "ChannelEvent":#channel-event on the @Channel@.
The listener is passed a "<span lang="default">ChannelStateChange</span><span lang="objc,swift">ARTChannelStateChange</span>":#channel-state-change object that contains the current state, previous state, a boolean indicating whether the channel was resumed, and an optional reason for the state change.

<div lang="jsall">
bq(definition#on-state-array-listener).
  jsall: on(String[] events, listener("ChannelStateChange":#channel-state-change stateChange))

Same as above, but registers multiple listeners, one for each event in the array.
</div>

bq(definition#on-listener).
  default: on(listener("ChannelStateChange":#channel-state-change stateChange))
  ruby:    on -> yields "ChannelStateChange":#channel-state-change
  csharp:  void On(Action<"ChannelStateChange":#channel-state-change> listener)
  java:    void on("ChannelStateListener":#channel-state-listener listener)
  objc,swift: on(call: ("ARTChannelStateChange?":#channel-state-change) -> Void) -> ARTEventListener
  flutter: Stream<"ChannelEvent":#channel-event> on()

<div lang="flutter">
The Stream returned can be subscribed for with a listener.

bq(definition). final streamSubscription = stream.listen(listener)

</div>
Register the given listener <span lang="ruby">block</span><span lang="swift,objc">function</span><span lang="csharp">lambda expression</span> for all "ChannelEvents":#channel-event on the @Channel@.
The listener is passed a "<span lang="default">ChannelStateChange</span><span lang="objc,swift">ARTChannelStateChange</span>":#channel-state-change object that contains the current state, previous state, the event, a boolean indicating whether the channel was resumed, and an optional reason for the state change.

If an exception is thrown in the listener and bubbles up to the event emitter, it will be caught and logged at @error@ level, so as not to affect other listeners for the same event

h4. Parameters

- <div lang="jsall">event(s)</div> := the channel event(s) to subscribe to, see "ChannelEvent":#channel-event for supported channel events<br>__Type: @String@ or @String[]@__
- <div lang="java">event</div> := the channel event to subscribe to<br>__Type: "@ChannelEvent@":#channel-event__
- <div lang="csharp">event</div> := the channel event to subscribe to<br>__Type: "@ChannelEvent@":#channel-event__
- <div lang="ruby">event</div> := the channel event as a Symbol such as @:attached@ or a @ChannelEvent@ object to subscribe to<br>__Type: "@ChannelEvent@":#channel-event__
- <div lang="swift,objc">event</div> := the @ARTChannelEvent@ to subscribe to<br>__Type: "@ARTChannelEvent@":#channel-event__
- <div lang="flutter">event</div> := the channel event to subscribe to<br>__Type: "@ChannelEvent@":#channel-event__

- <div lang="jsall">listener</div> := is a function of the form @function(stateChange)@ to be notified for matching event changes.
- <div lang="java">listener</div> := listener to be notified for matching event changes<br>__Type: "@ChannelStateListener@":#channel-state-listener__
- <div lang="csharp">action</div> := lambda expression to be notified for matching event changes<br>__Type: "@ChannelStateChange@":#channel-state-listener__
- <div lang="ruby">&block</div> := listener block that is yielded to for matching event changes
- <div lang="swift,objc">call</div> := called possibly with an "@ErrorInfo@":#error-info

h4. Example

"(external) Browser @ChannelState@ change example":<%= JsBins.url_for('realtime/channel-states') %>

h6(#once).
  default: once
  csharp: Once

There are two overloaded versions of this method:

bq(definition#once-state-listener).
  default: once(String event, listener("ChannelStateChange":#channel-state-change stateChange))
  ruby:    once("ChannelEvent":#channel-event *event) -> yields "ChannelStateChange":#channel-state-change
  java:    void once("ChannelEvent":#channel-event event, "ChannelStateListener":#channel-state-listener listener)
  csharp:  void Once("ChannelEvent":#channel-event event, Action<"ChannelStateChange":#channel-state-change> action)
  objc,swift: once(event: "ARTChannelEvent":#channel-event, call: ("ARTChannelStateChange?":#channel-state-change) -> Void) -> ARTEventListener

Register the given listener <span lang="ruby">block</span><span lang="swift,objc">function</span><span lang="csharp">lambda expression</span> for a single occurrence of the specified "ChannelEvent":#channel-event on the @Channel@. Once the listener has been called, it is removed as a registered listener and will not be called again.
The listener is passed a "<span lang="default">ChannelStateChange</span><span lang="objc,swift">ARTChannelStateChange</span>":#channel-state-change object that contains the current state, previous state, the event, a boolean indicating whether the channel was resumed, and an optional reason for the event change.

bq(definition#once-listener).
  default: once(listener("ChannelStateChange":#channel-state-change stateChange))
  ruby:    once -> yields "ChannelStateChange":#channel-state-change
  java:    void once("ChannelStateListener":#channel-state-listener listener)
  csharp:  void Once(Action<"ChannelStateChange":#channel-state-change> listener)
  objc,swift: once(call: ("ARTChannelStateChange?":#channel-state-change) -> Void) -> ARTEventListener

Register the given listener <span lang="ruby">block</span><span lang="swift,objc">function</span><span lang="csharp">lambda expression</span> for a single occurrence of any "ChannelEvent":#channel-event on the @Channel@. Once the listener has been called, it is removed as a registered listener and will not be called again.
The listener is passed a "<span lang="default">ChannelStateChange</span><span lang="objc,swift">ARTChannelStateChange</span>":#channel-state-change object that contains the current state, previous state, the event, a boolean indicating whether the channel was resumed, and an optional reason for the event change.

If an exception is thrown in the listener and bubbles up to the event emitter, it will be caught and logged at @error@ level, so as not to affect other listeners for the same event

h4. Parameters

- <div lang="jsall">event</div> := the channel event to subscribe to, see "ChannelEvent":#channel-event for supported channel events<br>__Type: @String@__
- <div lang="java">event</div> := the channel event to subscribe to<br>__Type: "@ChannelEvent@":#channel-event__
- <div lang="csharp">event</div> := the channel event to subscribe to<br>__Type: "@ChannelEvent@":#channel-event__
- <div lang="ruby">event</div> := the channel event as a Symbol such as @:attached@ or a @ChannelEvent@ object to subscribe to<br>__Type: "@ChannelEvent@":#channel-event__
- <div lang="swift,objc">event</div> := the @ARTChannelEvent@ to subscribe to<br>__Type: "@ARTChannelEvent@":#channel-event__

- <div lang="jsall">listener</div> := is a function of the form @function()@ to be notified for a single occurrence of a matching event change. The current event is available as @this.event@
- <div lang="java">listener</div> := listener to be notified for a single occurrence of a matching event change<br>__Type: "@ChannelStateListener@":#channel-state-listener__
- <div lang="ruby">&block</div> := listener block that is yielded to for a single occurrence of a matching event change
- <div lang="csharp">listener</div> := listener lambda expression that is notified only once for a matching event change
- <div lang="swift,objc">call</div> := called possibly with an "@ErrorInfo@":#error-info

h6(#off).
  default: off
  csharp: Off

There are <span lang="jsall">six</span><span lang="default">two</span> overloaded versions of this method:

bq(definition#off-state-listener).
  default: off(String event, listener)
  ruby:    off("ChannelEvent":#channel-event *event, &block)
  java:    void off("ChannelEvent":#channel-event event, "ChannelStateListener":#channel-state-listener listener)
  csharp:  void Off("ChannelEvent":#channel-event event, Action<"ChannelStateChange":#channel-state-change> listener)
  objc,swift: off(event: "ARTChannelEvent":#channel-event, listener: ARTEventListener)

Remove the given listener <span lang="ruby">block</span> for the "ChannelEvent":#channel-event.

bq(definition#off-listener).
  default: off(listener)
  ruby:    off(&block)
  java:    void off("ChannelStateListener":#channel-state-listener listener)
  csharp:  void Off(Action<"ChannelStateChange":#channel-state-change> listener)
  objc,swift: off(listener: ARTEventListener)

Remove the given listener <span lang="ruby">block</span> for all "ChannelEvents":#channel-event.

<div lang="jsall">
bq(definition). off(String[] events, listener)

Removes the given listener from all "ChannelEvents":#channel-event in the array.

bq(definition). off(String event)

Removes all listeners for a given "@ChannelEvent@":#channel-event .

bq(definition). off(String[] events)

Removes all listeners for all "ChannelEvents":#channel-event in the array.

bq(definition). off()

Removes all listeners (including both those registered against specific events and those registered without an event).
</div>

h4. Parameters

- <div lang="jsall">event(s)</div> := the channel event(s) to unsubscribe from<br>__Type: @String@ or @String[]@__
- <div lang="java">event</div> := the channel event to unsubscribe from<br>__Type: "@ChannelEvent@":#channelevent-
- <div lang="csharp">event</div> := the channel event to unsubscribe from<br>__Type: "@ChannelEvent@":#channel-event__
- <div lang="ruby">event</div> := the channel event as a Symbol such as @:detached@ or a @ChannelEvent@ object to unsubscribe from<br>__Type: "@ChannelEvent@":#channel-event__
- <div lang="swift,objc">event</div> := the @ARTChannelEvent@ to unsubscribe from<br>__Type: "@ARTChannelEvent@":#channel-event__

- <div lang="jsall">listener</div> := is the listener function to be removed
- <div lang="java">listener</div> := is the listener to be removed<br>__Type: "@ChannelStateListener":#channel-state-listener__
- <div lang="csharp">listener</div> := is the listener function to be removed
- <div lang="ruby">&block</div> := is the listener block to be removed
- <div lang="swift,objc">listener</div> := previous return value from a @on@ or @once@ call
- <div lang="flutter">streamSubscription</div> := obtained from calling @on@ can be used to cancel a listener by calling @streamSubscription.cancel@

h2(#related-types). Related types

h3(#channel-state).
  default: ChannelState
  objc,swift: ARTRealtimeChannelState
  ruby:    Channel::STATE Enum
  java:    io.ably.lib.realtime.ChannelState Enum
  csharp:    IO.Ably.Realtime.ChannelState Enum
  flutter: ably.ChannelState Enum

<%= partial partial_version('types/_channel_state') %>

h3(#channel-event).
  default: ChannelEvent
  swift,objc: ARTChannelEvent
  ruby:    Channel::EVENT Enum
  java:    io.ably.lib.realtime.ChannelEvent Enum
  csharp:  IO.Ably.Realtime.ChannelEvent Enum
  flutter: ably.ChannelEvent Enum

<%= partial partial_version('types/_channel_event') %>

h3(#channel-state-change).
  default: ChannelStateChange
  objc,swift: ARTRealtimeChannelStateChange
  java:    io.ably.lib.realtime.ChannelStateListener.ChannelStateChange
  ruby:    ChannelStateChange
  csharp:  IO.Ably.Realtime.ChannelStateChanged
  flutter: ably.ChannelStateChange

<%= partial partial_version('types/_channel_state_change') %>

h3(#message).
  default: Message
  objc,swift: ARTMessage
  ruby:    Ably::Models::Message
  java:    io.ably.lib.types.Message
  csharp:  IO.Ably.Message
  flutter: ably.Message

<%= partial partial_version('types/_message') %>

h3(#channel-options).
  default: ChannelOptions Object
  objc,swift: ARTChannelOptions
  ruby:    ChannelOptions Hash
  java:    io.ably.lib.types.ChannelOptions
  csharp:  IO.Ably.Rest.ChannelOptions
  flutter:  ably.ChannelOptions

<%= partial partial_version('types/_channel_options') %>

h3(#channel-state-listener).
  java: io.ably.lib.realtime.ChannelStateListener

blang[java].
  <%= partial partial_version('types/_channel_state_listener'), indent: 2, skip_first_indent: true %>

h3(#completion-listener).
  java:   io.ably.lib.realtime.CompletionListener

blang[java].
  <%= partial partial_version('types/_completion_listener'), indent: 2, skip_first_indent: true %>

h3(#paginated-request-params).
  csharp: PaginatedRequestParams

blang[csharp].
  <%= partial partial_version('types/_history_request_params'), indent: 2, skip_first_indent: true %>

h3(#message-listener).
  java:   io.ably.lib.realtime.Channel.MessageListener

blang[java].
  <%= partial partial_version('types/_message_listener'), indent: 2, skip_first_indent: true %>

h3(#paginated-result).
  default: PaginatedResult
  objc,swift: ARTPaginatedResult
  ruby:    Ably::Models::PaginatedResult
  java:    io.ably.lib.types.PaginatedResult
  csharp:  IO.Ably.PaginatedResult

<%= partial partial_version('types/_paginated_result') %>

h3(#param).
  java:    io.ably.lib.types.Param

blang[java].
  <%= partial partial_version('types/_param'), indent: 2, skip_first_indent: true %>
