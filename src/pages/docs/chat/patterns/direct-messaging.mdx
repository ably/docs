---
title: Direct messaging patterns
meta_description: "Learn how to implement direct messaging and group chat patterns using notification channels and dynamic channel subscriptions."
---

Direct messaging (DM) and group chat functionality requires a dynamic approach to channel subscriptions. Users need to be notified when new conversations are created and seamlessly join those conversations with appropriate message history.

## Architecture overview

The direct messaging pattern uses notification channels to alert users when they should subscribe to new conversation channels. This enables dynamic channel management for DMs and group chats.

### Core components

**Notification channels:** Each user has a personal notification/control channel based on their clientId (e.g., `notifications:${clientId}`). This channel receives signals to join new conversations.

**Conversation channels:** Dynamic channels created for each DM or group chat. These can be created on-demand when conversations begin.

**Server-side channel tracking:** The server maintains lists of which channels each user is active on, enabling robust reconnection and optimization.

## Implementation flow

### Initial connection

1. User connects and subscribes to their personal notification channel
2. User also subscribes to any existing conversation channels they're part of
3. Server tracks which channels the user has joined

### Creating new conversations

1. User A initiates a DM or creates a group chat
2. Server creates the conversation channel for participants
3. Server sends join signals to participants via their notification channels
4. Users receive the signal and subscribe to the conversation channel
5. Users join with [rewind](/docs/channels/options/rewind) enabled to get message context

### Seamless joining with context

When users join a conversation channel, they use rewind to receive previously published messages. This ensures they have context about the conversation without missing important information.

### Presence-based optimization

The server uses [presence](/docs/presence-occupancy/presence) in channels to determine whether users are currently active. This prevents sending unnecessary join signals to users who are already participating in a conversation.

### Reconnection handling

When users reconnect after being offline:

1. Server checks which channels the user should be active on
2. Users are notified to rejoin channels they were previously part of
3. Quiet channels can be reconnected if new activity occurs

## Channel naming strategies

Use consistent naming patterns to organize different types of conversations:

- Direct messages between specific users
- Group conversations with multiple participants  
- Notification channels per user

## Server-side management

**Channel list maintenance:** Keep track of which channels each user is active on server-side. This enables proper reconnection and helps determine when to send join notifications.

**Presence monitoring:** Use presence events to know whether users are currently active in channels. This optimizes when to send join signals.

**Dynamic creation:** Create conversation channels on-demand when new DMs or group chats are initiated.

## Security and permissions

**Authentication:** Use [identified clients](/docs/auth/identified-clients) to ensure trusted user identities in conversations.

**Capabilities:** Configure appropriate [capabilities](/docs/auth/capabilities) to control who can publish and subscribe to different channel types.

**Privacy:** Consider [encryption](/docs/channels/options/encryption) for sensitive conversations.

## Best practices

**Message history:** Configure appropriate rewind settings based on conversation type - new conversations might need less context than ongoing discussions.

**Channel cleanup:** Implement strategies for managing inactive channels and cleaning up old conversations.

**Scalability:** Monitor channel usage per user and implement limits to prevent resource exhaustion.

**Error handling:** Handle cases where users can't join channels due to network issues or permission problems.

This pattern provides the foundation for implementing sophisticated direct messaging systems that scale with your user base while maintaining a smooth user experience.