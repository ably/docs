---
title: "Tool calls"
meta_description: "Stream tool call execution visibility to users, enabling transparent AI interactions and generative UI experiences."
meta_keywords: "tool calls, function calling, generative UI, AI transparency, tool execution, streaming JSON, realtime feedback"
---

Modern AI models can invoke tools (also called functions) to perform specific tasks like retrieving data, performing calculations, or triggering actions. Streaming tool call information to users provides visibility into what the AI is doing, creates opportunities for rich generative UI experiences, and builds trust through transparency.

## What are tool calls? <a id="what"/>

Tool calls occur when an AI model decides to invoke a specific function or tool to accomplish a task. Rather than only returning text, the model can request to execute tools you've defined, such as fetching weather data, searching a database, or performing calculations.

A tool call consists of:

- Tool name: The identifier of the tool being invoked
- Tool input: Parameters passed to the tool, often structured as JSON
- Tool output: The result returned after execution

As an application developer, you decide how to surface tool calls to users. You may choose to display all tool calls, selectively surface specific tools or inputs/outputs, or keep tool calls entirely private.

Surfacing tool calls supports:

- Trust and transparency: Users see what actions the AI is taking, building confidence in the agent
- Human-in-the-loop workflows: Expose tool calls [resolved by humans](/docs/ai-transport/messaging/human-in-the-loop) where users can review and approve tool execution before it happens
- Generative UI: Build dynamic, contextual UI components based on the structured tool data

## Publish tool calls <a id="publishing"/>

Publish tool call and model output messages to the channel.

In the example below, the `responseId` is included in the message [extras](/docs/messages#properties) to allow subscribers to correlate all messages belonging to the same response. The message [`name`](/docs/messages#properties) allows the client to distinguish between the different message types:

<Code>
```javascript
const channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');

// Example: stream returns events like:
// { type: 'tool_call', name: 'get_weather', args: '{"location":"San Francisco"}', toolCallId: 'tool_123', responseId: 'resp_abc123' }
// { type: 'tool_result', name: 'get_weather', result: '{"temp":72,"conditions":"sunny"}', toolCallId: 'tool_123', responseId: 'resp_abc123' }
// { type: 'message', text: 'The weather in San Francisco is 72°F and sunny.', responseId: 'resp_abc123' }

for await (const event of stream) {
  if (event.type === 'tool_call') {
    // Publish tool call arguments
    await channel.publish({
      name: 'tool_call',
      data: {
        name: event.name,
        args: event.args
      },
      extras: {
        headers: {
          responseId: event.responseId,
          toolCallId: event.toolCallId
        }
      }
    });
  } else if (event.type === 'tool_result') {
    // Publish tool call results
    await channel.publish({
      name: 'tool_result',
      data: {
        name: event.name,
        result: event.result
      },
      extras: {
        headers: {
          responseId: event.responseId,
          toolCallId: event.toolCallId
        }
      }
    });
  } else if (event.type === 'message') {
    // Publish model output messages
    await channel.publish({
      name: 'message',
      data: event.text,
      extras: {
        headers: {
          responseId: event.responseId
        }
      }
    });
  }
}
```
```python
channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')

# Example: stream returns events like:
# { 'type': 'tool_call', 'name': 'get_weather', 'args': '{"location":"San Francisco"}', 'toolCallId': 'tool_123', 'responseId': 'resp_abc123' }
# { 'type': 'tool_result', 'name': 'get_weather', 'result': '{"temp":72,"conditions":"sunny"}', 'toolCallId': 'tool_123', 'responseId': 'resp_abc123' }
# { 'type': 'message', 'text': 'The weather in San Francisco is 72°F and sunny.', 'responseId': 'resp_abc123' }

async for event in stream:
    if event['type'] == 'tool_call':
        # Publish tool call arguments
        message = Message(
            name='tool_call',
            data={
                'name': event['name'],
                'args': event['args']
            },
            extras={
                'headers': {
                    'responseId': event['responseId'],
                    'toolCallId': event['toolCallId']
                }
            }
        )
        await channel.publish(message)
    elif event['type'] == 'tool_result':
        # Publish tool call results
        message = Message(
            name='tool_result',
            data={
                'name': event['name'],
                'result': event['result']
            },
            extras={
                'headers': {
                    'responseId': event['responseId'],
                    'toolCallId': event['toolCallId']
                }
            }
        )
        await channel.publish(message)
    elif event['type'] == 'message':
        # Publish model output messages
        message = Message(
            name='message',
            data=event['text'],
            extras={
                'headers': {
                    'responseId': event['responseId']
                }
            }
        )
        await channel.publish(message)
```
```java
Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");

// Example: stream returns events like:
// { type: 'tool_call', name: 'get_weather', args: '{"location":"San Francisco"}', toolCallId: 'tool_123', responseId: 'resp_abc123' }
// { type: 'tool_result', name: 'get_weather', result: '{"temp":72,"conditions":"sunny"}', toolCallId: 'tool_123', responseId: 'resp_abc123' }
// { type: 'message', text: 'The weather in San Francisco is 72°F and sunny.', responseId: 'resp_abc123' }

for (Event event : stream) {
    JsonObject extras = new JsonObject();
    JsonObject headers = new JsonObject();

    if (event.getType().equals("tool_call")) {
        // Publish tool call arguments
        JsonObject data = new JsonObject();
        data.addProperty("name", event.getName());
        data.addProperty("args", event.getArgs());

        headers.addProperty("responseId", event.getResponseId());
        headers.addProperty("toolCallId", event.getToolCallId());
        extras.add("headers", headers);

        channel.publish(new Message("tool_call", data, new MessageExtras(extras)));
    } else if (event.getType().equals("tool_result")) {
        // Publish tool call results
        JsonObject data = new JsonObject();
        data.addProperty("name", event.getName());
        data.addProperty("result", event.getResult());

        headers.addProperty("responseId", event.getResponseId());
        headers.addProperty("toolCallId", event.getToolCallId());
        extras.add("headers", headers);

        channel.publish(new Message("tool_result", data, new MessageExtras(extras)));
    } else if (event.getType().equals("message")) {
        // Publish model output messages
        headers.addProperty("responseId", event.getResponseId());
        extras.add("headers", headers);

        channel.publish(new Message("message", event.getText(), new MessageExtras(extras)));
    }
}
```
</Code>

<Aside data-type="note">
Model APIs like OpenAI's [Responses API](https://platform.openai.com/docs/api-reference/responses) and Anthropic's [Messages API](https://platform.claude.com/docs/en/api/messages) don't include tool results in their streams - instead, you execute tools in your code and return results to the model, but the model's output doesn't echo those results back. Agent SDKs like [OpenAI Agent SDK](https://platform.openai.com/docs/guides/agents-sdk) and [Claude Agent SDK](https://platform.claude.com/docs/en/agent-sdk/overview) maintain context and surface both tool calls and results on the stream. When using model APIs directly, publish tool results to the channel separately if you want to surface them to subscribers.
</Aside>

<Aside data-type="note">
To learn how to stream individual tokens as they are generated, see the [token streaming](/docs/ai-transport/token-streaming) documentation.
</Aside>

<Aside data-type="note">
Set [`echoMessages`](/docs/api/realtime-sdk/types#client-options) to `false` on the agent's Ably client to prevent the agent from receiving its own tool call messages, avoiding billing for [echoed messages](/docs/pub-sub/advanced#echo).
</Aside>

## Subscribe to tool calls <a id="subscribing"/>

Subscribe to tool call and model output messages on the channel.

In the example below, the `responseId` from the message [`extras`](/docs/api/realtime-sdk/messages#extras) is used to group tool calls and model output messages belonging to the same response. The message [`name`](/docs/messages#properties) allows the client to distinguish between the different message types:

<Code>
```javascript
const channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');

// Track responses by ID, each containing tool calls and final response
const responses = new Map();

// Subscribe to all events on the channel
await channel.subscribe((message) => {
  const responseId = message.extras?.headers?.responseId;

  if (!responseId) {
    console.warn('Message missing responseId');
    return;
  }

  // Initialize response object if needed
  if (!responses.has(responseId)) {
    responses.set(responseId, {
      toolCalls: new Map(),
      message: ''
    });
  }

  const response = responses.get(responseId);

  // Handle each message type
  switch (message.name) {
    case 'message':
      response.message = message.data;
      break;
    case 'tool_call':
      const toolCallId = message.extras?.headers?.toolCallId;
      response.toolCalls.set(toolCallId, {
        name: message.data.name,
        args: message.data.args
      });
      break;
    case 'tool_result':
      const resultToolCallId = message.extras?.headers?.toolCallId;
      const toolCall = response.toolCalls.get(resultToolCallId);
      if (toolCall) {
        toolCall.result = message.data.result;
      }
      break;
  }

  // Display the tool calls and response for this turn
  console.log(`Response ${responseId}:`, response);
});
```
```python
channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')

# Track responses by ID, each containing tool calls and final response
responses = {}

# Subscribe to all events on the channel
def on_message(message):
    response_id = message.extras.get('headers', {}).get('responseId')

    if not response_id:
        print('Message missing responseId')
        return

    # Initialize response object if needed
    if response_id not in responses:
        responses[response_id] = {
            'toolCalls': {},
            'message': ''
        }

    response = responses[response_id]

    # Handle each message type
    if message.name == 'message':
        response['message'] = message.data
    elif message.name == 'tool_call':
        tool_call_id = message.extras.get('headers', {}).get('toolCallId')
        response['toolCalls'][tool_call_id] = {
            'name': message.data['name'],
            'args': message.data['args']
        }
    elif message.name == 'tool_result':
        result_tool_call_id = message.extras.get('headers', {}).get('toolCallId')
        tool_call = response['toolCalls'].get(result_tool_call_id)
        if tool_call:
            tool_call['result'] = message.data['result']

    # Display the tool calls and response for this turn
    print(f'Response {response_id}:', response)

await channel.subscribe(on_message)
```
```java
Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");

// Track responses by ID, each containing tool calls and final response
Map<String, Response> responses = new ConcurrentHashMap<>();

// Subscribe to all events on the channel
channel.subscribe(message -> {
    JsonObject headers = message.extras.asJsonObject().get("headers").getAsJsonObject();
    String responseId = headers != null ? headers.get("responseId").getAsString() : null;

    if (responseId == null) {
        System.err.println("Message missing responseId");
        return;
    }

    // Initialize response object if needed
    responses.putIfAbsent(responseId, new Response());
    Response response = responses.get(responseId);

    // Handle each message type
    switch (message.name) {
        case "message":
            response.setMessage((String) message.data);
            break;
        case "tool_call":
            String toolCallId = headers.get("toolCallId").getAsString();
            JsonObject data = (JsonObject) message.data;
            ToolCall toolCall = new ToolCall();
            toolCall.setName(data.get("name").getAsString());
            toolCall.setArgs(data.get("args").getAsString());
            response.getToolCalls().put(toolCallId, toolCall);
            break;
        case "tool_result":
            String resultToolCallId = headers.get("toolCallId").getAsString();
            ToolCall existingToolCall = response.getToolCalls().get(resultToolCallId);
            if (existingToolCall != null) {
                JsonObject resultData = (JsonObject) message.data;
                existingToolCall.setResult(resultData.get("result").getAsString());
            }
            break;
    }

    // Display the tool calls and response for this turn
    System.out.println("Response " + responseId + ": " + response);
});
```
</Code>

<Aside data-type="further-reading">
To learn about hydrating responses from channel history, including using `rewind` or `untilAttach`, handling in-progress responses, and correlating with database records, see client hydration in the [message-per-response](/docs/ai-transport/token-streaming/message-per-response#hydration) and [message-per-token](/docs/ai-transport/token-streaming/message-per-token#hydration) documentation.
</Aside>

## Generative UI <a id="generative-ui"/>

Tool calls provide structured data that can form the basis of generative UI - dynamically creating UI components based on the tool being invoked, its parameters, and the results returned. Rather than just displaying raw tool call information, you can render rich, contextual components that provide a better user experience.

For example, when a weather tool is invoked, instead of showing raw JSON like `{ location: 'San Francisco', temp: 72, conditions: 'sunny' }`, you can render a weather card component with icons, formatted temperature, and visual indicators:

<Code>
```javascript
const channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');

await channel.subscribe((message) => {
  // Render component when tool is invoked
  if (message.name === 'tool_call' && message.data.name === 'get_weather') {
    const args = JSON.parse(message.data.args);
    renderWeatherCard({ location: args.location, loading: true });
  }

  // Update component with results
  if (message.name === 'tool_result' && message.data.name === 'get_weather') {
    const result = JSON.parse(message.data.result);
    renderWeatherCard(result);
  }
});
```
```python
channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')

def on_message(message):
    # Render component when tool is invoked
    if message.name == 'tool_call' and message.data['name'] == 'get_weather':
        args = json.loads(message.data['args'])
        render_weather_card({'location': args['location'], 'loading': True})

    # Update component with results
    if message.name == 'tool_result' and message.data['name'] == 'get_weather':
        result = json.loads(message.data['result'])
        render_weather_card(result)

await channel.subscribe(on_message)
```
```java
Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");

channel.subscribe(message -> {
    // Render component when tool is invoked
    if (message.name.equals("tool_call")) {
        JsonObject data = (JsonObject) message.data;
        if (data.get("name").getAsString().equals("get_weather")) {
            JsonObject args = JsonParser.parseString(data.get("args").getAsString()).getAsJsonObject();
            renderWeatherCard(args.get("location").getAsString(), true);
        }
    }

    // Update component with results
    if (message.name.equals("tool_result")) {
        JsonObject data = (JsonObject) message.data;
        if (data.get("name").getAsString().equals("get_weather")) {
            JsonObject result = JsonParser.parseString(data.get("result").getAsString()).getAsJsonObject();
            renderWeatherCard(result);
        }
    }
});
```
</Code>

<Aside data-type="note">
Models generate tool call arguments token by token, which you can stream to the client. When implementing token-level streaming, your UI should handle parsing partial JSON gracefully to render realtime updates as the arguments stream in. To learn more about approaches to token streaming, see the [token streaming](/docs/ai-transport/token-streaming) documentation.
</Aside>

## Client-side tools <a id="client-tools"/>

Some tools need to be executed directly on the client device rather than on the server, allowing agents to dynamically access information available on the end user's device as needed. These include tools that access device capabilities such as GPS location, camera, SMS, local files, or other native functionality.

Client-side tool calls follow a request-response pattern over Ably channels:

1. The agent publishes a tool call request to the channel.
2. The client receives and executes the tool using device APIs.
3. The client publishes the result back to the channel.
4. The agent receives the result and continues processing.

<Aside data-type="further-reading">
For more information about bi-directional communication patterns between agents and users, see [Accepting user input](/docs/ai-transport/messaging/accepting-user-input) and [Human-in-the-loop](/docs/ai-transport/messaging/human-in-the-loop).
</Aside>

The client subscribes to tool call requests, executes the tool using device APIs, and publishes the result back to the channel. The `toolCallId` enables correlation between tool call requests and results:

<Code>
```javascript
const channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');

await channel.subscribe('tool_call', async (message) => {
  const { name, args } = message.data;
  const { responseId, toolCallId } = message.extras?.headers || {};

  if (name === 'get_location') {
    const result = await getGeolocationPosition();
    await channel.publish({
      name: 'tool_result',
      data: {
        name: name,
        result: {
          lat: result.coords.latitude,
          lng: result.coords.longitude
        }
      },
      extras: {
        headers: {
          responseId: responseId,
          toolCallId: toolCallId
        }
      }
    });
  }
});
```
```python
channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')

async def on_tool_call(message):
    name = message.data['name']
    args = message.data.get('args')
    headers = message.extras.get('headers', {})
    response_id = headers.get('responseId')
    tool_call_id = headers.get('toolCallId')

    if name == 'get_location':
        result = await get_geolocation_position()
        message = Message(
            name='tool_result',
            data={
                'name': name,
                'result': {
                    'lat': result['coords']['latitude'],
                    'lng': result['coords']['longitude']
                }
            },
            extras={
                'headers': {
                    'responseId': response_id,
                    'toolCallId': tool_call_id
                }
            }
        )
        await channel.publish(message)

await channel.subscribe('tool_call', on_tool_call)
```
```java
Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");

channel.subscribe("tool_call", message -> {
    JsonObject data = (JsonObject) message.data;
    String name = data.get("name").getAsString();
    JsonObject headers = message.extras.asJsonObject().get("headers");
    String responseId = headers.get("responseId").getAsString();
    String toolCallId = headers.get("toolCallId").getAsString();

    if (name.equals("get_location")) {
        GeolocationPosition result = getGeolocationPosition();

        JsonObject resultData = new JsonObject();
        resultData.addProperty("name", name);
        JsonObject resultValue = new JsonObject();
        resultValue.addProperty("lat", result.getCoords().getLatitude());
        resultValue.addProperty("lng", result.getCoords().getLongitude());
        resultData.add("result", resultValue);

        JsonObject resultExtras = new JsonObject();
        JsonObject resultHeaders = new JsonObject();
        resultHeaders.addProperty("responseId", responseId);
        resultHeaders.addProperty("toolCallId", toolCallId);
        resultExtras.add("headers", resultHeaders);

        channel.publish(new Message("tool_result", resultData, new MessageExtras(resultExtras)));
    }
});
```
</Code>

<Aside data-type="note">
Client-side tools often require user permission to access device APIs. These permissions are managed by the device operating system, not the agent. Handle permission denials gracefully by publishing an error tool result so the AI can respond appropriately.
</Aside>

<Aside data-type="note">
Set [`echoMessages`](/docs/api/realtime-sdk/types#client-options) to `false` in the client options to prevent tool results from being echoed back to the client that published them. This avoids billing for the echoed message. When disabled, update your UI to reflect the tool execution status immediately upon sending rather than waiting for the echoed message. See [echoing messages](/docs/pub-sub/advanced#echo) for more details.
</Aside>

The agent subscribes to tool results to continue processing. The `toolCallId` correlates the result back to the original request:

<Code>
```javascript
const pendingToolCalls = new Map();

await channel.subscribe('tool_result', (message) => {
  const { toolCallId, result } = message.data;
  const pending = pendingToolCalls.get(toolCallId);

  if (!pending) return;

  // Pass result back to the AI model to continue the conversation
  processResult(pending.responseId, toolCallId, result);

  pendingToolCalls.delete(toolCallId);
});
```
```python
pending_tool_calls = {}

def on_tool_result(message):
    tool_call_id = message.data.get('toolCallId')
    result = message.data.get('result')
    pending = pending_tool_calls.get(tool_call_id)

    if not pending:
        return

    # Pass result back to the AI model to continue the conversation
    process_result(pending['responseId'], tool_call_id, result)

    del pending_tool_calls[tool_call_id]

await channel.subscribe('tool_result', on_tool_result)
```
```java
Map<String, PendingToolCall> pendingToolCalls = new ConcurrentHashMap<>();

channel.subscribe("tool_result", message -> {
    JsonObject data = (JsonObject) message.data;
    String toolCallId = data.get("toolCallId").getAsString();
    JsonObject result = data.get("result").getAsJsonObject();
    PendingToolCall pending = pendingToolCalls.get(toolCallId);

    if (pending == null) {
        return;
    }

    // Pass result back to the AI model to continue the conversation
    processResult(pending.getResponseId(), toolCallId, result);

    pendingToolCalls.remove(toolCallId);
});
```
</Code>

## Human-in-the-loop workflows <a id="human-in-the-loop"/>

Tool calls resolved by humans are one approach to implementing human-in-the-loop workflows. When an agent encounters a tool call that needs human resolution, it publishes the tool call to the channel and waits for the human to publish the result back over the channel.

For example, a tool that modifies data, performs financial transactions, or accesses sensitive resources might require explicit user approval before execution. The tool call information is surfaced to the user, who can then approve or reject the action.

<Aside data-type="further-reading">
For detailed implementation patterns and best practices for human-in-the-loop workflows, including authorization and verification strategies, see the [human-in-the-loop](/docs/ai-transport/messaging/human-in-the-loop) documentation.
</Aside>
