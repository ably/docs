---
title: Connections
meta_description: "Establish and maintain a persistent connection to Ably using the Realtime SDK."
languages:
  - javascript
  - nodejs
  - ruby
  - java
  - swift
  - objc
  - csharp
  - flutter
---

p(note). This section applies to the Ably Realtime Client only.

The Ably Realtime SDK establishes and maintains a connection to the Ably service, using the most efficient transport available, typically "WebSockets":https://ably.com/topic/websockets. The Ably realtime protocol operates and multiplexes all channel traffic over that connection. Channels are separate from Connections and are used to logically separate messages into different topics, see the "channels documentation":/channels for further information.

h2(#getting-started). Creating a connection

The Ably Realtime SDK opens and maintains a connection to the Ably realtime servers on instantiation. The @Connection@ object provides a straightforward API to monitor and manage "connection state":/connect/states.

This example relies on the default auto-connect behavior of the SDK, and then subscribes to the connection's @connected@ event:

bc[javascript]. const ably = new Ably.Realtime({ '{{API_KEY}}' });
ably.connection.on('connected', () => {
  console.log('Connected to Ably!');
});

bc[nodejs]. const Ably = require('ably');
const ably = new Ably.Realtime({ '{{API_KEY}}' });  
ably.connection.on('connected', () => {
  console.log('Connected to Ably!');
});

bc[ruby]. ably = Ably::Realtime.new('{{API_KEY}}')
ably.connection.on(:connected) do
  puts "Connected to Ably!"
end

bc[java]. AblyRealtime ably = new AblyRealtime("{{API_KEY}}");
ably.connection.on('connected', new ConnectionStateListener() {
  @Override
  public void onConnectionStateChanged(ConnectionStateChange change) {
    System.out.println("Connected to Ably!");
  }
});

bc[csharp]. AblyRealtime ably = new AblyRealtime("{{API_KEY}}");
ably.Connection.On(ConnectionEvent.Connected, args => {
  Console.WriteLine("Connected to Ably!");
});

bc[objc]. ARTRealtime *ably = [[ARTRealtime alloc] initWithKey:@"{{API_KEY}}"];
[ably.connection on:ARTRealtimeConnectionEventConnected callback:^(ARTConnectionStateChange *change) {
    NSLog(@"Connected to Ably!");
}];

bc[swift]. let realtime = ARTRealtime(key: "{{API_KEY}}")
realtime.connection.on(.connected) { change in
    print("Connected to Ably!")
}

bc[flutter]. final realtime = ably.Realtime(key: '{{API_KEY}}');
final channel = realtime
  .on(ably.ConnectionStateChange.connected)
  .subscribe((ably.ConnectionStateChange stateChange) {
    print('Connected to Ably!');
  }
);

blang[javascript,nodejs].
  If using the promises interface:

  bc[javascript]. const ably = new Ably.Realtime.Promise('{{API_KEY}}');
  await ably.connection.once("connected");
  console.log('Connected to Ably!');

  bc[nodejs]. const Ably = require('ably');
  const ably = new Ably.Realtime.Promise('{{API_KEY}}');
  await ably.connection.once("connected");
  console.log('Connected to Ably!');


<span lang="ruby">Note that all examples on this page assume you are running them within an EventMachine reactor. Find out more in our "Realtime usage documentation":/realtime/usage.</span>

h2(#monitoring-connections). Monitoring connections

Connection monitoring allows you to view and manage the "states of connections":/connect/states to Ably, showing events for individual people connecting and disconnecting. The "developer console":/account/LINK-ME also shows these events.

This feature is intended for debugging, so once the number of new connections exceeds the number of messages per second permitted by the lifecycle channel, new events will be dropped. This means if you want a definitive list of everyone using your app you'd be best using "token authentication":/auth/token to create your own 'auth server'.

h3(#metachannels). Connection metachannels

Sampled connection events for an app are published to the channel @[meta]clientEvents:connections@. Connection events can be used to compile statistics relating to client population.

The connection event types are:

- connection.opened := The connection was successfully made by the client to Ably.
- connection.closed := The connection was explicitly closed by the client.
- connection.refused := The connection was rejected for an expected reason, such as invalid credentials or a malformed request.
- connection.failed := The connection was rejected for an unexpected reason, such as a network failure.

Events contain a subset of the following metadata in the @data@ field:

- host := The host the connection was made to.<br>__Type: @String@__
- requestId := The unique ID of the request that Ably can use to correlate a connection event with internal logs, if necessary.<br>__Type: @String@__
- region := The region the connection was made from.<br>__Type: @String@__
- headers := The headers sent with the connection.<br>__Type: @JSON Object@__
- query := The parsed query string of the connection request, excluding authentication parameters. It contains connection information such as the SDK version and any custom transport parameters.<br>__Type: @JSON Object@__
- connectionId := The unique ID of the connection.<br>__Type: @String@__
- clientId := The ID of the client that attempted the connection.<br>__Type: @String@__
- channels := A list of channels included in the request. This is only relevant where channels are supported as part of the connection request, such as with "SSE":/protocols/sse. <br>__Type: @Array@__
- duration := The duration the connection was open for.<br>__Type: @Integer@__
- error := The details of any error encountered whilst making the connection request. It includes an error message, error code and HTTP status code.<br>__Type: @JSON Object@__

An example of a @connection.closed@ event is:

```[json]
{
  "host": "realtime.ably.io",
  "requestId": "fbbcb0ab-fa56-47c4-bbd4-fccc22a271b8",
  "region": "us-east-1",
  "headers": {
    "host": "realtime.ably.io",
    ...
  },
  "query": {
    "format": "json",
    "heartbeats": "true",
    "v": "1.2",
    "lib": "js-web-1.2.9"
  },
  "connectionId": "54321",
  "clientId": "12345",
  "duration": 61151
}
```

p(note). The Ably dashboard contains a developer console. In the developer console you can view connection events. See the "developer console section":/account/LINK-ME for more information.

h3(#connection-ids). Connection IDs

An active connection ID is guaranteed to be unique in the Ably system whilst it is active, i.e. no other connection will share that connection ID. However, Ably reserves the right to generate a new connection ID later that may be the same as a previously discarded connection ID (once the connection is closed). Therefore we advise customers to not use the connection ID as a perpetual unique identifier as it is possible that a connection ID may be used many times.

h2(#heartbeats). Heartbeats

Heartbeats enable Ably to identify clients that abruptly disconnect from the service, such as where an internet connection drops out or a client changes networks.

Ably sends a heartbeat to connected clients every 15 seconds. If a client goes more than 25 seconds without seeing any server activity from Ably, it assumes that something has gone wrong with the connection and the "connection state":/connect/states will become @disconnected@. The 25 seconds the client waits is the heartbeat interval plus a 10 second margin of error to allow for network delays.

Ably also uses this mechanism to detect dropped client connections, though some details vary depending on the transport used.

It is important to note that this mechanism is only used when something disrupts communication and does not properly terminate the TCP connection. It isn't used when a connection is deliberately closed or disconnected, for example by calling the "@close()@ method":/api/realtime-sdk/connection#close or being disconnected by the server.

The 15 second interval between heartbeats is used to strike a balance between optimizing battery usage for client devices and the time it takes to identify a dropped or unstable connection.

The interval between heartbeats can be customized if your app requires increased battery preservation or to identify dropped connections more quickly. Set a value between 5000 and 1800000 milliseconds (5 seconds and 30 minutes) using the @heartbeatInterval@ parameter within the @transportParams@ property of the "@clientOptions@":/api/realtime-sdk#client-options object.

Using a higher @heartbeatInterval@ can increase the time taken for the Ably service and the client itself to identify a connection has dropped when an abrupt disconnect occurs. The number of "peak connections":/account/LINK-ME may also appear higher as it can take longer to terminate dropped connections. Although @heartbeatInterval@ can be set as high as 30 minutes, Ably does not recommend setting it this high.

The following example code demonstrates establishing a connection to Ably with a @heartbeatInterval@ of 10 seconds:

bc[jsall]. const ably = new Ably.Realtime(
  {
    key: '{{API_KEY}}',
    transportParams: { heartbeatInterval: 10000 }
  }
);

h2(#closing-a-connection). Closing a connection

p(note). There is a 2 minute delay if a connection is not explicitly closed which could impact peak connections and thus costs.

blang[default,javascript].
  A connection to Ably can be closed once it is no longer needed.

  The following code sample explicitly closes the connection to Ably and prints the message @Closed the connection to Ably@.

blang[php].
  The <span lang="php">PHP</span> SDK is only available with a REST interface. You will need to use one of the realtime libraries to create or manage a connection to Ably. Use the language selector above to select a language with realtime support.

bc[javascript]. ably.close(); // runs synchronously
console.log('Closed the connection to Ably.');

bc[nodejs]. ably.close(); // runs synchronously
console.log('Closed the connection to Ably.');

bc[java]. ably.connection.close();
ably.connection.on(ConnectionState.closed, new ConnectionStateListener() {
  @Override
  public void onConnectionStateChanged(ConnectionStateChange state) {
    System.out.println("New state is " + state.current.name());
    switch (state.current) {
      case closed: {
        // Connection closed
        System.out.println("Closed the connection to Ably.");
        break;
      }
      case failed: {
        // Failed to close connection
        break;
      }
    }
  }
});

bc[python]. await ably.close()
print('Closed the connection to Ably.')

bc[ruby]. ably.connection.close
ably.connection.on(:closed) do
  puts "Closed the connection to Ably!"
end

bc[swift]. ably.connection.close()
ably.connection.on { stateChange in
    let stateChange = stateChange
    switch stateChange.current {
    case .closed:
        print("Closed the connection to Ably.")
    case .failed:
        print("Failed to close connection to Ably.")
    default:
        break
    }
}

bc[csharp]. ably.Connection.Close();
ably.Connection.On(ConnectionEvent.Closed, args =>
{
  Console.Out.WriteLine("Closed the connection to Ably.");
});

bc[objc]. [ably.connection close];
[ably.connection on:ARTRealtimeConnectionEventClosed callback:^(ARTConnectionStateChange *stateChange) {
    NSLog(@"Closed the connection to Ably.");
}];

bc[flutter]. realtime.connection.close();
realtime.connection
  .on(ably.ConnectionEvent.closed)
  .listen((ably.ConnectionStateChange stateChange) async {
    print('New state is: ${stateChange.current}');
    switch (stateChange.current) {
      case ably.ConnectionState.closed:
        // Connection closed
        print('Closed the connection to Ably.');
        break;
      case ably.ConnectionState.failed:
        // Failed to close connection
        break;
    }
});

bc[go]. client.Connection.On(ably.ConnectionEventClosed, func(change ably.ConnectionStateChange) {
    fmt.Println("Closed the connection to Ably.")
})
client.Close()

h2(#api-reference). API Reference

View the "Connection API Reference":/api/realtime-sdk/connection.
