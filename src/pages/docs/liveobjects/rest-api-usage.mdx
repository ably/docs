---
title: Using the REST API
meta_description: "Learn how to work with Ably LiveObjects using the REST API"
---

<Aside data-type='public-preview'>
LiveObjects REST API is in Public Preview. We are committed to supporting the LiveObjects REST API and welcome adoption and feedback.

**Building with LiveObjects?** Help shape its future by [sharing your use case](https://44qpp.share.hsforms.com/2fZobHQA1ToyRfB9xqZYQmQ).
</Aside>

LiveObjects provides a comprehensive REST API that enables you to directly work with objects without using a client SDK.

## Authentication <a id="authentication"/>

View the REST API [authentication](/docs/api/rest-api#authentication) documentation for details on how to authenticate your requests.

To use LiveObjects, an API key must have at least the `object-subscribe` capability. With only this capability, clients will have read-only access, preventing them from publishing operations.

In order to create or update objects, make sure your API key includes both `object-subscribe` and `object-publish` [capabilities](/docs/auth/capabilities) to allow full read and write access.

## Getting started: Fetch objects <a id="fetch-object"/>

### Get the entire channel object <a id="fetching-object-get"/>

The following request returns the entire channel object in compact format.

<Code>
```shell
  curl "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}}
```
</Code>

This endpoint returns the compact representation, which shows the logical structure of your data without metadata.

Example response:

<Code>
  ```json
  {
    "votes": {
      "down": 10,
      "up": 5
    }
  }
  ```
</Code>

This example shows a LiveMap "votes" stored on the channel object containing two LiveCounter instances: "down" and "up".


### Query objects by path <a id="fetch-object-with-path"/>

Return a subset of the channel object by specifying the `path` query parameter. For example, to return only the `votes` LiveMap instance from the root object:

<Code>
  ```shell
  curl "https://main.realtime.ably.net/channels/my-channel/object?path=votes" \
  -u {{API_KEY}}
  ```
</Code>

Example response:

<Code>
  ```json
  {
    "down": 5,
    "up": 10
  }
  ```
</Code>

### Get an object by ID <a id="simple-object-get-by-id"/>

To get a specific instance of an object type on the channel you can specify the object ID in the URL path:

<Code>
```shell
  curl "https://main.realtime.ably.net/channels/my-channel/object/map:qZXBk8xaGqf4kwLSlR7Tj0Eqhd48WDFfb3gTAbj194k@1760448597692" \
    -u {{API_KEY}}
```
</Code>

This endpoint also supports the `path` query option. Note that the path is evaluated relative to the specified object instance.

## Publishing operations <a id="publishing-operations"/>

Publish all operations to the same endpoint: `POST /channels/{channelId}/object`

Each operation includes:
1. A reference to an object using either **objectId** or **path**
2. An **operation-specific field** (`mapSet`, `counterInc`, etc.) containing the operation parameters

### Address objects in operations <a id="addressing-objects"/>

Address objects using either `objectId` or `path`:
- `objectId` (string): The unique identifier of the object instance to update
- `path` (string): The path to the object instance within the channel object

Use dot-separated notation for paths (e.g. `votes.up`), relative to the root of the channel object. An empty path `""` refers to the root channel object.

<Aside data-type='important'>
When using path operations, the server resolves object IDs at the time it receives the request. Ably applies the operation to these specific object instances. If the object instances at the specified path change due to concurrent updates before Ably processes the operation, Ably does not apply the operation to the new object instances.
</Aside>

### Available operations <a id="operation-types"/>

LiveObjects supports the following operations:

| Operation | Description |
| --------- | ----------- |
| `mapSet` | Sets a key/value pair in a LiveMap. |
| `mapRemove` | Removes a key from a LiveMap. |
| `counterInc` | Increments or decrements a LiveCounter. |
| `mapCreate` | Creates a new LiveMap instance. |
| `counterCreate` | Creates a new LiveCounter instance. |

<Aside data-type='further-reading'>
For complete OpenAPI specifications, see the [LiveObjects OpenAPI spec](/docs/api/liveobjects-rest).
</Aside>

Each operation has specific required and optional fields:

**mapSet** <a id="mapset-spec"/>

<Code>
```json
{
  "path": "user",
  "mapSet": {
    "key": "username",
    "value": {"string": "alice"}
  }
}
```
</Code>

**mapRemove** <a id="mapremove-spec"/>

<Code>
```json
{
  "path": "user",
  "mapRemove": {
    "key": "username"
  }
}
```
</Code>

**counterInc** <a id="counterinc-spec"/>

<Code>
```json
{
  "path": "votes.up",
  "counterInc": {
    "number": 5
  }
}
```
</Code>

<Aside data-type='note'>
There is no explicit `counterDec` operation. To decrement a counter, use `counterInc` with a negative number.
</Aside>

**mapCreate** <a id="mapcreate-spec"/>

Optionally omit the `path` or `objectId` fields when creating an object with `mapCreate`.
For the object to be reachable in the state tree, assign it to a key in a LiveMap that is
reachable from the root.

<Code>
```json
{
  "path": "posts.post1",
  "mapCreate": {
    "semantics": 0,
    "entries": {
      "title": {"data": {"string": "LiveObjects is awesome"}},
      "createdAt": {"data": {"number": 1745835181122}},
      "isPublished": {"data": {"boolean": true}}
    }
  }
}
```
</Code>

**counterCreate** <a id="countercreate-spec"/>

Optionally omit the `path` or `objectId` fields when creating an object with `counterCreate`.
For the object to be reachable in the state tree, assign it to a key in a LiveMap that is
reachable from the root.

<Code>
```json
{
  "path": "visits",
  "counterCreate": {
    "count": 0
  }
}
```
</Code>

### Publishing an operation request <a id="issue-operation"/>

**Update a specific object by ID** <a id="updating-objects-by-id"/>

To perform operations on a specific object instance, provide its object ID in the request body:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '{
      "objectId": "counter:iVji62_MW_j4dShuJbr2fmsP2D8MyCs6tFqON9-xAkc@1745828645269",
      "counterInc": {
        "number": 1
      }
    }'
```
</Code>

The response includes the ID of the published operation message, the channel and a list of object IDs that were affected by the operation:

<Code>
```json
{
  "messageId": "TJPWHhMTrF:0",
  "channel": "my-channel",
  "objectIds": ["counter:iVji62_MW_j4dShuJbr2fmsP2D8MyCs6tFqON9-xAkc@1745828645269"]
}
```
</Code>

**Update an object by path** <a id="updating-objects-by-path"/>

Path operations target objects based on their location in the channel object.

Paths are expressed relative to the structure of the object as defined by the [compact](#fetching-object-get) view of the channel object.

The following example increments the `LiveCounter` instance stored at the `up` key on the `votes` `LiveMap` object:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '{
      "path": "votes.up",
      "counterInc": {
        "number": 1
      }
    }'
```
</Code>

## Creating objects <a id="creating-objects"/>

Use `mapCreate` and `counterCreate` operations to create new LiveObjects instances.

### Creating objects with paths <a id="creating-with-path"/>

The simplest way to create an object is to specify a `path` where it should be created. The server automatically creates the object and assigns it to that path in a single atomic operation.

The following example creates a new `LiveMap` instance and assigns it to the `posts` `LiveMap` instance on the root object under the key `post1`:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '{
      "path": "posts.post1",
      "mapCreate": {
        "semantics": 0,
        "entries": {
          "title": {"data": {"string": "LiveObjects is awesome"}},
          "createdAt": {"data": {"number": 1745835181122}},
          "isPublished": {"data": {"boolean": true}}
        }
      }
    }'
```
</Code>

When using `path` with a create operation, the server constructs two operations published as a [batch](#batch-operations):

1. A `mapCreate` or `counterCreate` operation to create the new object
2. A `mapSet` operation to assign the new object to the parent LiveMap at the specified path

This ensures the new object is immediately [reachable](#object-reachability) from the root.

The response will include the object IDs of all objects affected by the resulting set of operations:

<Code>
```json
{
  "messageId": "mkfjWU2jju:0",
  "channel": "my-channel",
  "objectIds": [
    "map:cRCKx-eev7Tl66jGfl1SkZh_uEMo6F5jyV0B7mUn4Zs@1745835549101",
    "map:a_oQqPYUGxi95_Cn0pWcsoeBlHZZtVW5xKIw0hnJCZs@1745835547258"
  ]
}
```
</Code>

### Creating standalone objects <a id="creating-standalone"/>

You can create objects without immediately assigning them by omitting both `objectId` and `path` from the create operation.

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '{
      "mapCreate": {
        "semantics": 0,
        "entries": {
          "name": {"data": {"string": "Alice"}}
        }
      }
    }'
```
</Code>

The response includes the generated object ID:

<Code>
```json
{
  "messageId": "TJPWHhMTrF:0",
  "channel": "my-channel",
  "objectIds": ["map:abc123def456...@1745835549101"]
}
```
</Code>

<Aside data-type='important'>
Standalone objects are not reachable until assigned to the object tree. Unreachable objects are eligible for garbage collection. See [Object reachability and garbage collection](#object-reachability) for details.
</Aside>

## Advanced path operations <a id="advanced-path-operations"/>

### Path wildcards <a id="path-wildcards"/>

Use wildcards in paths to target multiple objects at once. To increment all `LiveCounter` instances in the `votes` `LiveMap` instance:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '{
      "path": "votes.*",
      "counterInc": {
        "number": 1
      }
    }'
```
</Code>

The response includes the IDs of each of the affected object instances:

<Code>
```json
{
  "messageId": "0Q1w-LpA11:0",
  "channel": "my-channel",
  "objectIds": [
    "counter:iVji62_MW_j4dShuJbr2fmsP2D8MyCs6tFqON9-xAkc@1745828645269",
    "counter:JbZYiHnw0ORAyzzLSQahVik31iBDL_ehJNpTEF3qwg8@1745828651669"
  ]
}
```
</Code>

Wildcards match exactly one level in the channel object and can appear at the end or middle of paths. For example, given the following compact view of the channel object:

<Code>
```json
{
  "posts": {
    "post1": {
      "votes": {
        "up": 5,
        "down": 10
      }
    },
    "post2": {
      "votes": {
        "up": 5,
        "down": 10
      }
    }
  }
}
```
</Code>

The following example increments the upvote `LiveCounter` instances for all posts in the `posts` `LiveMap` instance:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '{
      "path": "posts.*.votes.up",
      "counterInc": {
        "number": 1
      }
    }'
```
</Code>

### Escaping special characters <a id="path-escaping"/>

If your `LiveMap` keys contain periods, you can escape them with a backslash. The following example increments the upvote `LiveCounter` instance for a post with the key `post.123`:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '{
      "path": "posts.post\.123.votes.up",
      "counterInc": {
        "number": 1
      }
    }'
```
</Code>

## Get objects with metadata <a id="get-object-metadata"/>

By default, the REST API returns objects in **compact format**, which shows the logical structure of your data without metadata. This format is ideal for most use cases.

You can request the **non-compact format** by adding `compact=false` to your request. This returns the full object structure including:
- Object IDs for each instance
- Object type metadata (map semantics, counter values)
- Complete object hierarchy

**When to use each format:**

| Format | When to use |
|--------|------------|
| **Compact** (default) | Reading data values, understanding logical structure |
| **Non-compact** | Inspecting object IDs, debugging, understanding metadata |

### Get the root object with metadata <a id="fetching-object"/>

You can optionally include additional object [metadata](/docs/liveobjects/concepts/objects#metadata) in the response by specifying the `compact=false` query option:

<Code>
  ```shell
  curl "https://main.realtime.ably.net/channels/my-channel/object?compact=false" \
  -u {{API_KEY}}
  ```
</Code>

<Code>
  ```json
  {
    "objectId": "root",
    "map": {
      "semantics": "LWW",
      "entries": {
        "votes": {
          "data": {
            "objectId": "map:qZXBk8xaGqf4kwLSlR7Tj0Eqhd48WDFfb3gTAbj194k@1760448597692",
            "map": {
              "semantics": "LWW",
              "entries": {
                "down": {
                  "data": {
                    "objectId": "counter:Yj1F_aEX3T2rRkTkra7Aifmlr8PxUWSR3kO3MzxtQto@1760448653393",
                    "counter": {
                      "data": {
                        "number": 5
                      }
                    }
                  }
                },
                "up": {
                  "data": {
                    "objectId": "counter:ibxddWpDjH8R3cvXWWacfe4IVd3DxT_oqkAafhaS68s@1760448646413",
                    "counter": {
                      "data": {
                        "number": 10
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
}

  ```
</Code>

### Get an object by ID with metadata <a id="metadata-object-get-by-id"/>

To fetch a specific instance of an object type on the channel you can specify the object ID in the URL path:

<Code>
```shell
  curl "https://main.realtime.ably.net/channels/my-channel/object/map:qZXBk8xaGqf4kwLSlR7Tj0Eqhd48WDFfb3gTAbj194k@1760448597692" \
    -u {{API_KEY}}
```
</Code>

This endpoint supports the `path` and `compact` query options. Note that the path is evaluated relative to the specified object instance.

<Code>
```json
{
  "down": 5,
  "up": 10
}
```
</Code>

The full object response can be retrieved by providing the `compact=false` query parameter:

<Code>
  ```shell
  curl "https://main.realtime.ably.net/channels/my-channel/object/map:qZXBk8xaGqf4kwLSlR7Tj0Eqhd48WDFfb3gTAbj194k@1760448597692?compact=false" \
  -u {{API_KEY}}
  ```
</Code>

<Code>
  ```json
  {
    "objectId": "map:qZXBk8xaGqf4kwLSlR7Tj0Eqhd48WDFfb3gTAbj194k@1760448597692",
    "map": {
      "semantics": "LWW",
      "entries": {
        "down": {
          "data": {
            "objectId": "counter:Yj1F_aEX3T2rRkTkra7Aifmlr8PxUWSR3kO3MzxtQto@1760448653393",
            "counter": {
              "data": {
                "number": 5
              }
            }
          }
        },
        "up": {
          "data": {
            "objectId": "counter:ibxddWpDjH8R3cvXWWacfe4IVd3DxT_oqkAafhaS68s@1760448646413",
            "counter": {
              "data": {
                "number": 10
              }
            }
          }
        }
      }
    }
  }
  ```
</Code>

The `path` parameter can also be provided here to return a subset of the channel object starting from the specified object ID:

<Code>
  ```shell
  curl "https://main.realtime.ably.net/channels/my-channel/object/map:qZXBk8xaGqf4kwLSlR7Tj0Eqhd48WDFfb3gTAbj194k@1760448597692?path=votes" \
  -u {{API_KEY}}
  ```
</Code>

<Code>
```json
{
  "down": 5,
  "up": 10
}
```
</Code>

## Cyclic references <a id="fetching-objects-get-cycles"/>

For both the full object and the compact response formats, cyclic references in the channel object are included as a
reference to the object ID rather than including the same object instance in the response more than once.

For example, if you create a cycle in the channel object by adding a reference to the root object in the `votes` `LiveMap` instance with the following operation:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '{
      "objectId": "map:qZXBk8xaGqf4kwLSlR7Tj0Eqhd48WDFfb3gTAbj194k@1760448597692",
      "mapSet": {
        "key": "myRoot",
        "value": {"objectId": "root"}
      }
    }'
```
</Code>

The response will handle the cyclic reference by including the `myRoot` key in the response as a reference to the object ID of the root object:

<Code>
```shell
  curl "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}}
```
</Code>

<Code>
  ```json
  {
    "votes": {
      "down": 5,
      "up": 10,
      "myRoot": {
        "objectId": "root"
      }
    }
  }
  ```
</Code>

## Object reachability and garbage collection <a id="object-reachability"/>

Objects must be reachable from the root object to persist. Unreachable objects are automatically removed by garbage collection. Learn more about [reachability and object lifecycle](/docs/liveobjects/concepts/objects#reachability).

### Removing objects <a id="removing-objects"/>

Remove an object from the channel using `mapRemove` to delete the key referencing it:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '{
      "objectId": "root",
      "mapRemove": {
        "key": "posts"
      }
    }'
```
</Code>

If no other references to the object exist, it becomes unreachable and is eligible for garbage collection.

<Aside data-type='note'>
Removing a key may also make nested child objects unreachable. These objects are also eligible for garbage collection.
</Aside>

**Example lifecycle:**

<Code>
```shell
# 1. Create a map and assign it to "user"
curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
  -u {{API_KEY}} \
  -H "Content-Type: application/json" \
  -d '{
    "path": "user",
    "mapCreate": {
      "semantics": 0,
      "entries": {"name": {"data": {"string": "Alice"}}}
    }
  }'
# Object is now REACHABLE at path "user"

# 2. Remove the "user" key from root
curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
  -u {{API_KEY}} \
  -H "Content-Type: application/json" \
  -d '{
    "path": "",
    "mapRemove": {"key": "user"}
  }'
# Object is now UNREACHABLE and eligible for garbage collection

# 3. After garbage collection runs, the object is permanently deleted
```
</Code>

<Aside data-type='important'>
Garbage collection is permanent. Once collected, objects cannot be recovered.
</Aside>

## Batch operations <a id="batch-operations"/>

Group multiple operations into a single request by sending an array of operations. All operations are published as a single message and processed as a single atomic unit. Learn more about [batch operations](/docs/liveobjects/batch).

The following example increments two distinct `LiveCounter` instances in a single batch operation:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '[
      {
        "objectId": "counter:iVji62_MW_j4dShuJbr2fmsP2D8MyCs6tFqON9-xAkc@1745828645269",
        "counterInc": {
          "number": 1
        }
      },
      {
        "objectId": "counter:JbZYiHnw0ORAyzzLSQahVik31iBDL_ehJNpTEF3qwg8@1745828651669",
        "counterInc": {
          "number": 1
        }
      }
    ]'
```
</Code>

## Idempotent operations <a id="idempotent-operations"/>

Publish operations idempotently by specifying an `id` for the operation message, using the same approach as [idempotent message publishing](/docs/api/rest-api#idempotent-publish):

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '{
      "id": "my-idempotency-key",
      "objectId": "counter:iVji62_MW_j4dShuJbr2fmsP2D8MyCs6tFqON9-xAkc@1745828645269",
      "counterInc": {
        "number": 1
      }
    }'
```
</Code>

For batch operations, use the format `<baseId>:<index>` where the index is the zero-based index of the operation in the array:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '[
      {
        "id": "my-idempotency-key:0",
        "objectId": "counter:iVji62_MW_j4dShuJbr2fmsP2D8MyCs6tFqON9-xAkc@1745828645269",
        "counterInc": {
          "number": 1
        }
      },
      {
        "id": "my-idempotency-key:1",
        "objectId": "counter:JbZYiHnw0ORAyzzLSQahVik31iBDL_ehJNpTEF3qwg8@1745828651669",
        "counterInc": {
          "number": 1
        }
      }
    ]'
```
</Code>

## Advanced: Client-generated object IDs <a id="client-generated-ids"/>

Generate object IDs when creating objects to enable atomic batch operations with cross-references between newly created objects. This is useful when creating multiple objects that reference each other in a single batch.

Object IDs are generated by hashing the operation type, the JSON-encoded initial value, and a random nonce. Format: `{type}:{hash}@{timestamp}`

There are additional operations for creating objects with client-generated IDs:
- `mapCreateWithObjectId`
- `counterCreateWithObjectId`

**mapCreateWithObjectId**

- `objectId` (string): The pre-computed object ID for the new map
- `initialValue` (string): JSON-encoded string of the map data, matching the format from
  `mapCreate`.
- `nonce` (string): Random string you generated

<Code>
```json
{
  "objectId": "map:abc123@ts1",
  "mapCreateWithObjectId": {
    "initialValue": "{\"entries\":{\"name\":{\"data\":{\"string\":\"Alice\"}},\"age\":{\"data\":{\"number\":30}}}}",
    "nonce": "random-nonce-abc123"
  }
}
```
</Code>

**counterCreateWithObjectId**

- `objectId` (string): The pre-computed object ID for the new counter
- `initialValue` (string): JSON-encoded string of the counter data, matching the format from
  `counterCreate`.
- `nonce` (string): Random string you generated

<Code>
```json
{
  "objectId": "counter:xyz789@ts1",
  "counterCreateWithObjectId": {
    "initialValue": "{\"count\":0}",
    "nonce": "nonce-xyz789"
  }
}
```
</Code>

<Aside data-type='important'>
The server validates that your `objectId` matches the hash of `initialValue + nonce`.
</Aside>

### Creating objects with client-generated IDs <a id="creating-with-client-ids"/>

Publish an operation using either `mapCreateWithObjectId` or `counterCreateWithObjectId` to create
an object with a client-generated ID.

For example:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '{
      "objectId": "map:abc123@ts1",
      "mapCreateWithObjectId": {
        "initialValue": "{\"entries\":{\"name\":{\"data\":{\"string\":\"Alice\"}},\"age\":{\"data\":{\"number\":30}}}}",
        "nonce": "random-nonce-abc123"
      }
    }'
```
</Code>

### Atomic batch with cross-references <a id="atomic-batch-cross-references"/>

Create a map and immediately link it to root in a single atomic operation:

<Code>
```shell
  curl -X POST "https://main.realtime.ably.net/channels/my-channel/object" \
    -u {{API_KEY}} \
    -H "Content-Type: application/json" \
    -d '[
      {
        "objectId": "map:abc123@ts1",
        "mapCreateWithObjectId": {
          "initialValue": "{\"entries\":{\"name\":{\"data\":{\"string\":\"Alice\"}}}}",
          "nonce": "nonce-1"
        }
      },
      {
        "objectId": "root",
        "mapSet": {
          "key": "alice",
          "value": {"objectId": "map:abc123@ts1"}
        }
      }
    ]'
```
</Code>

Both operations execute atomically. The second operation references the object created in the first because you pre-computed the ID.

<Aside data-type='note'>
Only use client-generated IDs when you need atomic batch operations with cross-references. For most use cases, use simple operations or path-based operations instead.
</Aside>

## Data values reference <a id="data-values"/>

When working with objects via the REST API, [primitive types](/docs/liveobjects/concepts/objects#primitive-types) and [object references](/docs/liveobjects/concepts/objects#composability) are included in request and response bodies under `data` fields.

The key in the `data` object indicates the type of the value. Examples of data value formats:

<Code>
```json
{ "data": { "number": 42 } }
{ "data": { "string": "LiveObjects is awesome" } }
{ "data": { "boolean": true } }
{ "data": { "bytes": "TGl2ZU9iamVjdHMgaXMgYXdlc29tZQo=" } }
{ "data": { "objectId": "counter:JbZYiHnw0ORAyzzLSQahVik31iBDL_ehJNpTEF3qwg8@1745828651669" } }
```
</Code>

<Aside data-type='note'>
`bytes` values use base64 string encoding in JSON request and response bodies.
</Aside>
