---
title: "Guide: Integrate external systems with Ably Chat"
meta_description: "Extend Ably Chat with external integrations: process messages with AI, webhooks, and custom logic at scale."
meta_keywords: "chat integrations, external systems, webhooks, AI chat, message processing, chat automation, integration rules, message routing"
---

Ably Chat is designed for extensibility. Whether you need to process messages with AI, translate content in real-time, trigger business workflows, or enrich messages with external data, Ably's integration capabilities enable you to extend your chat application without compromising on scale, reliability, or performance.

This guide explains how to architect integrations that process chat messages through external systems and respond back to the chat in real-time. Before diving into the technical implementation, it's important to understand your architectural goals and the role your external system will play.

## Why integrate external systems?

Integrating external systems with Ably Chat enables you to extend your chat application beyond simple message delivery. Common integration use cases include:

* **AI-powered assistants:** Process commands or questions through language models and respond with helpful information.
* **Real-time translation:** Automatically translate messages for multilingual chat rooms.
* **Notifications:** Detect and process mentions, or other notifications.
* **Analytics and monitoring:** Analyze sentiment, track engagement metrics, or identify trending topics.
* **Workflow automation:** Trigger external business processes based on chat activity.
* **Command processing:** Handle slash commands that invoke server-side logic.

Unlike [chat moderation](/docs/chat/moderation), which filters or blocks content before or after publication, integrations focus on processing messages and responding with new content or triggering external actions. Also unlike [exporting chat data](/docs/guides/chat/export-chat), which stores all messages for long-term retention, integrations process specific messages matched by integration rules.

## Why Ably for external integrations?

Ably Chat integrations are built on Ably's proven platform architecture, designed to handle integration workloads at any scale:

* **Reliable message delivery:** Every integration benefits from Ably's [four pillars of dependability](/docs/platform/architecture): Performance, Integrity, Reliability, and Availability.
* **Flexible routing:** Use channel filters to selectively route only the messages on channels that need processing to your integration.
* **Multiple integration methods:** Choose webhooks, queues, or streaming based on your architecture and scale requirements.
* **Proven at scale:** Ably processes over 500 million messages per day for customers, with [serverless scalability](/docs/platform/architecture/platform-scalability) that eliminates infrastructure management.
* **No vendor lock-in:** Integrate with any external service, using any language or platform that can handle HTTP requests or consume from queues.

Because Ably Chat rooms use Pub/Sub channels as their underlying transport, you can leverage all of Ably's [platform integrations](/docs/platform/integrations) to extend your chat application.

## Key considerations <a id="key-considerations"/>

Consider the following when integrating external systems with Ably Chat:

* **Avoiding infinite loops:** When your integration responds back to chat, ensure responses don't trigger the same integration rule. Use separate channels or the [privileged skip integration flag](/docs/platform/integrations/skip-integrations) to break potential loops.
* **Scale and reliability:** Different integration methods offer different reliability guarantees. Webhooks are simpler to implement but have limited retry windows, queues provide at-least-once delivery with dead letter queues, and streaming offers massive scale but requires more infrastructure management.
* **External system limitations:** Your external service may have rate limits, processing constraints, or availability issues. Implement retry logic, circuit breakers, and caching to handle these limitations gracefully.
* **Cost optimization:** Only process messages that require processing. Use channel filters to ensure you only receive messages from relevant chat rooms.

## Implementation options <a id="implementation-options"/>

With your strategy in mind, choose the technical approach that fits your needs:

1. Using [outbound webhooks](#webhook). [HTTP endpoint](/docs/platform/integrations/webhooks/generic), [AWS Lambda](/docs/platform/integrations/webhooks/lambda), and others.
2. Using [Ably queues](#ably-queue).
3. Using [outbound streaming](#outbound-streaming). Stream to your own [Kafka](/docs/platform/integrations/streaming/kafka), [Kinesis](/docs/platform/integrations/streaming/kinesis), and others.

## Understanding integrations

Ably Chat rooms are built on Ably Pub/Sub channels, which means you can leverage Ably's integration capabilities to forward messages to external systems for processing:

* **Chat rooms use Pub/Sub channels:** Each chat room is built on an Ably channel, enabling the full range of Ably's integration capabilities.
* **Message structure:** Chat messages are encoded as Pub/Sub messages with a specific structure. See the [Chat integrations documentation](/docs/chat/integrations) for details on the mapping.
* **Integration rules:** Configure rules that filter which messages trigger integrations based on channel name patterns and event types.
* **Bidirectional flow:** Integrations allow you to export messages to external systems, process them, and respond back to chat rooms in real-time.

### Integration flow

The typical integration flow works as follows:

1. A user sends a message to a chat room, optionally including headers or metadata to control processing externally.
2. An integration rule evaluates the message based on room name pattern matching.
3. If the rule matches, Ably forwards the message to your external system via the configured integration method.
4. Your external system processes the message (AI inference, translation, business logic, etc.).
5. The external system sends a response back to an Ably Chat room.
6. All subscribed clients receive the response in real-time.

[/TODO/]: # (Add a visual showing somethign like *Client → Ably Chat → Integration Rule → External System → Response → Ably Chat → Clients*)

## Filtering rooms and event types <a id="filtering"/>

Integrations allow you to filter which Chat rooms are forwarded to your external system using a regular expression on the room name.
This is a simple way to reduce the volume of messages you need to process by only receiving messages from the chat rooms you are interested in.

### Setting up integration rules

When configuring an integration rule in your Ably dashboard:

* **Channel filter:** Use a regular expression to match channel names. For example, `^chat:support.*` will match all channels starting with `chat:support`. See [understanding channel names and room names](#understanding-channel-names-and-room-names) for details on how room names map to channel names.
* **Event type:** Use `channel.message` for all integration types. This forwards all chat messages published to relevant rooms and excludes presence messages and channel lifecycle messages
* **Enveloped messages:** Enable this to receive all metadata about the message, including the `serial`, `version`, and `extras` (which include the [`headers`](/docs/chat/rooms/messages#structure) of a chat message)

### Understanding channel names and room names

Chat rooms are underpinned by Ably Pub/Sub channels, but with a specific suffix (`::$chat`) added to form the full channel name.
When using the Chat SDK to create or get a room, this is done automatically for you, you do not need to include the suffix yourself.

Integration rules match against the full channel name, but you don't need to include the `::$chat` suffix in your filter pattern.

**Example room and channel naming:**

<Code>
```javascript
// Get a chat room - the room name becomes the channel name with ::$chat suffix
const supportRoom = await chatClient.rooms.get('chat:support');
// Underlying channel: chat:support::$chat

const groupRoom = await chatClient.rooms.get('chat:group:123');
// Underlying channel: chat:group:123::$chat

// Messages sent to these rooms will trigger an integration
// if your rule's channel filter is: ^chat:support.*
await supportRoom.messages.send({ text: 'Need help' });

// Messages sent to other channel patterns will NOT trigger the integration
const generalRoom = await chatClient.rooms.get('chat:general');
await generalRoom.messages.send({ text: 'Hi' }); // Won't trigger if filter is ^chat:support.*
```
</Code>

## Decoding and processing messages <a id="decoding-and-processing"/>

When your integration receives messages, you need to decode them and extract the relevant information.

### Understanding enveloped messages

With enveloping enabled (the default), Ably wraps messages in additional metadata like so:

<Code>
```javascript
{
  "source": "channel.message",
  "appId": "your-app-id",
  "channel": "chat:support::$chat",
  "site": "eu-west-1-A",
  "ruleId": "integration-rule-id",
  "messages": [
    {
      "id": "oWSRIqvv2d:0:0",
      "clientId": "some-client-id",
      "name": "chat.message",
      "timestamp": 1234567890,
      "serial": "01765820788939-000@108wgxjJwBwuAB37648671:000",
      "action": 0,
      "data": {
        "text": "Message content",
        "metadata": {}
      },
      "extras": {
        "headers": {
          "x-integration-action": "weather"
        }
      }
    }
  ]
}
```
</Code>

### Extracting the room name

Your integration receives the full channel name including the `::$chat` suffix. To send responses back to the same room, extract the room name by removing the suffix:

<Code>
```javascript
// In your webhook handler or queue consumer
function processIntegrationPayload(envelopeData) {
  // Extract room name from channel name
  const channelName = envelopeData.channel; // e.g., "chat:support::$chat"
  const roomName = channelName.replace('::$chat', ''); // e.g., "chat:support"
}
```
</Code>

### Extracting message data

The Ably SDK provides methods to decode messages from the enveloped payload.
From there, you can extract the text content, headers, and metadata and process them as needed.
You can use custom headers to control how messages are processed by your integration. For example, you might define an `x-integration-action` header to specify different processing actions:

<Code>
```javascript
const Ably = require('ably');

async function processIntegrationPayload(envelopeData) {
  // Decode messages using Ably SDK
  const decodedMessages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of decodedMessages) {
    // Extract text content
    const text = msg.data?.text;

    // Extract headers if needed
    const headers = msg.extras?.headers || {};
    const action = headers['x-integration-action'];

    // Extract metadata if needed
    const metadata = msg.data?.metadata || {};

    // Process each message based on action
    await processServiceRequest(roomName, text, action);
  }
}

async function processServiceRequest(roomName, text, action) {
    switch (action) {
      case 'weather':
        await handleWeatherRequest(text, roomName);
        break;

      case 'translate':
        await handleTranslationRequest(text, roomName);
        break;

      case 'ai-assist':
        await handleAIAssistantRequest(text, roomName);
        break;

      default:
        // Ignore messages without integration actions
        break;
    }
}
```
</Code>

## Using a webhook <a id="webhook"/>

Ably can forward messages to your external system via a webhook. This is the simplest integration method to set up and works well for most use cases. This section covers HTTP endpoint webhooks, but the same principles apply to other webhook integrations such as AWS Lambda, Azure Function, Google Cloud Function, and others.

Read the guide on [outbound webhooks](/docs/platform/integrations/webhooks) for more details on how to set up a webhook with Ably for the platform of your choice.

Benefits:
- Simplest integration method to implement and get started quickly.
- Automatic retry handling with configurable retry windows.
- No additional infrastructure required beyond your webhook endpoint or function.

You need to consider:
- Ably retries failed webhook deliveries, but only for a limited retry window. Monitor the [`[meta]log` channel](/docs/platform/errors#meta) for delivery failures.
- Messages can arrive out-of-order. Use `serial` and `version.serial` properties to order them correctly if needed.
- Failed webhook calls that exceed the retry window will lead to message loss. Implement monitoring and alerting to detect failures early.
- [At-least-once delivery](/docs/platform/architecture/idempotency#protocol-support-for-exactly-once-delivery) means you need to handle duplicate messages. Deduplication can be done by tracking `serial` and `version.serial`.

## Using an Ably queue <a id="ably-queue"/>

Ably can forward messages from chat room channels to an [Ably Queue](/docs/platform/integrations/queues), which you can then consume from your own servers to process messages through your external system and respond back to chat. Read the guide on [Ably queues](/docs/platform/integrations/queues) for more details on how to set up the queue integration with Ably.

Ably ensures that each message is delivered to only one consumer even if multiple consumers are connected.

Benefits of using an Ably queue:
- You can consume it from your servers, meaning overall this is fault-tolerant. Ably takes care of the complexity of maintaining a queue.
- You can use multiple queues and configure which channels go to which queue via regex filters on the channel name.
- Fault-tolerant: if your systems suffer any temporary downtime, you will not miss messages, up to the queue max size. There is a dead letter queue to handle the situation where messages are dropped from the Ably Queue.

You need to consider:
- During peak times you may need to scale up your consumers to avoid overloading the queue past the maximum queue length allowed.
- Each message has a time-to-live in the queue. The default and maximum is 60 minutes.
- Oldest messages are dropped if the maximum queue length is exceeded. Check the [dead letter queue](/docs/platform/integrations/queues#deadletter) to see if this is happening.
- Always consume messages from the [dead letter queue](/docs/platform/integrations/queues#deadletter) to monitor errors.

## Using outbound streaming <a id="outbound-streaming"/>

Ably can stream messages directly to your own queueing or streaming service: Kafka, Kinesis, AMQP, SQS, Pulsar. Read the guide on [outbound streaming](/docs/platform/integrations/streaming) for more details on how to set up the streaming integration with Ably for the service of your choice.

Benefits:
- Use your existing queue system to process messages from Ably.
- You control your own queue system, so you have full control over message ingestion in terms of retry strategies, retention policies, queue lengths, and so on.

You need to consider:
- You need to maintain and be responsible for a reliable streaming system. If you don't already have such a system, it increases complexity on your end.
- Consistency. If your streaming system is not reachable, messages may be lost. Errors can be seen in the [`[meta]log` channel](/docs/platform/errors#meta).

## Responding back to chat <a id="responding"/>

After processing messages through your external system, you will typically want to publish responses back to the chat room. This could be answers from an AI assistant, translated text, enriched content, or status updates.
To avoid triggering the integration rule on the response message, use Ably's [skip integrations](/docs/platform/integrations/skip-integrations) feature to publish messages that bypass integration rules.

**Note:** Your API key or token must have the [`privileged-headers`](/docs/auth/capabilities#capability-operations) capability to apply the skip integration flag.

<Code>
```javascript
async function sendResponseToChat(channelName, responseText) {
  // Extract the room name from the channel name
  const roomName = channelName.replace('::$chat', ''); // e.g., "chat:support"
  const room = await chatClient.rooms.get(roomName);

  // Send response message skipping some or all integration rules
  await room.messages.send({
    text: responseText
  }, {
    extras: {
      privileged: {
        skipRule: '*' // Skip all integration rules
      }
    }
  });
}
```
</Code>

The rule ID is available in the integration webhook envelope's `ruleId` field, or you can find it in your Ably [dashboard](https://ably.com/dashboard) under Integrations.

## Next steps

Explore related documentation to deepen your integration knowledge:

* [Chat SDK documentation](/docs/chat) - Comprehensive guide to Ably Chat features
* [Platform Integrations](/docs/platform/integrations) - Detailed setup for webhooks, queues, and streaming
* [Chat Integrations](/docs/chat/integrations) - Technical reference for Chat message structure
* [Export Chat Data](/docs/guides/chat/export-chat) - Guide for storing all chat messages long-term
* [Architecture Overview](/docs/platform/architecture) - Learn how Ably achieves scale and reliability
* [Authentication](/docs/auth) - Security best practices for production apps
* [Chat Moderation](/docs/chat/moderation) - Filter and moderate chat content

For custom integration requirements or questions, [contact Ably support](https://ably.com/support).
