---
title: Presence
section: rest
index: 40
jump_to:
  Help with:
    - Presence
    - Member data
    - Presence member list#member-list
    - Presence history
  Presence API reference:
    - get
    - history
---

Presence enables clients to be aware of other clients that are currently "present" on a channel. Each member present on a channel has a unique self-assigned client identifier and system-assigned connection identifier, along with an optional payload that can be used to describe the member's status or attributes. Presence allows you to quickly build apps such as chat rooms and multiplayer games by automatically keeping track of who is present in real time across any device.

h2(#presence). Presence

Using the "Ably REST API":/rest-api it is possible to obtain the set of members currently present on a channel, or obtain the presence history for the channel, if persistence is enabled for that channel.

Since the "Ably REST API":/rest-api is stateless, and REST clients do not have realtime connections to the Ably service, it is not possible to enter or leave a channel via the REST API. Find out more about "using presence with the Realtime API":/realtime/presence.

A single <span lang="default">"@clientId@":/rest/usage#client-id</span><span lang="ruby,python">"@client_id@":/rest/usage#client-id</span><span lang="csharp">"@ClientId@":/rest/usage#client-id</span> may be present multiple times on the same channel via different client connections. As far as Ably is concerned, these are different members of the presence set for the channel, however they will be differentiated by their unique "<span lang="default">@connectionId@</span><span lang="csharp">@ConnectionId@</span><span lang="ruby">@connection_id@</span>":/realtime/connection/#id. For example, if a client with ID "Sarah" is connected to a chat channel on both a desktop and a mobile device simultaneously, "Sarah" will be present twice in the presence member set with the same client ID, yet will have two unique connection IDs. A member of the presence set is therefore unique by the combination of the <span lang="default">"@clientId@":/rest/usage#client-id</span><span lang="ruby,python">"@client_id@":/rest/usage#client-id</span><span lang="csharp">"@ClientId@":/rest/usage#client-id</span> and "<span lang="default">@connectionId@</span><span lang="csharp">@ConnectionId@</span><span lang="ruby">@connection_id@</span>":/realtime/connection/#id strings.

h3(#presence-states). Presence states and events

<%= partial 'shared/_presence_states' %>

"View a realtime presence states and events example":<%= JsBins.url_for('realtime/presence-events') %>

h3(#member-data). Member data

In addition to the <span lang="default">"@clientId@":/rest/usage#client-id</span><span lang="ruby,python">"@client_id@":/rest/usage#client-id</span><span lang="csharp">"@ClientId@":/rest/usage#client-id</span> for members on a channel, it is also possible to include data when entering a channel. Clients can "update":/realtime/presence#update their data at any point which will be broadcasted to all presence subscribers as a <span lang="ruby">@:update@</span><span lang="java">@PresenceAction.UPDATE@</span><span lang="csharp">@PresenceAction.Update@</span><span lang="java">@Action.UPDATE@</span><span lang="default">@update@</span> event.

See the "Realtime Presence Member data documentation":/realtime/presence#member-data for more info.

h3(#member-list). Presence member list

The @Presence@ object exposes a "<span lang="default">@get@</span><span lang="csharp">@Get@</span>":#get method allowing a client to retrieve an array of all members currently present on the channel. In the REST client library this method directly queries "Ably's REST presence API":/rest-api#presence. No presence state is cached in the library itself, unlike in the "Realtime client library":/realtime.

```[jsall]
channel.presence.get(function(err, membersPage) {
  console.log(membersPage.items.length + ' presence members in first page');
  if(membersPage.hasNext()) {
    membersPage.next(function(err, nextPage) { ... });
  }
});
```

```[ruby]
members_page = channel.presence.get
puts "#{members_page.items.length} presence members in first page"
if members_page.has_next?
  next_page = members_page.next
end
```

```[python]
members_page = channel.presence.get()
print str(len(members_page.items)) + ' members present'
if members_page.has_next():
  next_page = members_page.next()
```

```[php]
$membersPage = $channel->presence->get();
echo(count($membersPage->items) . ' presence members in first page');
if ($membersPage->hasNext()) {
  $nextPage = $membersPage.next();
}
```

```[java]
PaginatedResult<PresenceMessage> membersPage = channel.presence.get(null);
System.out.println(membersPage.items().length + " members in first page");
if(membersPage.hasNext()) {
  PaginatedResult<PresenceMessage> nextPage = membersPage.next();
  System.out.println(nextPage.items().length + " members on 2nd page");
}
```

```[csharp]
  PaginatedResult<PresenceMessage> membersPage = await channel.Presence.GetAsync();
  Console.WriteLine(membersPage.Items.Count + " members in first page");
  if(membersPage.HasNext)
  {
    PaginatedResult<PresenceMessage> nextPage = await membersPage.NextAsync();
    Console.WriteLine(nextPage.Items.Count + " members on 2nd page");
  }
```

```[objc]
[channel.presence get:^(ARTPaginatedResult<ARTPresenceMessage *> *membersPage, ARTErrorInfo *error) {
  NSLog(@"%lu members in first page", [membersPage.items count]);
  if (membersPage.hasNext) {
    [membersPage next:^(ARTPaginatedResult<ARTPresenceMessage *> *nextPage, ARTErrorInfo *error) {
      NSLog(@"%lu members on 2nd page", [nextPage.items count]);
    }];
  }
}];
```

```[swift]
channel.presence.get { membersPage, error in
  let membersPage = membersPage!
  print("\(membersPage.items.count) in first page")
  if membersPage.hasNext {
    membersPage.next { nextPage, error in
      print("\(nextPage!.items.count) members on 2nd page")
    }
  }
}
```

h3(#presence-history). Presence History

The @Presence@ object exposes a "<span lang="default">@history@</span><span lang="csharp">@History@</span>":#history method allowing a client to retrieve historical presence events on the channel.

History provides access to instantaneous "live" history as well as the longer term persisted history for presence channels. If "persisted history":/realtime/history#persisted-history is enabled for the channel, then presence events will "typically be stored for 24 - 72 hours":https://support.ably.io/solution/articles/3000030059-how-long-are-messages-stored-for. If persisted history is not enabled, Ably retains the last two minutes of presence event history in memory.

The following example retrieves the first two pages of historical presence events published.

bc[jsall]. var presence = channel.presence;
presence.history(function(err, eventsPage) {
  if(err) {
    console.log('Unable to get presence history; err = ' + err.message);
  } else {
    console.log(eventsPage.items.length + ' presence events received in first page');
    if(eventsPage.hasNext()) {
      eventsPage.next(function(err, nextPage) { ... });
    }
});

bc[ruby]. events_page = channel.presence.history
puts "#{events_page.items.length} presence events received in first page"
if events_page.has_next?
  next_page = events_page.next
  puts "#{next_page.items.length} presence events received on second page"
end

bc[php]. $eventsPage = $channel->presence->history();
echo(count($eventsPage->items) . ' presence events received in first page');
if ($eventsPage.hasNext()) {
  $nextPage = $eventsPage->next();
  echo(count($nextPage->items) . ' presence events received in second page');
}

```[python]
events_page = channel.presence.history()
print str(len(events_page.items)) + " presence events received"
if events_page.has_next():
  next_page = events_page.next()
```

```[java]
PaginatedResult<PresenceMessage> eventsPage = channel.presence.history(null);
System.out.println(eventsPage.items().length + " presence events received in first page");
if(eventsPage.hasNext()) {
  PaginatedResult<PresenceMessage> nextPage = eventsPage.next();
  System.out.println(nextPage.items().length + " presence events received in 2nd page");
}
```

```[csharp]
  PaginatedResult<PresenceMessage> eventsPage = await channel.Presence.HistoryAsync();
  Console.WriteLine(eventsPage.Items.Count + " presence events received in first page");
  if (eventsPage.HasNext)
  {
    PaginatedResult<PresenceMessage> nextPage = await eventsPage.NextAsync();
    Console.WriteLine(nextPage.Items.Count + " presence events received in 2nd page");
  }
```

```[objc]
[channel.presence history:^(ARTPaginatedResult<ARTPresenceMessage *> *eventsPage, ARTErrorInfo *error) {
  NSLog(@"%lu presence events received in first page", [eventsPage.items count]);
  if (eventsPage.hasNext) {
    [eventsPage next:^(ARTPaginatedResult<ARTPresenceMessage *> *nextPage, ARTErrorInfo *error) {
      NSLog(@"%lu presence events received in 2nd page", [nextPage.items count]);
    }];
  }
}];
```

```[swift]
channel.presence.history { eventsPage, error in
  let eventsPage = eventsPage!
  print("\(eventsPage.items.count) presence events received in first page")
  if eventsPage.hasNext {
    eventsPage.next { nextPage, error in
      print("\(nextPage!.items.count) presence events received in 2nd page")
    }
  }
}
```

See the "presence history documentation":/rest/history#presence-history for further details of the supported query parameters.

h1. API Reference

inline-toc.
  Presence reference:
    - Methods:
      - get(options)#get
      - history(options)#get
    - Related types:
      - PresenceMessage#presence-message
      - Presence action
      - PaginatedResult#paginated-result
      - Param

h2. Methods

h6(#get).
  default: get
  csharp: Get

Get the current presence member set for this channel.  In the REST client library this method directly queries "Ably's REST presence API":/rest-api#presence

bq(definition).
  default: get(Object options, callback("ErrorInfo":/realtime/types#error-info err, "PaginatedResult":#paginated-result<"PresenceMessage":#presence-message> resultPage))
  ruby:    "PaginatedResult":#paginated-result<"PresenceMessage":#presence-message> get(Hash options)
  python:  "PaginatedResult":#paginated-result<"PresenceMessage":#presence-message> get(kwargs_options)
  php:     "PaginatedResult":#paginated-result<"PresenceMessage":#presence-message> get(Array options)
  java:    "PaginatedResult":#paginated-result<"PresenceMessage":#presence-message> get("Param":#param[] options)
  csharp:  Task<"PaginatedResult":#paginated-result<"PresenceMessage":#presence-message>> GetAsync(int? limit = null, string clientId = null, string connectionId = null);
  swift,objc: get(query: ARTPresenceQuery, callback: (["ARTPresenceMessage":#presence-message], ARTErrorInfo?) -> Void)

Gets an array of members present on the channel as "PresenceMessage":#presence-message objects.

blang[jsall,ruby,python,php,java,swift,objc].
  h4. Parameters

  - <span lang="default">options</span><span lang="objc,swift,csharp">query</span><span lang="java">"Param":#param[] options</span> := <span lang="default">an optional object containing query parameters</span><span lang="python">optional keyword arguments containing the query parameters</span><span lang="ruby">an optional set of symbol key and value pairs containing the query parameters</span><span lang="php">an optional Associate Array containing the query parameters</span> as specified below.

  - <div lang="jsall">callback</div> := is a function of the form: @function(err, "PaginatedResult":#paginated-result<"PresenceMessage":#presence-message> resultPage)@
  - <div lang="objc,swift">callback</div> := called with a "@PaginatedResult@":#paginated-result@<@"@PresenceMessage@":#presence-message@>@, or with an error

h4. <span lang="default">@options@ parameters</span><span lang="objc,swift">@ARTPresenceQuery@ properties</span><span lang="csharp">Arguments</span>

- <span lang="default">clientId</span><span lang="python">client_id</span><span lang="ruby">:client_id</span> := when provided, will filter array of members returned that match the provided <span lang="default">"@clientId@":/rest/usage#client-id</span><span lang="ruby,python">"@client_id@":/rest/usage#client-id</span><span lang="csharp">"@ClientId@":/rest/usage#client-id</span> string
- <span lang="default">connectionId</span><span lang="python">connection_id</span><span lang="ruby">:connection_id</span> := when provided, will filter array of members returned that match the provided <span lang="default">@connectionId@</span><span lang="csharp">@ConnectionId@</span><span lang="ruby">@connection_id@</span>":/realtime/connection/#id string

blang[jsall].
  h4. Callback result

  On success, @resultPage@ contains a "@PaginatedResult@":#paginated-result encapsulating an array of "@PresenceMessage@":#presence-message objects corresponding to the current page of members currently present on the channel. "@PaginatedResult@":#paginated-result supports pagination using "@next()@":#paginated-result and "@first()@":#paginated-result methods.

  On failure to retrieve the current presence member set, @err@ contains an "@ErrorInfo@":#error-info object with the failure reason.

blang[java,ruby,php,python,csharp].
  h4. Returns

  <span lang="csharp">This method is asyncronous and needs to be awaited.</span>

  On success, the returned "@PaginatedResult@":#paginated-result encapsulates an array of "@PresenceMessage@":#presence-message objects corresponding to the current page of members currently present on the channel. "@PaginatedResult@":#paginated-result supports pagination using "<span lang="default">@next@</span><span lang="csharp">@NextAsync@</span>":#paginated-result and "<span lang="default">@first@</span><span lang="csharp">@FirstAsync@</span>":#paginated-result methods.

  Failure to retrieve the current presence member set will raise an "@AblyException@":/realtime/types/#ably-exception

h6(#history). History

bq(definition).
  default: history(Object options, callback("ErrorInfo":/rest/types#error-info err, "PaginatedResult":#paginated-result<"PresenceMessage":#presence-message> resultPage))
  ruby:    "PaginatedResult":#paginated-result<"PresenceMessage":#presence-message> history(Hash options)
  python:  "PaginatedResult":#paginated-result<"PresenceMessage":#presence-message> history(kwargs_options)
  php:     "PaginatedResult":#paginated-result<"PresenceMessage":#presence-message> history(Array options)
  java:    "PaginatedResult":#paginated-result<"PresenceMessage":#presence-message> history("Param":#param[] options)
  csharp:  Task<"PaginatedResult":#paginated-result<"PresenceMessage":#presence-message>> HistoryAsync("DataRequestQuery":#data-request-query query);
  objc,swift: history(query: ARTDataQuery?, callback: ("ARTPaginatedResult":#paginated-result<"ARTPresenceMessage":#presence-message>?, ARTErrorInfo?) -> Void) throws

Gets a "paginated":#paginated-result set of historical presence message events for this channel. If the "channel is configured to persist messages to disk":https://support.ably.io/support/solutions/articles/3000030059-how-long-are-messages-stored-for, then the presence message event history will "typically be available for 24 - 72 hours":https://support.ably.io/solution/articles/3000030059-how-long-are-messages-stored-for. If not, presence message events are only retained in memory by the Ably service for two minutes.

h4. Parameters

- <span lang="default">options</span><span lang="java">"Param":#param[] options</span><span lang="objc,swift">query</span><span lang="csharp">"DataRequestQuery":#data-request-query query</span> := <span lang="default">an optional object containing query parameters</span><span lang="python">optional keyword arguments containing the query parameters</span><span lang="ruby">an optional set of key value pairs containing query parameters</span><span lang="php">an optional Associate Array containing the query parameters</span>, as specified in the "presence history API documentation":/rest/history#presence-history.

- <div lang="jsall">callback</div> := is a function of the form: @function(err, resultPage)@
- <div lang="swift,objc">callback</div> := called with a "ARTPaginatedResult":#paginated-result<"ARTPresenceMessage":#presence-message> object or an error

blang[jsall,swift,objc].
  h4. Callback result

  On success, @resultPage@ contains a "@PaginatedResult@":#paginated-result encapsulating an array of "@PresenceMessage@":#presence-message objects corresponding to the current page of results. "@PaginatedResult@":#paginated-result supports pagination using "@next()@":#paginated-result and "@first()@":#paginated-result methods.

  On failure to retrieve message history, @err@ contains an "@ErrorInfo@":#error-info object with the failure reason.

blang[java,ruby,php,python,csharp].
  h4. Returns

  <span lang="csharp">This method is asyncronous and needs to be awaited.</span>

  On success, the returned "@PaginatedResult@":#paginated-result encapsulates an array of "@PresenceMessage@":#presence-message objects corresponding to the current page of results. "@PaginatedResult@":#paginated-result supports pagination using "<span lang="default">@next@</span><span lang="csharp">@NextAsync@</span>":#paginated-result and "<span lang="default">@first@</span><span lang="csharp">@FirstAsync@</span>":#paginated-result methods.

  Failure to retrieve the message history will raise an "@AblyException@":/realtime/types/#ably-exception

h2(#related-types). Related types

h3(#presence-message).
  default: PresenceMessage
  swift,objc: ARTPresenceMessage
  ruby:    Ably::Models::PresenceMessage
  java:    io.ably.lib.types.PresenceMessage
  csharp:  IO.Ably.PresenceMessage

<%= partial 'types/_presence_message' %>

h3(#presence-action).
  default: Presence action
  python:  PresenceAction
  swift,objc: ARTPresenceAction
  java:    io.ably.lib.types.PresenceMessage.Action
  ruby:    Ably::Models::PresenceMessage::ACTION
  csharp:  IO.Ably.PresenceAction

<%= partial 'types/_presence_action' %>

h3(#data-request-query).
  csharp: DataRequestQuery

blang[csharp].
  <%= partial 'types/_data_request_query', indent: 2, skip_first_indent: true %>

h3(#paginated-result).
  default: PaginatedResult
  swift,objc: ARTPaginatedResult
  ruby:    Ably::Models::PaginatedResult
  java:    io.ably.lib.types.PaginatedResult
  csharp:  IO.Ably.PaginatedResult

<%= partial 'types/_paginated_result' %>

h3(#param).
  java:    io.ably.lib.types.Param

blang[java].
  <%= partial 'types/_param', indent: 2, skip_first_indent: true %>
