---
title: "Process messages with external systems"
meta_description: "Process chat messages through external systems to trigger notifications, handle slash commands, analyze sentiment, moderate content, and more."
meta_keywords: "chat processing, message processing, notifications, slash commands, sentiment analysis, chat automation, webhooks"
---

You can process chat messages through external systems like notification services, analytics platforms, or AI tools to build powerful features. By extracting message data and metadata, you can trigger notifications, execute slash commands, analyze sentiment, moderate content, and more.

## Understanding the processing flow <a id="integration-flow"/>

The typical message processing flow works as follows:

1. A user sends a message to a chat room, optionally including [metadata or headers](#using-message-data) for processing context
2. An integration rule evaluates the message based on room name pattern matching
3. If the rule matches, Ably forwards the message to your external system
4. Your external system processes the message and extracts relevant data
5. Based on the message content or metadata, your system can trigger actions like sending notifications, logging events, or analyzing sentiment

## Choosing an integration method <a id="implementation-options"/>

Ably provides several different integration methods, each suited to different use cases.

### Webhooks

[Outbound webhooks](/docs/platform/integrations/webhooks) are ideal for simple business logic and event-driven actions. They work well for processing @mentions or triggering custom notifications, executing lightweight business logic such as lookups and validation, and serverless architectures like AWS Lambda and Cloud Functions.

See [Extract messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#webhooks) for setup details and code examples.

### Streaming

[Outbound streaming](/docs/platform/integrations/streaming) enables massive scale and integration with existing infrastructure. This is ideal for high-throughput scenarios with large-scale chats and millions of messages, leveraging existing streaming infrastructure like Kafka or Kinesis, and building complex data pipelines and analytics.

See [Extract messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#streaming) for setup details and code examples.

### Ably Queues

[Ably Queues](/docs/platform/integrations/queues) provide strict ordering and fault-tolerant delivery. They are well suited for automated support flows where message order matters, processing sequential events like game moves or transaction steps, and fault-tolerant message processing with automatic retries.

See [Extract messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#queues) for setup details and code examples.

## Using message data for processing <a id="using-message-data"/>

When your integration receives messages, you have access to structured data that enables various processing patterns.

### Extracting message data

Clients can include metadata to provide context for your external services. For example, when implementing a notification system, you might include the target user ID and notification type:

<Code>
```javascript
// Client sends message with metadata
await room.messages.send({
  text: '@john.123 Can you review this?',
  metadata: {
    targetClientId: 'john.123',
    notificationType: 'mention'
  }
});
```
</Code>

In your integration, decode the messages and extract the relevant data:

<Code>
```javascript
const Ably = require('ably');

async function processIntegrationPayload(envelopeData) {
  // Decode messages using Ably SDK
  const decodedMessages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of decodedMessages) {
    // Extract text content
    const text = msg.data?.text;

    // Extract headers for routing
    const headers = msg.extras?.headers || {};
    const command = headers['x-command'];

    // Extract metadata for business context (treat as untrusted)
    const metadata = msg.data?.metadata || {};
    const notificationType = metadata.notificationType;

    // Extract room and user information
    const roomName = envelopeData.channel.replace('::$chat', '');
    const senderId = msg.clientId;

    // Route based on headers or metadata
    if (command === 'remind') {
      await handleRemindCommand(text, metadata.targetClientId, senderId);
    } else if (notificationType === 'mention') {
      await sendMentionNotification(metadata.targetClientId, text, roomName, senderId);
    }
  }
}
```
</Code>

For complete details on message decoding and structure, see the section on [extracting messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#decoding).

### Available message data

Each message provides the following data points:

* **Message text** (`msg.data.text`): The actual message content for text analysis, command parsing, or content moderation
* **Client ID** (`msg.clientId`): The user who sent the message, useful for attribution and user-specific actions
* **Timestamp** (`msg.timestamp`): When the message was sent, enabling time-based processing or analytics
* **Message ID** (`msg.id`): Unique identifier for tracking, logging, or reference
* **Room information** (`envelopeData.channel`): Which chat room the message came from
* **Metadata** (`msg.data.metadata`): Client-provided structured data for business context
* **Headers** (`msg.extras.headers`): Server-controlled routing and processing flags

### Enabling features with metadata

Client applications can include metadata to provide context for your processing logic. This enables patterns like:

**@Mention notifications:** When a client detects that a user has mentioned another user (e.g., `@john.123`), it can include the target user's ID in the metadata. Your integration can then extract this information to trigger push notifications, emails, or other notification mechanisms to alert the mentioned user.

**Slash commands:** For commands like `/remind @user message`, clients can include the command type and parameters in metadata (e.g., `targetClientId`, `reminderTime`). Your integration processes this structured data to schedule reminders, execute actions, or trigger workflows.

**Content categorization:** Clients can tag messages with categories or intents (e.g., `messageType: 'question'`, `category: 'support'`) to help your integration route messages to appropriate handlers, analytics pipelines, or support systems.

**Important:** Metadata comes from client applications and should always be treated as untrusted user input. Validate and sanitize metadata in your integration before using it for processing decisions.

## Key considerations <a id="key-considerations"/>

Consider the following when integrating external systems with Ably Chat:

* **Scale and reliability:** Different integration methods offer different reliability guarantees. See [choosing an integration method](#implementation-options) for guidance on webhooks, streaming, and queues
* **External system limitations:** Your external service may have rate limits, processing constraints, or availability issues. Implement retry logic, circuit breakers, and caching to handle these limitations gracefully
* **Cost optimization:** Only process messages that require processing. Use channel filters and metadata/headers to route messages efficiently
* **Security:** Always validate and sanitize client-provided metadata before using it in your integration logic. Treat all client-provided data as untrusted input. For sensitive operations like payment processing or moderation actions, make authorization decisions server-side based on user permissions and authentication context rather than trusting client-provided flags
* **Error handling:** Handle external system failures gracefully - consider fallback responses or queuing failed requests for retry
* **Privacy:** Be mindful of what message data you store or forward to external services. Consider data retention policies and user privacy requirements when processing chat messages
