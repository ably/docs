---
title: "Extract messages via integrations"
meta_description: "Extract chat messages from Ably Chat using integrations for external processing, storage, or analysis."
meta_keywords: "chat integrations, message extraction, webhooks, streaming, queues, message processing, chat data"
---

Extract chat messages from Ably Chat rooms to external systems using Ably's integration capabilities. This enables you to process, store, or analyze messages outside of Ably Chat while maintaining realtime message delivery to chat participants.

Chat rooms are built on Ably Pub/Sub channels, allowing you to leverage the full range of Ably's [platform integrations](/docs/platform/integrations) to forward messages to external systems.

## Integration methods <a id="methods"/>

Ably provides three primary methods for extracting chat messages:

1. **[Webhooks](#webhooks)** - Forward messages to [HTTP endpoints](/docs/platform/integrations/webhooks/generic), [AWS Lambda](/docs/platform/integrations/webhooks/lambda), [Google Cloud Functions](/docs/platform/integrations/webhooks/gcp-function), [Cloudflare Workers](/docs/platform/integrations/webhooks/cloudflare), and more
2. **[Queues](#queues)** - Route messages to [Ably-managed queues](/docs/platform/integrations/queues) for consumption by your services
3. **[Streaming](#streaming)** - Stream messages to external systems like [Kafka](/docs/platform/integrations/streaming/kafka), [Kinesis](/docs/platform/integrations/streaming/kinesis), [SQS](/docs/platform/integrations/streaming/sqs), [AMQP](/docs/platform/integrations/streaming/amqp), or [Pulsar](/docs/platform/integrations/streaming/pulsar)

Each method offers different trade-offs in terms of simplicity, reliability, and infrastructure requirements.

## Filtering rooms <a id="filtering"/>

Control which chat rooms trigger integrations using channel name filters.

### Setting up filters <a id="filter-setup"/>

When configuring an integration rule in your Ably dashboard:

* **Channel filter**: Use a regular expression to match room names. For example, `^support:.*` matches all rooms starting with `support:`
* **Event type**: Use `channel.message` to forward chat messages and exclude presence events
* **Enveloped messages**: Enable to receive full message metadata including `serial`, `version`, and `headers`

**Note**: Chat rooms use the `::$chat` suffix on channel names internally. Integration filters match against the full channel name, but you don't need to include the suffix in your filter pattern.

### Example filter configuration

<Code>
```javascript
// Room name: support:ticket-123
// Internal channel: support:ticket-123::$chat
// Filter pattern: ^support:.*
// Result: Messages from this room will be forwarded

const supportRoom = await chatClient.rooms.get('support:ticket-123');
await supportRoom.messages.send({ text: 'Help needed' }); // Will trigger integration
```
</Code>

## Understanding channel names and room names <a id="channel-names"/>

Chat rooms are underpinned by Ably Pub/Sub channels with a `::$chat` suffix added to form the full channel name. When using the Chat SDK to create or get a room, this is done automatically - you don't need to include the suffix yourself.

Integration rules match against the full channel name, but you don't need to include the `::$chat` suffix in your filter pattern.

<Code>
```javascript
// Get a chat room - the room name becomes the channel name with ::$chat suffix
const supportRoom = await chatClient.rooms.get('chat:support');
// Underlying channel: chat:support::$chat

// Messages sent to these rooms will trigger an integration
// if your rule's channel filter is: ^chat:support.*
await supportRoom.messages.send({ text: 'Need help' });

// Messages sent to other channel patterns will NOT trigger the integration
const generalRoom = await chatClient.rooms.get('chat:general');
// Underlying channel: chat:general::$chat
await generalRoom.messages.send({ text: 'Hi' }); // Won't trigger if filter is ^chat:support.*
```
</Code>

## Decoding messages <a id="decoding"/>

Messages received through integrations are encoded as Ably Pub/Sub messages and need to be decoded into Chat messages. Full details on the mapping are available in the [Chat integrations](/docs/chat/integrations) documentation.

### Understanding enveloped messages <a id="envelope"/>

With enveloping enabled (recommended), messages arrive wrapped in metadata:

<Code>
```javascript
{
  "source": "channel.message",
  "appId": "your-app-id",
  "channel": "support:ticket-123::$chat",
  "ruleId": "integration-rule-id",
  "messages": [
    {
      "id": "unique-message-id",
      "clientId": "user-123",
      "name": "chat.message",
      "timestamp": 1234567890,
      "serial": "01765820788939-000@108wgxjJwBwuAB37648671:000",
      "action": 0,
      "data": {
        "text": "Message content",
        "metadata": {}
      },
      "extras": {
        "headers": {}
      }
    }
  ]
}
```
</Code>

### Extracting room name <a id="extract-room"/>

Remove the `::$chat` suffix to get the room name:

<Code>
```javascript
function extractRoomName(channelName) {
  // channelName: "support:ticket-123::$chat"
  return channelName.replace('::$chat', ''); // Returns: "support:ticket-123"
}
```
</Code>

### Decoding message data <a id="decode-data"/>

Use the Ably SDK to decode messages from the envelope:

<Code>
```javascript
const Ably = require('ably');

function decodeMessages(envelopeData) {
  const decodedMessages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  return decodedMessages.map(msg => ({
    serial: msg.serial,
    text: msg.data?.text,
    metadata: msg.data?.metadata || {},
    headers: msg.extras?.headers || {},
    clientId: msg.clientId,
    timestamp: msg.timestamp,
    action: msg.action,
    versionSerial: msg.version?.serial || msg.serial
  }));
}
```
</Code>

## Using metadata and headers <a id="metadata-headers"/>

Metadata and headers enable you to control how messages are processed by external systems and add context for integration logic.

### Metadata

Message [`metadata`](/docs/chat/rooms/messages#structure) is set by the client when sending a message. Use metadata for storing JSON-serializable structured data relevant to your application logic.

For example, if triggering some notification process from a particular client, you might include user or intent information in the metadata:

<Code>
```javascript
// Client sends message with metadata
await room.messages.send({
  text: '@john.123 Hey, how are you?',
  metadata: {
    targetClientId: 'User123',
    type: 'mention',
    location: 'London',
    timestamp: Date.now()
  }
});
```
</Code>

**Important:** Metadata is not server-validated. Always treat it as untrusted user input in your integration code.

### Headers

Message [`headers`](/docs/chat/rooms/messages#structure) can be set by the client when sending a message, similar to metadata. However, they are more typically used for [filtering](/docs/pub-sub/advanced#filter-subscribe) subscriptions and routing for integrations.

For example, you might include headers to indicate the type of processing required by your integration:

<Code>
```javascript
// Client sends message with headers
await room.messages.send({
  text: '@john.123 Hey, how are you?',
  metadata: {
    targetClientId: 'john.123',
    type: 'mention
    location: 'London',
    timestamp: Date.now()
  },
  headers: {
    'x-intent': 'notification',
    'x-priority': 'high'
  }
});
```
</Code>

#### Adding headers at the rule level

When configuring an integration rule in your Ably dashboard, you can specify headers to be added when the rule triggers. This allows you to attach additional metadata to messages only when they match your integration criteria.

These rule-level headers are added after the client publishes the message, so they appear in the enveloped message received by your integration endpoint but not in the original message stored in chat history. They will also not be visible to other chat clients.

**Important:** While rule-level headers cannot be set or modified by clients, neither headers nor metadata should be treated as fully server-authoritative. Always validate and sanitize all data in your integration code before using it for business logic or security decisions.

## Message versioning <a id="versioning"/>

Chat messages have a versioning system for updates and deletes:

* **`serial`**: Unique identifier for the original message
* **`version.serial`**: Identifier for the specific message version
* **`action`**: Indicates message type (create, update, delete, or summary for reactions)

### Handling message versions <a id="handle-versions"/>

<Code>
```javascript
function processMessage(message) {
  // Discard reaction summaries if not needed
  if (message.action === 'message.summary') {
    return;
  }

  // Process based on action
  switch (message.action) {
    case 'message.created':
      handleNewMessage(message);
      break;
    case 'message.updated':
      handleMessageUpdate(message);
      break;
    case 'message.deleted':
      handleMessageDelete(message);
      break;
  }
}
```
</Code>

### Version ordering <a id="version-ordering"/>

Version serials are lexicographically ordered. A higher `version.serial` indicates a newer version:

<Code>
```javascript
function isNewerVersion(existingVersion, newVersion) {
  return newVersion > existingVersion;
}

// Only process if this is a newer version
if (isNewerVersion(stored.version.serial, incoming.version.serial)) {
  updateMessage(incoming);
}
```
</Code>

Read more about [message versioning and sorting](/docs/chat/rooms/messages#ordering-update-delete) in the messages documentation.

## Using webhooks <a id="webhooks"/>

[Outbound webhooks](/docs/platform/integrations/webhooks) enable you to forward messages to HTTP endpoints or serverless functions.

### Setup

Configure a webhook integration in your Ably dashboard pointing to your endpoint. See the following for platform-specific setup guides:

* [Generic HTTP webhook](/docs/platform/integrations/webhooks/generic) - Forward to any HTTP/HTTPS endpoint
* [AWS Lambda](/docs/platform/integrations/webhooks/lambda) - Trigger Lambda functions
* [Google Cloud Functions](/docs/platform/integrations/webhooks/gcp-function) - Invoke GCP functions
* [Cloudflare Workers](/docs/platform/integrations/webhooks/cloudflare) - Trigger Workers
* [General webhook documentation](/docs/platform/integrations/webhooks) - Overview and other platforms

### Benefits
* Simplest integration method to implement.
* Automatic retry handling with configurable retry windows.
* No additional infrastructure required beyond your webhook endpoint or function.
* Messages can be batched together to reduce invocation overhead.

### Considerations

* **Retry behavior**: For Lambda, AWS automatically retries failed invocations up to two times with delays (1 minute, then 2 minutes). For generic HTTP webhooks, Ably retries for a limited window.
* **Ordering**: Messages may arrive out-of-order; use `serial` and `version.serial` to sort.
* **Message Loss**: Messages may be dropped if retries exceed the retry window.
* **Deduplication**: Handle potential duplicates using message serials - webhooks provide at-least-once delivery.
* **Monitoring**: Use [`[meta]log` channel](/docs/metadata-stats/metadata/subscribe#log) to detect failures (see [monitoring section](#monitoring-performance)).

### Example webhook handler

<Code>
```javascript
async function handleWebhook(req, res) {
  const envelope = req.body;
  const roomName = extractRoomName(envelope.channel);
  const messages = decodeMessages(envelope);

  for (const message of messages) {
    await processMessage(roomName, message);
  }

  res.status(200).send('OK');
}
```
</Code>

## Using queues <a id="queues"/>

[Ably Queues](/docs/platform/integrations/queues) are traditional message queues that enable you to consume, process, or store chat messages from your servers.

### Setup

Configure an Ably queue integration in your dashboard:

1. [Provision a queue](/docs/platform/integrations/queues#provision) with your desired region, TTL, and max length settings
2. [Create a queue rule](/docs/platform/integrations/queues#config) to route chat messages to the queue
3. Consume messages using [AMQP](/docs/platform/integrations/queues#amqp) or [STOMP](/docs/platform/integrations/queues#stomp) protocols

See [Ably queues](/docs/platform/integrations/queues) for complete setup details.

### Benefits

* Fault-tolerant message delivery
* Messages persist during consumer downtime (up to queue limits)
* Dead letter queue for dropped messages
* At-least-once delivery guarantee

### Considerations

* **Queue limits**: Default maximum is 10,000 messages. Monitor queue length during peak times to avoid reaching capacity
* **TTL**: Messages expire after 60 minutes (default/max) if not consumed
* **Dead letter queue**: Automatically provisioned. Always consume to monitor for dropped or expired messages
* **Throughput**: Multi-tenanted queues support up to 200 messages/second per account. For higher volumes, consider [dedicated queues or streaming](/docs/platform/integrations/queues#scalability)
* **Ordering**: Messages maintain order per channel with a single consumer. Multiple consumers or multi-channel messages may affect ordering

### Example queue consumer (AMQP)

<Code>
```javascript
const amqp = require('amqplib');

// Queue name format: APPID:queue-name
const queueName = 'your-app-id:chat-messages';
// Avoid hardcoding credentials in production
const url = 'amqps://APPID.KEYID:SECRET@us-east-1-a-queue.ably.io/shared';

amqp.connect(url, (err, conn) => {
  if (err) { return console.error(err); }

  conn.createChannel((err, ch) => {
    if (err) { return console.error(err); }

    // Subscribe to the queue
    ch.consume(queueName, (item) => {
      const envelope = JSON.parse(item.content);
      const roomName = extractRoomName(envelope.channel);

      // Decode messages using Ably SDK
      const messages = Ably.Realtime.Message.fromEncodedArray(envelope.messages);

      messages.forEach(async (message) => {
        await processMessage(roomName, message);
      });

      // Acknowledge message to remove from queue
      ch.ack(item);
    });
  });
});
```
</Code>

### Monitor the dead letter queue <a id="dead-letter-queue"/>

Ably automatically provisions a [dead letter queue](/docs/platform/integrations/queues#deadletter) when you create a queue. Messages are moved to the dead letter queue when they:

* Are rejected by consumers (`basic.reject` or `basic.nack` with `requeue=false`)
* Exceed their TTL and expire
* Cause the queue to reach maximum capacity (oldest messages dropped)

**Important:** Monitor your dead letter queue to detect processing failures and capacity issues.

<Code>
```javascript
async function monitorDeadLetterQueue(appID) {
  // Dead letter queue name format: APPID:deadletter
  const dlqName = `${appID}:deadletter`;
  // Avoid hardcoding credentials in production
  const url = 'amqps://APPID.KEYID:SECRET@us-east-1-a-queue.ably.io/shared';

  amqp.connect(url, (err, conn) => {
    if (err) { return console.error(err); }

    conn.createChannel((err, ch) => {
      if (err) { return console.error(err); }

      ch.consume(dlqName, (item) => {
        const envelope = JSON.parse(item.content);
        console.error('Message dropped from queue:', envelope);

        // Handle failed message (alert, retry, etc.)
        handleFailedMessage(envelope);

        ch.ack(item);
      });
    });
  });
}
```
</Code>

**Note:** Only one dead letter queue exists per Ably application, shared across all queues.

## Using streaming <a id="streaming"/>

[Outbound streaming](/docs/platform/integrations/streaming) enables you to stream a constant flow of chat messages to external streaming or queueing services.

### Setup

Configure streaming to your target system. See the following for platform-specific setup:

* [Apache Kafka](/docs/platform/integrations/streaming/kafka) - Stream to Kafka topics
* [AWS Kinesis](/docs/platform/integrations/streaming/kinesis) - Stream to Kinesis streams
* [AWS SQS](/docs/platform/integrations/streaming/sqs) - Stream to SQS queues
* [AMQP](/docs/platform/integrations/streaming/amqp) - Stream to AMQP brokers
* [Apache Pulsar](/docs/platform/integrations/streaming/pulsar) - Stream to Pulsar topics
* [General streaming documentation](/docs/platform/integrations/streaming) - Overview and configuration

### Benefits

* Leverage existing streaming infrastructure
* Full control over retention and processing
* Massive scale capabilities

### Considerations

* **Infrastructure**: You manage and maintain the streaming system
* **Reliability**: Messages lost if system unavailable
* **Complexity**: Higher operational overhead

### Example Kafka consumer

<Code>
```javascript
const { Kafka } = require('kafkajs');

async function consumeFromKafka() {
  const consumer = kafka.consumer({ groupId: 'chat-processor' });
  await consumer.connect();
  await consumer.subscribe({ topic: 'ably-chat-messages' });

  await consumer.run({
    eachMessage: async ({ message }) => {
      const envelope = JSON.parse(message.value);
      const roomName = extractRoomName(envelope.channel);
      const decoded = decodeMessages(envelope);

      await processMessages(roomName, decoded);
    }
  });
}
```
</Code>

## Monitoring integration performance <a id="monitoring-performance"/>

Monitor the health and performance of your integrations in realtime using Ably's [metachannels](/docs/metadata-stats/metadata/subscribe). Metachannels provide app-level metadata about integrations, statistics, and errors.

### Monitor integration errors <a id="monitor-errors"/>

The [`[meta]log` channel](/docs/metadata-stats/metadata/subscribe#log) publishes error events from integrations in realtime. This enables you to detect and respond to integration failures as they occur.

Subscribe to the `[meta]log` channel to receive error events:

<Code>
```javascript
const Ably = require('ably');
const client = new Ably.Realtime({ key: 'YOUR_API_KEY' });

const metaLogChannel = client.channels.get('[meta]log');

await metaLogChannel.subscribe((message) => {
  if (message.data.error) {
    alertOperationsTeam(message.data);
  }
});
```
</Code>

Integration error logs will contain a `tag` field as part of the `data` payload, indicating the integration type - for example, `reactor.generic.http`, for webhooks. This allows you to filter and categorize errors by integration method.

**Note:** The `[meta]log` channel only publishes errors that cannot be directly reported to clients. For example, webhook delivery failures or queue publishing errors.

### Monitor app statistics <a id="monitor-stats"/>

The [`[meta]stats:minute` channel](/docs/metadata-stats/metadata/subscribe#stats) publishes [app-level statistics](/docs/metadata-stats/stats) every minute. Use these statistics to monitor integration throughput, message volumes, and resource usage.

Subscribe to receive [statistics](docs/metadata-stats/stats#outbound) updates:

<Code>
```javascript
const statsChannel = client.channels.get('[meta]stats:minute');

await statsChannel.subscribe('update', (event) => {
  const stats = event.data.entries;

  // Monitor integration-specific metrics
  console.log('Integration stats:', {
    webhooks: stats['messages.outbound.webhook.messages.count'] || 0,
    queues: stats['messages.outbound.sharedQueue.messages.count'] || 0,
    // Add other metrics as needed
  });

  // Alert on anomalies
  if (stats['messages.outbound.webhook.all.failed'] > threshold) {
    alertOnWebhookFailures(stats);
  }
});
```
</Code>

Use the [rewind channel option](/docs/channels/options/rewind) to retrieve the most recent statistics immediately:

<Code>
```javascript
// Get the last statistics event plus subscribe to future updates
const statsChannel = client.channels.get('[meta]stats:minute', {
  params: { rewind: '1' }
});

statsChannel.subscribe('update', (event) => {
  console.log('Stats:', event.data.entries);
});
```
</Code>

### Integration monitoring best practices <a id="monitoring-best-practices"/>

* **Subscribe to both channels**: Use `[meta]log` for error detection and `[meta]stats:minute` for performance monitoring
* **Set up alerting**: Create automated alerts for integration failures or throughput anomalies
* **Track trends**: Store statistics over time to identify patterns and capacity planning needs
* **Filter by integration type**: Use the statistics entries to monitor specific integration methods (webhooks, queues, streaming)
* **Correlate with external logs**: Use `requestId` from error events to correlate with your system logs

See [metadata subscriptions documentation](/docs/metadata-stats/metadata/subscribe) for complete details on available metachannels.

## Handling message reactions <a id="reactions"/>

Message reactions are delivered as separate events with `action: 'message.summary'`.

### Reaction summary structure

<Code>
```javascript
{
  "action": "message.summary",
  "serial": "original-message-serial",
  "annotations": {
    "summary": {
      "reaction:unique.v1": {
        "üëç": { "count": 5 },
        "‚ù§Ô∏è": { "count": 3 }
      }
    }
  }
}
```
</Code>

### Processing reactions

<Code>
```javascript
function processMessage(message) {
  if (message.action === 'message.summary') {
    // Handle reaction summary
    const reactions = message.annotations?.summary?.['reaction:unique.v1'] || {};
    updateReactionCounts(message.serial, reactions);
    return;
  }

  // Handle regular message
  saveMessage(message);
}
```
</Code>

Read more about [message reactions](/docs/chat/rooms/message-reactions) and the [reactions annotation mapping](/docs/chat/integrations#how-to-handle-message-reactions).


## Related documentation

* [Chat integrations](/docs/chat/integrations) - Technical reference for message structure mapping
* [Platform integrations](/docs/platform/integrations) - Complete integration setup guides
* [Message structure](/docs/chat/rooms/messages#structure) - Chat message format details
* [Chat history](/docs/chat/rooms/history) - Retrieve historical messages via API
* [Store messages in your database](/docs/chat/external-storage-and-processing/data-storage) - Guide for long-term storage
* [Process and respond to messages](/docs/chat/external-storage-and-processing/data-processing) - Guide for bidirectional integrations
