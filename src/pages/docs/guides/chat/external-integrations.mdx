---
title: "Guide: Integrate external systems with Ably Chat"
meta_description: "Extend Ably Chat with external integrations: process messages with AI, webhooks, and custom logic at scale."
meta_keywords: "chat integrations, external systems, webhooks, AI chat, message processing, chat automation, integration rules, message routing"
---

Ably Chat is designed for extensibility. Whether you need to process messages with AI, translate content in real-time, trigger business workflows, or enrich messages with external data, Ably's integration capabilities enable you to extend your chat application without compromising on scale, reliability, or performance.

This guide explains how to architect integrations that process chat messages through external systems and respond back to the chat in real-time. Before diving into the technical implementation, it's important to understand your architectural goals and the role your external system will play.

## Why integrate external systems?

Integrating external systems with Ably Chat enables you to extend your chat application beyond simple message delivery. Common integration use cases include:

* **AI-powered assistants:** Process commands or questions through language models and respond with helpful information.
* **Real-time translation:** Automatically translate messages for multilingual chat rooms.
* **Notifications:** Detect and process mentions, or other notifications.
* **Analytics and monitoring:** Analyze sentiment, track engagement metrics, or identify trending topics.
* **Workflow automation:** Trigger external business processes based on chat activity.
* **Command processing:** Handle slash commands that invoke server-side logic.

Unlike [chat moderation](/docs/chat/moderation), which filters or blocks content before or after publication, integrations focus on processing messages and responding with new content or triggering external actions. Also unlike [exporting chat data](/docs/guides/chat/export-chat), which stores all messages for long-term retention, integrations process specific messages matched by integration rules.

## Why Ably for external integrations?

Ably Chat integrations are built on Ably's proven platform architecture, designed to handle integration workloads at any scale:

* **Reliable message delivery:** Every integration benefits from Ably's [four pillars of dependability](/docs/platform/architecture): Performance, Integrity, Reliability, and Availability.
* **Flexible routing:** Use channel filters to selectively route only the messages on channels that need processing to your integration.
* **Multiple integration methods:** Choose webhooks, queues, or streaming based on your architecture and scale requirements.
* **Proven at scale:** Ably processes over 500 million messages per day for customers, with [serverless scalability](/docs/platform/architecture/platform-scalability) that eliminates infrastructure management.
* **No vendor lock-in:** Integrate with any external service, using any language or platform that can handle HTTP requests or consume from queues.

Because Ably Chat rooms use Pub/Sub channels as their underlying transport, you can leverage all of Ably's [platform integrations](/docs/platform/integrations) to extend your chat application.

## Key considerations <a id="key-considerations"/>

Consider the following when integrating external systems with Ably Chat:

* **Avoiding infinite loops:** When your integration responds back to chat, ensure responses don't trigger the same integration rule. Use separate channels or the [privileged skip integration flag](/docs/platform/integrations/skip-integrations) to break potential loops.
* **Scale and reliability:** Different integration methods offer different reliability guarantees. Webhooks are simpler to implement but have limited retry windows, queues provide at-least-once delivery with dead letter queues, and streaming offers massive scale but requires more infrastructure management.
* **External system limitations:** Your external service may have rate limits, processing constraints, or availability issues. Implement retry logic, circuit breakers, and caching to handle these limitations gracefully.
* **Cost optimization:** Only process messages that require processing. Use channel filters to ensure you only receive messages from relevant chat rooms.

## Implementation options <a id="implementation-options"/>

With your strategy in mind, choose the technical approach that fits your needs:

1. Using [outbound webhooks](#webhook). [HTTP endpoint](/docs/platform/integrations/webhooks/generic), [AWS Lambda](/docs/platform/integrations/webhooks/lambda), and others.
2. Using [Ably queues](#ably-queue).
3. Using [outbound streaming](#outbound-streaming). Stream to your own [Kafka](/docs/platform/integrations/streaming/kafka), [Kinesis](/docs/platform/integrations/streaming/kinesis), and others.

## Understanding integrations

Ably Chat rooms are built on Ably Pub/Sub channels, which means you can leverage Ably's integration capabilities to forward messages to external systems for processing:

* **Chat rooms use Pub/Sub channels:** Each chat room is built on an Ably channel, enabling the full range of Ably's integration capabilities.
* **Message structure:** Chat messages are encoded as Pub/Sub messages with a specific structure. See the [Chat integrations documentation](/docs/chat/integrations) for details on the mapping.
* **Integration rules:** Configure rules that filter which messages trigger integrations based on channel name patterns and event types.
* **Bidirectional flow:** Integrations allow you to export messages to external systems, process them, and respond back to chat rooms in real-time.

### Integration flow

The typical integration flow works as follows:

1. A user sends a message to a chat room, optionally including headers or metadata to control processing externally.
2. An integration rule evaluates the message based on room name pattern matching.
3. If the rule matches, Ably forwards the message to your external system via the configured integration method.
4. Your external system processes the message (AI inference, translation, business logic, etc.).
5. The external system sends a response back to an Ably Chat room.
6. All subscribed clients receive the response in real-time.

[/TODO/]: # (Add a visual showing somethign like *Client → Ably Chat → Integration Rule → External System → Response → Ably Chat → Clients*)

## Filtering rooms and event types <a id="filtering"/>

Integrations allow you to filter which Chat rooms are forwarded to your external system using a regular expression on the room name.
This is a simple way to reduce the volume of messages you need to process by only receiving messages from the chat rooms you are interested in.

### Setting up integration rules

When configuring an integration rule in your Ably dashboard:

* **Channel filter:** Use a regular expression to match channel names. For example, `^chat:support.*` will match all channels starting with `chat:support`. See [understanding channel names and room names](#understanding-channel-names-and-room-names) for details on how room names map to channel names.
* **Event type:** Use `channel.message` for all integration types. This forwards all chat messages published to relevant rooms and excludes presence messages and channel lifecycle messages
* **Enveloped messages:** Enable this to receive all metadata about the message, including the `serial`, `version`, and `extras` (which include the [`headers`](/docs/chat/rooms/messages#structure) of a chat message)

### Understanding channel names and room names

Chat rooms are underpinned by Ably Pub/Sub channels, but with a specific suffix (`::$chat`) added to form the full channel name.
When using the Chat SDK to create or get a room, this is done automatically for you, you do not need to include the suffix yourself.

Integration rules match against the full channel name, but you don't need to include the `::$chat` suffix in your filter pattern.

**Example room and channel naming:**

<Code>
```javascript
// Get a chat room - the room name becomes the channel name with ::$chat suffix
const supportRoom = await chatClient.rooms.get('chat:support');
// Underlying channel: chat:support::$chat

const groupRoom = await chatClient.rooms.get('chat:group:123');
// Underlying channel: chat:group:123::$chat

// Messages sent to these rooms will trigger an integration
// if your rule's channel filter is: ^chat:support.*
await supportRoom.messages.send({ text: 'Need help' });

// Messages sent to other channel patterns will NOT trigger the integration
const generalRoom = await chatClient.rooms.get('chat:general');
await generalRoom.messages.send({ text: 'Hi' }); // Won't trigger if filter is ^chat:support.*
```
</Code>

## Decoding and processing messages <a id="decoding-and-processing"/>

When your integration receives messages, you need to decode them and extract the relevant information.

### Understanding enveloped messages

With enveloping enabled (the default), Ably wraps messages in additional metadata like so:

<Code>
```javascript
{
  "source": "channel.message",
  "appId": "your-app-id",
  "channel": "chat:support::$chat",
  "site": "eu-west-1-A",
  "ruleId": "integration-rule-id",
  "messages": [
    {
      "id": "message-id",
      "name": "event-name",
      "connectionId": "connection-id",
      "timestamp": 1234567890,
      "data": {
        "text": "Message content",
        "metadata": {}
      },
      "extras": {
        "headers": {
          "x-integration-action": "weather"
        }
      }
    }
  ]
}
```
</Code>

### Extracting the room name

Your integration receives the full channel name including the `::$chat` suffix. To send responses back to the same room, extract the room name by removing the suffix:

<Code>
```javascript
// In your webhook handler or queue consumer
function processIntegrationPayload(envelopeData) {
  // Extract room name from channel name
  const channelName = envelopeData.channel; // e.g., "chat:support::$chat"
  const roomName = channelName.replace('::$chat', ''); // e.g., "chat:support"
}
```
</Code>

### Extracting message data

The Ably SDK provides methods to decode messages from the enveloped payload.
From there, you can extract the text content, headers, and metadata and process them as needed.
You can use custom headers to control how messages are processed by your integration. For example, you might define an `x-integration-action` header to specify different processing actions:

<Code>
```javascript
const Ably = require('ably');

async function processIntegrationPayload(envelopeData) {
  // Decode messages using Ably SDK
  const decodedMessages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of decodedMessages) {
    // Extract text content
    const text = msg.data?.text;

    // Extract headers (used for routing and control)
    const headers = msg.extras?.headers || {};
    const action = headers['x-integration-action'];

    // Extract metadata (custom structured data)
    const metadata = msg.data?.metadata || {};

    // Process each message
    await processMessage(roomName, text, action);
  }
}

async function processMessage(roomName, text, action) {
    switch (action) {
      case 'weather':
        await handleWeatherRequest(text, roomName);
        break;

      case 'translate':
        await handleTranslationRequest(text, roomName);
        break;

      case 'ai-assist':
        await handleAIAssistantRequest(text, roomName);
        break;

      default:
        // Ignore messages without integration actions
        break;
    }
}
```
</Code>

## Using a webhook <a id="webhook"/>

Ably can forward messages to your external system via a webhook. This is the simplest to set up and offers the lowest latency. This section covers the simple HTTP endpoint webhook, but the same principles apply to other webhook integrations such as AWS Lambda, Azure Function, Google Cloud Function, and others.

Read the guide on [outbound webhooks](/docs/platform/integrations/webhooks) for more details on how to set up a webhook with Ably for the platform of your choice.

**Benefits:**
* Easiest to set up and understand
* No infrastructure to manage with serverless functions
* Direct HTTP invocation with automatic retries
* Native support for major cloud providers

**You need to consider:**
* **Cold start latency:** Serverless functions may have cold start delays. Consider keeping functions warm for latency-sensitive use cases.
* **Limited retry window:** Ably will retry delivering the message to your webhook, but only for a short period. Monitor the [`[meta]log` channel](/docs/platform/errors#meta) for delivery failures.
* **Scale limits:** Webhook scale depends on your function's concurrency configuration. Ensure your function can handle expected message volumes.
* **[At-least-once delivery](/docs/platform/architecture/idempotency#protocol-support-for-exactly-once-delivery):** Deduplication can be done by checking `serial` and `version.serial`.
* **Ordering:** Messages can arrive out-of-order. Use `serial` and `version.serial` properties to order them correctly if needed.

## Using an Ably queue <a id="ably-queue"/>

Ably can forward messages from chat room channels to an [Ably Queue](/docs/platform/integrations/queues), which you can then consume from your own servers to process messages through your external system and respond back to chat. Read the guide on [Ably queues](/docs/platform/integrations/queues) for more details on how to set up the queue integration with Ably.

Ably ensures that each message is delivered to only one consumer even if multiple consumers are connected.

**Benefits:**
* At-least-once delivery with dead letter queue support.
* No message loss if your consumers temporarily disconnect.
* Scale consumers independently by running multiple instances.
* Use multiple queues for different channels, filtering via regex on channel name.
* Ably manages the queue infrastructure for you.

**You need to consider:**
* **Queue limits:** Each message has a time-to-live (TTL) in the queue. The default and maximum is 60 minutes.
* **Consumer scaling:** During peak times you may need to scale up your consumers to avoid going over the maximum queue length allowed.
* **Dead letter queue:** Oldest messages are dropped if the maximum queue length is exceeded. Always consume messages from the [dead letter queue](/docs/platform/integrations/queues#deadletter) to monitor errors.
* **Consumer infrastructure:** You need to manage and maintain your consumer servers or containers that process messages from the queue.

## Using outbound streaming <a id="outbound-streaming"/>

Ably can stream messages directly to your own queueing or streaming service: Kafka, Kinesis, AMQP, SQS, Pulsar. Read the guide on [outbound streaming](/docs/platform/integrations/streaming) for more details on how to set up the streaming integration with Ably for the service of your choice.

**Benefits:**
* Massive scale (millions of messages/second)
* Multiple consumers can process the same stream
* Integration with existing data infrastructure
* Use your existing queue system to process messages from Ably

**You need to consider:**
* **Infrastructure complexity:** You need to maintain and be responsible for a reliable streaming system. If you don't already have such a system, it increases complexity.
* **Consistency:** If your streaming system is not reachable, messages may be lost. Errors can be seen in the [`[meta]log` channel](/docs/platform/errors#meta).
* **Setup complexity:** Most complex integration method to set up and operate.

## Responding back to chat <a id="responding"/>

After processing messages through your external system, you will typically want to publish responses back to the chat room. This could be answers from an AI assistant, translated text, enriched content, or status updates.
To avoid triggering the integration rule on the response message, Use Ably's [skip integrations](/docs/platform/integrations/skip-integrations) feature to publish messages that bypass integration rules.

**Note:** Your API key or token must have the [`privileged-headers`](/docs/auth/capabilities#capability-operations) capability to apply the skip integration flag.

<Code>
```javascript
const Ably = require('ably');

async function sendResponseToChat(envelopeData, responseText) {
  // Extract the room name from the channel name
  const channelName = envelopeData.channel; // e.g., "chat:support::$chat"
  const roomName = channelName.replace('::$chat', ''); // e.g., "chat:support"

  // Initialize Chat client and get the room
  const chatClient = new Ably.Chat(realtime);
  const room = await chatClient.rooms.get(roomName);

  // Send response message skipping all integration rules
  await room.messages.send({
    text: responseText
  }, {
    extras: {
      privileged: {'
        skipRule: [ruleIdToSkip]  // To skip all rules use '*' instead of an array
      }
    }
  });
}
```
</Code>

The rule ID is available in the integration webhook envelope's `ruleId` field, or you can find it in your Ably [dashboard](https://ably.com/dashboard) under Integrations.

## Best practices for production

When building production-ready integrations, follow these best practices:

### Error handling and resilience

* **Retry logic:** Implement exponential backoff for failed external API calls to handle transient failures gracefully
* **Circuit breakers:** Prevent cascading failures by temporarily stopping requests to failing external services
* **Timeouts:** Set appropriate timeouts for external API calls to avoid indefinite blocking
* **Graceful degradation:** Design your system to handle external service failures without breaking the entire integration
* See [Ably's architecture documentation](/docs/platform/architecture/fault-tolerance) for resilience patterns

### Idempotency

* **Message deduplication:** Track processed message IDs to safely handle Ably's [at-least-once delivery](/docs/platform/architecture/idempotency#protocol-support-for-exactly-once-delivery)
* **Idempotent operations:** Design your external system operations to be safely retryable
* **Cleanup strategy:** Implement cleanup for tracked message IDs to prevent memory leaks (LRU cache, TTL-based cleanup)

### Rate limiting and caching

* **Cache responses:** Cache frequent external API responses to reduce latency and costs
* **Rate limits:** Respect external service rate limits with throttling and queuing
* **Batching:** Consider batching multiple operations to reduce external API calls
* **CDN integration:** Use CDNs for static content enrichment (images, metadata)

### Security

* **Webhook signatures:** Always validate webhook signatures using Ably's provided signature headers
* **Token authentication:** Use short-lived [JWT tokens](/docs/auth/token#jwt) with minimal capabilities for client connections
* **API key security:** Never embed API keys in client code; use server-side endpoints to generate tokens
* **TLS/HTTPS:** Ensure all connections use TLS encryption
* **Secret management:** Store API keys and secrets in secure management systems (AWS Secrets Manager, Azure Key Vault, etc.)
* See [Ably's authentication documentation](/docs/auth) for security best practices

### Monitoring and observability

* **[Meta channel](/docs/metadata-stats/metadata/subscribe) monitoring:** Subscribe to `[meta]log:integration` to track integration errors
* **Dead letter queues:** Monitor [dead letter queues](/docs/platform/integrations/queues#deadletter) if using Ably Queues
* **Metrics tracking:** Monitor error rates, latency, throughput, and external service response times
* **Alerting:** Set up alerts for integration failures, queue depth issues, and performance degradation
* **Logging:** Implement structured logging with correlation IDs for debugging

## Production checklist

Before deploying your integration to production, verify:

- [ ] Integration rule filters correctly match target channels
- [ ] External system authenticated and authorized properly
- [ ] Response messages configured to avoid infinite loops (separate channels or privileged skipRule)
- [ ] API key has `privileged-headers` capability if using skipRule feature
- [ ] Error handling and logging implemented
- [ ] Retry logic and exponential backoff in place
- [ ] Monitoring and alerting configured
  - [ ] Subscribe to `[meta]log` channel
  - [ ] Track error rates and latency
  - [ ] Monitor queue depths (if using queues)
  - [ ] Alert on dead letter queue messages
- [ ] Load tested at expected scale (+ 50% buffer)
- [ ] Cost estimation validated based on message volume
- [ ] Security review completed
  - [ ] No API keys embedded in client code
  - [ ] TLS/HTTPS enabled for all connections
  - [ ] Webhook signatures validated
  - [ ] Secrets stored in secure management system
- [ ] Idempotency handling implemented
- [ ] Documentation for your team on how integration works
- [ ] Rollback plan prepared in case of issues
- [ ] Test in staging environment before production

## Next steps

Explore related documentation to deepen your integration knowledge:

* [Chat SDK documentation](/docs/chat) - Comprehensive guide to Ably Chat features
* [Platform Integrations](/docs/platform/integrations) - Detailed setup for webhooks, queues, and streaming
* [Chat Integrations](/docs/chat/integrations) - Technical reference for Chat message structure
* [Export Chat Data](/docs/guides/chat/export-chat) - Guide for storing all chat messages long-term
* [Architecture Overview](/docs/platform/architecture) - Learn how Ably achieves scale and reliability
* [Authentication](/docs/auth) - Security best practices for production apps
* [Chat Moderation](/docs/chat/moderation) - Filter and moderate chat content

For custom integration requirements or questions, [contact Ably support](https://ably.com/support).
