---
title: "Extract messages via integrations"
meta_description: "Extract chat messages from Ably Chat using integrations for external processing, storage, or analysis."
meta_keywords: "chat integrations, message extraction, webhooks, streaming, queues, message processing, chat data"
---

Extract chat messages from Ably Chat rooms to external systems using Ably's integration capabilities. This enables you to process, store, or analyze messages outside of Ably Chat while maintaining realtime message delivery to chat participants.

Chat rooms are built on Ably Pub/Sub channels, allowing you to leverage the full range of Ably's [platform integrations](/docs/platform/integrations) to forward messages to external systems.

## Integration methods <a id="methods"/>

Ably provides three primary methods for extracting chat messages:

1. **[Webhooks](#webhooks)** - Forward messages to [HTTP endpoints](/docs/platform/integrations/webhooks/generic), [AWS Lambda](/docs/platform/integrations/webhooks/lambda), [Google Cloud Functions](/docs/platform/integrations/webhooks/gcp-function), [Cloudflare Workers](/docs/platform/integrations/webhooks/cloudflare), and more
2. **[Queues](#queues)** - Route messages to [Ably-managed queues](/docs/platform/integrations/queues) for consumption by your services
3. **[Streaming](#streaming)** - Stream messages to external systems like [Kafka](/docs/platform/integrations/streaming/kafka), [Kinesis](/docs/platform/integrations/streaming/kinesis), [SQS](/docs/platform/integrations/streaming/sqs), [AMQP](/docs/platform/integrations/streaming/amqp), or [Pulsar](/docs/platform/integrations/streaming/pulsar)

Each method offers different trade-offs in terms of simplicity, reliability, and infrastructure requirements.

## Filtering rooms <a id="filtering"/>

Integration rules can be configured to match and forward messages from specific chat rooms based on channel name patterns. This enables you to configure any number of integration rules for different use cases and apply them to relevant rooms.

### Setting up filters <a id="filter-setup"/>

When configuring an integration rule in your Ably dashboard:

* **Channel filter**: Use a regular expression to match room names. For example, `^support:.*` matches all rooms starting with `support:`
* **Event type**: Use `channel.message` to forward chat messages and exclude presence events
* **Enveloped messages**: Enable to receive full message metadata including `serial`, `version`, and `headers`

### Example filter configuration

<Code>
```javascript
// Room name: support:ticket-123
// Filter pattern: ^support:.*
// Result: Messages from support:ticket-123 will be forwarded
const supportRoom = await chatClient.rooms.get('support:ticket-123');
await supportRoom.messages.send({ text: 'Help needed' }); // Will trigger integration
```
</Code>

## Understanding channel names and room names <a id="channel-names"/>

Chat rooms are underpinned by Ably Pub/Sub channels with a `::$chat` suffix added to form the full channel name. When using the Chat SDK to create or get a room, this is done automatically - you don't need to include the suffix yourself.

Integration rules match against the full channel name, but you don't need to include the `::$chat` suffix in your filter pattern.

<Code>
```javascript
// Get a chat room - the room name becomes the channel name with ::$chat suffix
const supportRoom = await chatClient.rooms.get('chat:support');
// Underlying channel: chat:support::$chat

// Messages sent to these rooms will trigger an integration
// if your rule's channel filter is: ^chat:support.*
await supportRoom.messages.send({ text: 'Need help' });

// Messages sent to other channel patterns will NOT trigger the integration
const generalRoom = await chatClient.rooms.get('chat:general');
// Underlying channel: chat:general::$chat
await generalRoom.messages.send({ text: 'Hi' }); // Won't trigger if filter is ^chat:support.*
```
</Code>

## Decoding messages <a id="decoding"/>

Messages received through integrations are encoded as Ably Pub/Sub messages and need to be decoded into Chat messages. The Ably-js SDK exposes [functions](#decode-data) you can use to handle this, or you can see the page on [chat integrations](/docs/chat/integrations) for more details on how to manually decode messages.
By default, these messages are sent in an envelope containing additional structured metadata, such as the channel name, app ID, and rule ID.

### Understanding enveloped messages <a id="envelope"/>

With enveloping enabled (recommended), messages arrive wrapped in useful metadata:

<Code>
```javascript
{
  "source": "channel.message",
  "appId": "your-app-id",
  "channel": "support:ticket-123::$chat",
  "ruleId": "integration-rule-id",
  "messages": [
    {
      "id": "unique-message-id",
      "clientId": "user-123",
      "name": "chat.message",
      "timestamp": 1234567890,
      "serial": "01765820788939-000@108wgxjJwBwuAB37648671:000",
      "action": 0,
      "data": {
        "text": "Message content",
        "metadata": {}
      },
      "extras": {
        "headers": {}
      }
    }
  ]
}
```
</Code>

### Extracting the room name <a id="extract-room"/>

The enveloped payload contains the underlying channel name from which the contained messages originated. To get the corresponding room name, remove the `::$chat` suffix from the string value of the `channel` field:

<Code>
```javascript
function extractRoomName(channelName) {
  // channelName: "support:ticket-123::$chat"
  return channelName.replace('::$chat', ''); // Returns: "support:ticket-123"
}
```
</Code>

This room name can then be used to interact with the Chat SDK and REST API as needed.

### Decoding message data <a id="decode-data"/>

You can use the Ably SDK to decode messages from the envelope:

<Code>
```javascript
const Ably = require('ably');

function decodeMessages(envelopeData) {
  const decodedMessages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  return decodedMessages.map(msg => ({
    serial: msg.serial,
    text: msg.data?.text,
    metadata: msg.data?.metadata || {},
    headers: msg.extras?.headers || {},
    clientId: msg.clientId,
    timestamp: msg.timestamp,
    action: msg.action,
    versionSerial: msg.version?.serial || msg.serial
    versionTimestamp: msg.version?.timestamp || msg.timestamp
  }));
}
```
</Code>

## Using metadata and headers <a id="metadata-headers"/>

Metadata and headers enable you to control how messages are processed by external systems and add context for integration logic.

### Metadata

Message [`metadata`](/docs/chat/rooms/messages#structure) is set by the client when sending a message. Use metadata for storing JSON-serializable structured data relevant to your application logic.

For example, if triggering some notification process from a particular client, you might include user or intent information in the metadata:

<Code>
```javascript
// Client sends message with metadata
await room.messages.send({
  text: '@john.123 Hey, how are you?',
  metadata: {
    targetClientId: 'User123',
    type: 'mention',
    location: 'London',
    language: 'en',
  }
});
```
</Code>

**Important:** Metadata is not server-validated. Always treat it as untrusted user input in your integration code.

### Headers

Message [`headers`](/docs/chat/rooms/messages#structure) can be set by the client when sending a message, similar to metadata. However, they are more typically used for [filtering](/docs/pub-sub/advanced#filter-subscribe) subscriptions and routing for integrations.

For example, you might include headers to indicate the type of processing required by your integration:

<Code>
```javascript
// Client sends message with headers
await room.messages.send({
  text: '@john.123 Hey, how are you?',
  metadata: {
    targetClientId: 'john.123',
    type: 'mention
    location: 'London',
    timestamp: Date.now()
  },
  headers: {
    'x-intent': 'notification',
    'x-priority': 'high'
  }
});
```
</Code>

#### Adding headers at the rule level

When configuring an integration rule in your Ably dashboard, you can specify headers to be added when the rule triggers. This allows you to attach additional metadata to messages only when they match your integration criteria.

These rule-level headers are added after the client publishes the message, so they appear in the enveloped message received by your integration endpoint but not in the original message stored in chat history. They will also not be visible to other chat clients.

**Important:** Carefully validate and sanitize all data in your integration code before using it for business logic or security decisions.

## Message ordering and versioning <a id="versioning"/>

Chat message `serial` and `version.serial` fields are [globally unique and lexicographically sortable](/docs/chat/rooms/messages#global-ordering) strings that enable you to correctly order chat messages even when they arrive out of sequence.
Together with the `action` field, these properties allow you to handle message creation, updates, and deletions in the correct order.

* **`serial`**: Unique identifier for the original message (remains constant across all versions)
* **`version.serial`**: Identifier for a specific message version (only populated for updated or deleted messages)
* **`action`**: Indicates message type (`message.created`, `message.updated`, `message.deleted`, or `message.summary` for reactions)

When receiving messages through integrations, `version.serial` will only be present if the message has been updated or deleted (i.e., `action` is not `message.created`).

### Determining message order <a id="handle-versions"/>

Use `serial` and `version.serial` fields to determine the correct order of messages and apply updates or deletions appropriately:

* **Comparing different messages**: Compare `serial` fields to determine which message was sent first. A lexicographically higher `serial` value indicates a newer message.
* **Comparing versions of the same message**: When both messages have the same `serial` (indicating different versions of the same message), compare `version.serial` values to determine which version is newer. A lexicographically higher `version.serial` indicates a more recent update or delete operation.

### Handling out-of-order delivery

Messages may arrive out of order due to network conditions, retry logic, or when consuming from multiple integration sources. To handle this correctly:

1. Check if `message.serial === storedMessage.serial` to identify if they're the same message
2. If the serials match, compare `message.version.serial > storedMessage.version.serial` to see if the incoming version is newer
3. Only process the update or delete if the incoming version is newer than what you have stored

This approach ensures you always maintain the most recent version of each message, regardless of delivery order.

Read more about [message versioning and sorting](/docs/chat/rooms/messages#ordering-update-delete) in the messages documentation.

## Using webhooks <a id="webhooks"/>

[Outbound webhooks](/docs/platform/integrations/webhooks) enable you to forward messages to HTTP endpoints or serverless functions.

Webhooks are the simplest integration method to implement, requiring no additional infrastructure beyond your webhook endpoint or serverless function. They provide automatic retry handling with configurable retry windows, and messages can be batched together to reduce invocation overhead.

### Setup

Configure a webhook integration in your Ably dashboard pointing to your endpoint. See the following for platform-specific setup guides:

* [Generic HTTP webhook](/docs/platform/integrations/webhooks/generic) - Forward to any HTTP/HTTPS endpoint
* [AWS Lambda](/docs/platform/integrations/webhooks/lambda) - Trigger Lambda functions
* [Google Cloud Functions](/docs/platform/integrations/webhooks/gcp-function) - Invoke GCP functions
* [Cloudflare Workers](/docs/platform/integrations/webhooks/cloudflare) - Trigger Workers
* [General webhook documentation](/docs/platform/integrations/webhooks) - Overview and other platforms


### Considerations

* **Retry behavior**: For Lambda, AWS automatically retries failed invocations up to two times with delays (1 minute, then 2 minutes). For generic HTTP webhooks, Ably retries for a limited window.
* **Ordering**: Messages may arrive out-of-order; use `serial` and `version.serial` to sort.
* **Message Loss**: Messages may be dropped if retries exceed the retry window.
* **Deduplication**: Handle potential duplicates using message serials - webhooks provide at-least-once delivery.
* **Monitoring**: Use [`[meta]log` channel](/docs/metadata-stats/metadata/subscribe#log) to detect failures (see [monitoring section](#monitoring-performance)).

### Example webhook handler

<Code>
```javascript
async function handleWebhook(req, res) {
  const envelope = req.body;
  const roomName = extractRoomName(envelope.channel);
  const messages = decodeMessages(envelope);

  for (const message of messages) {
    await processMessage(roomName, message);
  }

  res.status(200).send('OK');
}
```
</Code>

## Using queues <a id="queues"/>

[Ably Queues](/docs/platform/integrations/queues) are traditional message queues that enable you to consume, process, or store chat messages from your servers.

Ably Queues provide fault-tolerant message delivery with at-least-once delivery guarantees. Messages persist during consumer downtime up to queue limits, and a dead letter queue automatically captures dropped messages for monitoring and recovery.

### Setup

Configure an Ably queue integration in your dashboard:

1. [Provision a queue](/docs/platform/integrations/queues#provision) with your desired region, TTL, and max length settings
2. [Create a queue rule](/docs/platform/integrations/queues#config) to route chat messages to the queue
3. Consume messages using [AMQP](/docs/platform/integrations/queues#amqp) or [STOMP](/docs/platform/integrations/queues#stomp) protocols

See [Ably queues](/docs/platform/integrations/queues) for complete setup details.

### Considerations

* **Queue limits**: Default maximum is 10,000 messages. Monitor queue length during peak times to avoid reaching capacity
* **TTL**: Messages expire after 60 minutes (default/max) if not consumed
* **Dead letter queue**: Automatically provisioned. Always consume to monitor for dropped or expired messages
* **Throughput**: Multi-tenanted queues support up to 200 messages/second per account. For higher volumes, consider [dedicated queues or streaming](/docs/platform/integrations/queues#scalability)
* **Ordering**: Messages maintain order per channel with a single consumer. Multiple consumers or multi-channel messages may affect ordering

### Example queue consumer (AMQP)

<Code>
```javascript
const amqp = require('amqplib');

// Queue name format: APPID:queue-name
const queueName = 'your-app-id:chat-messages';
// Avoid hardcoding credentials in production
const url = 'amqps://APPID.KEYID:SECRET@us-east-1-a-queue.ably.io/shared';

amqp.connect(url, (err, conn) => {
  if (err) { return console.error(err); }

  conn.createChannel((err, ch) => {
    if (err) { return console.error(err); }

    // Subscribe to the queue
    ch.consume(queueName, (item) => {
      const envelope = JSON.parse(item.content);
      const roomName = extractRoomName(envelope.channel);

      // Decode messages using Ably SDK
      const messages = Ably.Realtime.Message.fromEncodedArray(envelope.messages);

      messages.forEach(async (message) => {
        await processMessage(roomName, message);
      });

      // Acknowledge message to remove from queue
      ch.ack(item);
    });
  });
});
```
</Code>

### Monitor the dead letter queue <a id="dead-letter-queue"/>

Ably automatically provisions a [dead letter queue](/docs/platform/integrations/queues#deadletter) when you create a queue. Messages are moved to the dead letter queue when they:

* Are rejected by consumers (`basic.reject` or `basic.nack` with `requeue=false`)
* Exceed their TTL and expire
* Cause the queue to reach maximum capacity (oldest messages dropped)

**Important:** Monitor your dead letter queue to detect processing failures and capacity issues.

<Code>
```javascript
async function monitorDeadLetterQueue(appID) {
  // Dead letter queue name format: APPID:deadletter
  const dlqName = `${appID}:deadletter`;
  // Avoid hardcoding credentials in production
  const url = 'amqps://APPID.KEYID:SECRET@us-east-1-a-queue.ably.io/shared';

  amqp.connect(url, (err, conn) => {
    if (err) { return console.error(err); }

    conn.createChannel((err, ch) => {
      if (err) { return console.error(err); }

      ch.consume(dlqName, (item) => {
        const envelope = JSON.parse(item.content);
        console.error('Message dropped from queue:', envelope);

        // Handle failed message (alert, retry, etc.)
        handleFailedMessage(envelope);

        ch.ack(item);
      });
    });
  });
}
```
</Code>

**Note:** Only one dead letter queue exists per Ably application, shared across all queues.

## Using streaming <a id="streaming"/>

[Outbound streaming](/docs/platform/integrations/streaming) enables you to stream a constant flow of chat messages to external streaming or queueing services.

Streaming integrations enable you to leverage your existing streaming infrastructure with full control over retention and processing, providing massive scale capabilities for high-volume message flows.

### Setup

Configure streaming to your target system. See the following for platform-specific setup:

* [Apache Kafka](/docs/platform/integrations/streaming/kafka) - Stream to Kafka topics
* [AWS Kinesis](/docs/platform/integrations/streaming/kinesis) - Stream to Kinesis streams
* [AWS SQS](/docs/platform/integrations/streaming/sqs) - Stream to SQS queues
* [AMQP](/docs/platform/integrations/streaming/amqp) - Stream to AMQP brokers
* [Apache Pulsar](/docs/platform/integrations/streaming/pulsar) - Stream to Pulsar topics
* [General streaming documentation](/docs/platform/integrations/streaming) - Overview and configuration


### Considerations

* **Infrastructure**: You manage and maintain the streaming system
* **Reliability**: Messages lost if system unavailable
* **Complexity**: Higher operational overhead

### Example Kafka consumer

<Code>
```javascript
const { Kafka } = require('kafkajs');

async function consumeFromKafka() {
  const consumer = kafka.consumer({ groupId: 'chat-processor' });
  await consumer.connect();
  await consumer.subscribe({ topic: 'ably-chat-messages' });

  await consumer.run({
    eachMessage: async ({ message }) => {
      const envelope = JSON.parse(message.value);
      const roomName = extractRoomName(envelope.channel);
      const decoded = decodeMessages(envelope);

      await processMessages(roomName, decoded);
    }
  });
}
```
</Code>

## Monitoring integration performance <a id="monitoring-performance"/>

Monitor the health and performance of your integrations in realtime using Ably's [metachannels](/docs/metadata-stats/metadata/subscribe). Metachannels provide app-level metadata about integrations, statistics, and errors.

### Monitor integration errors <a id="monitor-errors"/>

The [`[meta]log` channel](/docs/metadata-stats/metadata/subscribe#log) publishes error events from integrations in realtime. This enables you to detect and respond to integration failures as they occur.

Subscribe to the `[meta]log` channel to receive error events:

<Code>
```javascript
const Ably = require('ably');
const client = new Ably.Realtime({ key: 'YOUR_API_KEY' });

const metaLogChannel = client.channels.get('[meta]log');

await metaLogChannel.subscribe((message) => {
  if (message.data.error) {
    alertOperationsTeam(message.data);
  }
});
```
</Code>

Integration error logs will contain a `tag` field as part of the `data` payload, indicating the integration type - for example, `reactor.generic.http`, for webhooks. This allows you to filter and categorize errors by integration method.

**Note:** The `[meta]log` channel only publishes errors that cannot be directly reported to clients. For example, webhook delivery failures or queue publishing errors.

### Monitor app statistics <a id="monitor-stats"/>

The [`[meta]stats:minute` channel](/docs/metadata-stats/metadata/subscribe#stats) publishes [app-level statistics](/docs/metadata-stats/stats) every minute. Use these statistics to monitor integration throughput, message volumes, and resource usage.

Subscribe to receive [statistics](docs/metadata-stats/stats#outbound) updates:

<Code>
```javascript
const statsChannel = client.channels.get('[meta]stats:minute');

await statsChannel.subscribe('update', (event) => {
  const stats = event.data.entries;

  // Monitor integration-specific metrics
  console.log('Integration stats:', {
    webhooks: stats['messages.outbound.webhook.messages.count'] || 0,
    queues: stats['messages.outbound.sharedQueue.messages.count'] || 0,
    // Add other metrics as needed
  });

  // Alert on anomalies
  if (stats['messages.outbound.webhook.all.failed'] > threshold) {
    alertOnWebhookFailures(stats);
  }
});
```
</Code>

Use the [rewind channel option](/docs/channels/options/rewind) to retrieve the most recent statistics immediately:

<Code>
```javascript
// Get the last statistics event plus subscribe to future updates
const statsChannel = client.channels.get('[meta]stats:minute', {
  params: { rewind: '1' }
});

statsChannel.subscribe('update', (event) => {
  console.log('Stats:', event.data.entries);
});
```
</Code>

### Integration monitoring best practices <a id="monitoring-best-practices"/>

* **Subscribe to both channels**: Use `[meta]log` for error detection and `[meta]stats:minute` for performance monitoring
* **Set up alerting**: Create automated alerts for integration failures or throughput anomalies
* **Track trends**: Store statistics over time to identify patterns and capacity planning needs
* **Filter by integration type**: Use the statistics entries to monitor specific integration methods (webhooks, queues, streaming)
* **Correlate with external logs**: Use `requestId` from error events to correlate with your system logs

See [metadata subscriptions documentation](/docs/metadata-stats/metadata/subscribe) for complete details on available metachannels.

## Handling message reactions <a id="reactions"/>

Message reactions are delivered as separate events with `action: 'message.summary'`.

### Reaction summary structure

<Code>
```javascript
{
  "action": "message.summary",
  "serial": "original-message-serial",
  "annotations": {
    "summary": {
      "reaction:unique.v1": {
        "üëç": { "count": 5 },
        "‚ù§Ô∏è": { "count": 3 }
      }
    }
  }
}
```
</Code>

### Processing reactions

<Code>
```javascript
function processMessage(message) {
  if (message.action === 'message.summary') {
    // Handle reaction summary
    const reactions = message.annotations?.summary?.['reaction:unique.v1'] || {};
    updateReactionCounts(message.serial, reactions);
    return;
  }

  // Handle regular message
  saveMessage(message);
}
```
</Code>

Read more about [message reactions](/docs/chat/rooms/message-reactions) and the [reactions annotation mapping](/docs/chat/integrations#how-to-handle-message-reactions).
