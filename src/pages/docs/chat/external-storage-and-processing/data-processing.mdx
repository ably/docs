---
title: "Process messages with external systems"
meta_description: "Process chat messages through external systems to trigger notifications, handle slash commands, analyze sentiment, moderate content, and more."
meta_keywords: "chat processing, message processing, notifications, slash commands, sentiment analysis, chat automation, webhooks"
---

You can process chat messages through external systems like notification services, analytics platforms, or AI tools to build powerful features. By extracting message data and metadata, you can trigger notifications, execute slash commands, analyze sentiment, moderate content, and more.

## Why process messages with external systems? <a id="why-process"/>

Integrating external systems with Ably Chat enables you to extend your chat application beyond simple message delivery:

* **AI-powered assistance**: Process commands or questions through language models and respond with helpful information
* **Real-time translation**: Automatically translate messages for multilingual chat rooms
* **Sentiment analysis**: Analyze the emotional tone of messages to gauge user or group sentiment
* **Notifications**: Detect mentions or keywords and trigger custom notification systems
* **Workflow automation**: Trigger external business processes based on chat activity
* **Command processing**: Handle slash commands that invoke server-side logic

## Understanding the processing flow <a id="integration-flow"/>

The typical message processing flow works as follows:

1. A user sends a message to a chat room, optionally including [metadata or headers](#metadata-headers) for processing context
2. An integration rule evaluates the message based on room name pattern matching
3. If the rule matches, Ably forwards the message to your external system
4. Your external system processes the message and extracts relevant data
5. Based on the message content or metadata, your system can trigger actions like sending notifications, logging events, or analyzing sentiment

## Choosing an integration method <a id="implementation-options"/>

Ably provides several different integration methods, each suited to different use cases.

### Webhooks

[Outbound webhooks](/docs/platform/integrations/webhooks) are ideal for simple business logic and event-driven actions, particularly for processing @mentions or triggering custom notifications, executing lightweight business logic (lookup, validation, etc.), and serverless architectures (AWS Lambda, Cloud Functions, etc.).

**Learn more:** See [Extract messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#webhooks) for setup details and code examples.

### Streaming

[Outbound streaming](/docs/platform/integrations/streaming) enables massive scale and integration with existing infrastructure, making it ideal for high-throughput scenarios (large-scale chats, millions of messages), existing streaming infrastructure (Kafka, Kinesis, etc.), and complex data pipelines and analytics.

**Learn more:** See [Extract messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#streaming) for setup details and code examples.

### Ably Queues

[Ably Queues](/docs/platform/integrations/queues) provide strict ordering and fault-tolerant delivery, making them ideal for automated support flows where message order matters, processing sequential events (game moves, transaction steps), and fault-tolerant message processing with automatic retries.

**Learn more:** See [Extract messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#queues) for setup details and code examples.

## Using metadata for structured content <a id="metadata-headers"/>

Clients can provide context for your external services to use while processing by adding data in the [`metadata`](/docs/chat/external-storage-and-processing/data-extraction#metadata-headers) field. For example, when implementing a notification system, you might include the target user ID and notification type:

<Code>
```javascript
// Client sends message with metadata
await room.messages.send({
  text: '@john.123 Can you review this?',
  metadata: {
    targetClientId: 'john.123',
    notificationType: 'mention'
  }
});
```
</Code>

You can then [extract](#decoding) the metadata in your integration to trigger business logic:

<Code>
```javascript
// use metadata in your integration to trigger notifications
const metadata = msg.data?.metadata || {};
if (metadata.notificationType === 'mention') {
  await sendNotification(metadata.targetClientId, {
    type: 'mention',
    text: msg.data.text,
    roomName: roomName
  });
}
```
</Code>

**Important:** Metadata is not server-validated. Always treat it as untrusted user input and validate it in your integration code.

## Processing messages in your integration <a id="processing"/>

When your integration receives messages, extract the message data, metadata, and headers to control processing logic.

<Code>
```javascript
const Ably = require('ably');

async function processIntegrationPayload(envelopeData) {
  // Decode messages using Ably SDK
  const decodedMessages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of decodedMessages) {
    // Extract text content
    const text = msg.data?.text;

    // Extract headers for routing
    const headers = msg.extras?.headers || {};
    const command = headers['x-command'];

    // Extract metadata for business context (treat as untrusted)
    const metadata = msg.data?.metadata || {};
    const notificationType = metadata.notificationType;

    // Extract room and user information
    const roomName = envelopeData.channel.replace('::$chat', '');
    const senderId = msg.clientId;

    // Route based on headers or metadata
    if (command === 'remind') {
      await handleRemindCommand(text, metadata.targetClientId, senderId);
    } else if (notificationType === 'mention') {
      await sendMentionNotification(metadata.targetClientId, text, roomName, senderId);
    }
  }
}
```
</Code>

For complete details on message decoding and structure, see the section on [extracting messages via integrations](/docs/chat/external-storage-and-processing/data-extraction#decoding).

## Example: Detecting @mentions for notifications <a id="example-mentions"/>

When users mention others in chat, you can detect these mentions and send notifications to the mentioned users.

### Client sends message with metadata

<Code>
```javascript
// Client detects @mention and includes metadata
await room.messages.send({
  text: '@john.123 Can you review this proposal?',
  metadata: {
    notificationType: 'mention',
    targetClientId: 'john.123'
  }
});
```
</Code>

### Integration processes and sends notification

<Code>
```javascript
const express = require('express');
const Ably = require('ably');

const app = express();
app.use(express.json());

app.post('/webhook', async (req, res) => {
  const envelope = req.body;
  const messages = Ably.Realtime.Message.fromEncodedArray(envelope.messages);

  for (const msg of messages) {
    const metadata = msg.data?.metadata || {};

    // Validate metadata (treat as untrusted user input)
    if (metadata.notificationType === 'mention' && metadata.targetClientId) {
      const roomName = envelope.channel.replace('::$chat', '');

      // Send notification via your notification service
      await sendPushNotification({
        userId: metadata.targetClientId,
        title: `New mention in ${roomName}`,
        body: msg.data.text,
        senderId: msg.clientId
      });
    }
  }

  res.status(200).send('OK');
});

app.listen(3000);
```
</Code>

## Example: Handling slash commands <a id="example-commands"/>

Process slash commands by using message headers to route to different command handlers. Commands can work naturally with @mentions in the message text.

### Client sends command with header

<Code>
```javascript
// Client sends a slash command with @mention
await room.messages.send(
  {
    text: '/remind @john.123 Review the proposal by EOD',
    metadata: {
      targetClientId: 'john.123'
    }
  },
  {
    extras: {
      headers: {
        'x-command': 'remind'
      }
    }
  }
);
```
</Code>

### Integration routes and processes command

<Code>
```javascript
async function processIntegrationPayload(envelopeData) {
  const messages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of messages) {
    const headers = msg.extras?.headers || {};
    const command = headers['x-command'];

    if (command === 'remind') {
      const metadata = msg.data?.metadata || {};

      // Extract reminder text (remove command and @mention)
      const reminderText = msg.data.text
        .replace(/\/remind\s+/, '')
        .replace(/@[\w.]+\s+/, '');

      // Schedule reminder via your reminder service
      await scheduleReminder({
        targetUserId: metadata.targetClientId,
        message: reminderText,
        fromUserId: msg.clientId,
        roomId: envelopeData.channel.replace('::$chat', ''),
        createdAt: msg.timestamp
      });

      // Log command usage for analytics
      await logCommandUsage({
        command: 'remind',
        userId: msg.clientId,
        targetUserId: metadata.targetClientId,
        timestamp: msg.timestamp
      });
    }
  }
}
```
</Code>

## Example: Sentiment analysis <a id="example-sentiment"/>

Analyze the emotional tone of messages to track conversation health or flag concerning content.

<Code>
```javascript
async function processIntegrationPayload(envelopeData) {
  const messages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of messages) {
    const text = msg.data?.text;

    // Analyze sentiment using your preferred service
    const sentiment = await analyzeSentiment(text);

    // Store sentiment data for analytics
    await storeSentimentData({
      roomId: envelopeData.channel.replace('::$chat', ''),
      userId: msg.clientId,
      messageId: msg.id,
      sentiment: sentiment.score, // e.g., -1 to 1
      timestamp: msg.timestamp
    });

    // Flag messages with very negative sentiment
    if (sentiment.score < -0.8) {
      await flagForModeration({
        roomId: envelopeData.channel.replace('::$chat', ''),
        messageId: msg.id,
        reason: 'negative_sentiment',
        severity: 'high'
      });
    }
  }
}
```
</Code>

## Key considerations <a id="key-considerations"/>

Consider the following when integrating external systems with Ably Chat:

* **Scale and reliability:** Different integration methods offer different reliability guarantees. See [choosing an integration method](#implementation-options) for guidance on webhooks, streaming, and queues
* **External system limitations:** Your external service may have rate limits, processing constraints, or availability issues. Implement retry logic, circuit breakers, and caching to handle these limitations gracefully
* **Cost optimization:** Only process messages that require processing. Use channel filters and metadata/headers to route messages efficiently
* **Security:** Always validate and sanitize client-provided metadata before using it in your integration logic. Treat all client-provided data as untrusted input. For sensitive operations like payment processing or moderation actions, make authorization decisions server-side based on user permissions and authentication context rather than trusting client-provided flags
* **Error handling:** Handle external system failures gracefully - consider fallback responses or queuing failed requests for retry
* **Privacy:** Be mindful of what message data you store or forward to external services. Consider data retention policies and user privacy requirements when processing chat messages
