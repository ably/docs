---
title: Channels
meta_description: "Channels are used to organize message traffic within Ably."
languages:
  - csharp
  - flutter
  - java
  - javascript
  - nodejs
  - objc
  - php
  - python
  - ruby
  - swift
  - go
redirect_from:
  - /rest/channels
  - /rest/versions/v1.1/channels
  - /rest/versions/v1.0/channels
  - /rest/versions/v0.8/channels
  - /rest/channels-messages
  - /rest/versions/v0.8/channels-messages
  - /rest/beta
  - /rest/batch
  - /realtime/channels
  - /realtime/versions/v1.1/channels
  - /realtime/versions/v1.0/channels
  - /realtime/versions/v0.8/channels
  - /realtime/channels-messages
  - /realtime/versions/v0.8/channels-messages
  - /core-features/channels
  - /core-features/versions/v1.1/channels
  - /core-features/pubsub
  - /core-features/versions/v1.1/pubsub
  - /general/channel-rules-namespaces
  - /general/versions/v1.1/channel-rules-namespaces
  - /general/versions/v1.0/channel-rules-namespaces
  - /general/versions/v0.8/channel-rules-namespaces
---

Channels are used to separate "messages":/channels/messages into different topics. They provide a way to implement the Publish-Subscribe (Pub/Sub) architectural pattern. Pub/Sub enables any number of publishers to publish messages to a channel, and any number of subscribers to be subscribed to a channel to receive them, with publishers and subscribers completely decoupled from one another.

Clients can subscribe to channels and publish messages using the realtime interface of an Ably SDK. Clients can only publish messages when using the REST interface.

<aside data-type='note'>
<ul><li>Channel names are case sensitive</li>
<li>They can't start with @[@ or @:@</li>
<li>They can't be empty</li>
<li>They can't contain newline characters</li></ul>
<p>While Ably doesn't limit the length of channel names, we recommend you keep them under 2048 characters, since some older browsers have trouble with long URLs.</p>
</aside>


h2(#namespaces). Channel namespaces

Channel namespaces enable channels to be grouped together based on a prefix that is included as part of the channel name. A colon @:@ is used to delimit a channel namespace, that is, a namespace is the first segment of a channel name up until the first colon. If a channel name does not contain a colon, the namespace is the entire channel name.

The following are examples of channels that are all part of the 'customer' namespace:

* @customer@
* @customer:tracking-id@
* @customer:order:update@

Namespaces can be used to apply operations to all channels within the namespace, such as "capabilities":/auth/capabilities, "channel rules":#rules and "integration rules":/general/integrations. Namespaces are not required to refer to a set of channels within a capability. A resource specifier, such as @foo:*@, a glob expression, will match a channel named @foo:bar@, even without a @foo@ namespace.

<aside data-type='note'>
In addition to the restrictions on channel names above, a namespace cannot contain the wildcard character @*@.
</aside>

h2(#attach). Attach to a channel

Attaching to a channel ensures that it is created in the Ably system and that all messages published on the channel are received by any channel listeners registered by calling "subscribe()":/api/realtime-sdk/channels#subscribe. Ably will start to stream messages to a client as soon as they have attached, regardless of whether or not they have yet subscribed. Attach is only available to the realtime interface.

Channels are not pre-configured or provisioned by Ably in advance. They are created on demand when clients attach, and remain active until such time that there are no remaining attached clients.

Note that "@attach()@":/api/realtime-sdk/channels#attach can be called explicitly, however it's more common for a client to "subscribe":#subscribe, which will automatically initiate the attach.

The following example explicitly attaches to a channel, which results in the channel being provisioned in Ably's global realtime cluster. This channel will remain available globally until there are no more clients attached to the channel:

```[realtime_javascript]
const channel = realtime.channels.get('chatroom');
await channel.attach();
```

```[realtime_nodejs]
const channel = realtime.channels.get('chatroom');
await channel.attach();
```

```[realtime_ruby]
realtime.channels.get('chatroom').attach do |channel|
  puts "'chatroom' exists and is now available globally in every datacenter"
end
```

```[realtime_python]
channel = realtime.channels.get('chatroom')
await channel.attach()
print("'chatroom' exists and is now available globally in every datacenter")
```

```[realtime_java]
Channel channel = realtime.channels.get("chatroom");
channel.on(new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelStateChange state) {
    switch (state.current) {
      case attached: {
        System.out.println("'chatroom' exists and is now available globally");
      }
    }
  }
});
```

```[realtime_csharp]
IRealtimeChannel channel = realtime.Channels.Get("chatroom");
channel.Attach((success, error) => {
  Console.WriteLine("'chatroom' exists and is now available globally");
});
```

```[realtime_objc]
[[realtime.channels get:@"chatroom" options:options] attach:^(ARTErrorInfo *error) {
  NSLog(@"'chatroom' exists and is now available globally in every datacenter");
}];
```

```[realtime_swift]
realtime.channels.get("chatroom").attach { error in
  print("'chatroom' exists and is now available globally in every datacenter")
}
```

```[realtime_flutter]
final channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
final channelMessageSubscription = channel
    .on()
    .listen((ably.ChannelStateChange state) {
  switch (state.current) {
    case ably.ChannelState.attached: {
      print("'chatroom' exists and is now available globally");
      break;
    }
    default:
      break;
  }
});
```

```[realtime_go]
channel := realtime.Channels.Get("channelName")
channel.Attach(context.Background())
```

h3(#detach). Detach from a channel

A client can detach from a channel so that it no longer receives any messages published to that channel. Detaching is different to unsubscribing from a channel because "@unsubscribe()@":/api/realtime-sdk/channels#unsubscribe is a client-side operation. The Ably platform does not know that a client has unsubscribed and will continue to stream messages to that client until "@detach()@":/api/realtime-sdk/channels#detach is called.

A channel will automatically close when all of the following criteria are met:

* There are no more realtime clients attached to it
* Approximately one minute has passed since the last client detached
* Approximately one minute has passed since the last message was published to the channel

The following is an example of detaching from a channel:

```[realtime_javascript]
const channel = realtime.channels.get('chatroom');
await channel.detach();
```

```[realtime_nodejs]
const channel = realtime.channels.get('chatroom');
await channel.detach();
```

```[realtime_ruby]
channel.detach
channel.on(:detached) do |channel_state_change|
  puts "detached from the channel #{channel.name}"
end
```

```[realtime_python]
await channel.detach()
```

```[realtime_java]
channel.on(ChannelEvent.detached, new ChannelStateListener() {
    @Override
    public void onChannelStateChanged(ChannelStateChange stateChange) {
        System.out.println("Detached from the channel " + channel.name);
        if (stateChange.reason != null) {
            System.out.println(stateChange.reason.toString());
        }
    }
});

channel.detach();
```

```[realtime_csharp]
Channel.Detach();
channel.On(ChannelEvent.Detached, stateChange => {
  Console.WriteLine("detached from the channel " + channel.Name)
});
```

```[realtime_objc]
[channel detach]
[channel on:ARTChannelEventDetached callback:^(ARTChannelStateChange *stateChange) {
  NSLog(@"detached from the channel ", channel.name);
}];
```

```[realtime_swift]
channel.detach()
channel.on(.detached) { stateChange in
  print("detached from the channel \(channel.name)")
}
```

```[realtime_flutter]
channel.detach();
final stateChangeListener = channel
    .on(ably.ChannelEvent.detached)
    .listen((ably.ChannelStateChange state) {
  print('detached from the channel ${channel.name}');
});
```

```[realtime_go]
channel := realtime.Channels.Get("channelName")
channel.Detach(context.Background())
```

h3(#batch-publish). Batch publish

It is possible to publish messages to multiple channels with a single request. A batch request queries an API multiple times with single HTTP request. A batch request has a single set of request details containing the request body, parameters and headers. These are converted into an array of requests to the underlying API. Each individual request to the underlying API is performed in parallel and may succeed or fail independently.

The following is an example of a batch publish request using the "@request()@":/api/rest-sdk#request method to query the "batch REST API":/api/rest-api#batch-publish

```[rest_javascript]
const ablyRest = new Ably.Rest({ key: '{{API_KEY}}' })
const content = { 'channels': [ 'test1', 'test2' ], 'messages': { 'data': 'myData' } }
const batchPublish = await ablyRest.request('post', '/messages', null, content, null);

console.log('Success! status code was ' + batchPublish.statusCode)
```

```[rest_python]
ably_rest = AblyRest(key='{{API_KEY}}')

content = {
    "channels": ["test1", "test2"],
    "messages": {
        "data": 'myData'
    }
}

response = await ably_rest.request('POST', '/messages', body=content)

if response.is_success:
    print('Success! status code was', response.status_code)
else:
    print('An error occurred; err =', response.error_message)
```

```[rest_java]
ClientOptions options = new ClientOptions("{{API_KEY}}");
AblyRest ablyRest = new AblyRest(options);

JsonObject content = new JsonObject();
Gson gson = new Gson();

content.add("channels", gson.toJsonTree(new String[]{"test1", "test2"}));
JsonObject messages = new JsonObject();
messages.addProperty("data", "myData");
content.add("messages", messages);

final HttpCore.RequestBody body = HttpUtils.requestBodyFromGson(content, ablyRest.options.useBinaryProtocol);
HttpPaginatedResponse response = ablyRest.request("POST", "/messages", null, body, null);

System.out.println("Success! Status code was " + response.statusCode);
```

```[rest_php]
$rest = new Ably\AblyRest(
    ['key' => '{{API_KEY}}']
);
$content = ['channels' => ['test1', 'test2'], 'messages' => ['data' => 'myData']];
$batchPublish = $rest->request('POST', '/messages', [], $content);

echo('Success! status code was ' . $batchPublish->statusCode);
```

```[rest_go]
rest, err := ably.NewREST(
  ably.WithKey("{{API_KEY}}"),
)
if err != nil {
  log.Fatalf("Error creating Ably client: %v", err)
}

type Message struct {
  Data string `json:"data"`
}

type Content struct {
  Channels []string `json:"channels"`
  Messages Message  `json:"messages"`
}

// Create an instance of the Content structure
content := Content{
  Channels: []string{"test1", "test2"},
  Messages: Message{
    Data: "myData",
  },
}

response, err := rest.Request(
  "POST",
  "/messages",
  ably.RequestWithBody(content)).Pages(context.Background())

if err != nil {
  log.Fatalf("An error occurred; err = %v", err)
}
log.Printf("Success! status code was = %v", response.StatusCode())
```

h4(#batch-requests). Batch requests

Each batch publish request can contain a single @BatchSpec@ object, or an array of @BatchSpec@ objects. Each @BatchSpec@ object contains a single channel name or an array of channel names in the @channels@ property. The @messages@ property then contains a single message or an array of messages. Each @BatchSpec@ will then publish each of its messages to each of its channels.

For each channel, the messages grouped into a single @BatchSpec@ are published atomically. This means that:

* Either they will all be successfully published or none of them will
* The "max message size":/pricing/limits#message limit applies to the total size of all messages in in a @BatchSpec@
* Each @BatchSpec@ will only count as a single message for the purpose of the "per-channel rate limit":/pricing/limits#message

So if you do not need the atomicity guarantee and might be in danger of exceeding the max message size limit, you can put each message into its own @BatchSpec@ (relative ordering will still be preserved). Conversely, if you are publishing many hundreds of small messages and are in danger of exceeding the max per-channel message rate, you group them into a fewer @BatchSpecs@.

The batch request as a whole is subject to the following limits:

* Each request can only include 100 different channels. If the same channel name appears in multiple @BatchSpec@ objects within a single request, it only counts as one channel towards the 100 channel limit per batch request.
* Each request has a maximum body size of 2MiB.

The following is an example of a single @BatchSpec@ object publishing a single message to 2 channels:

```[text]
{
  channels: ['channel1', 'channel2'],
  messages: {data: 'My message contents'}
}
```

The following is an example of an array of @BatchSpec@ objects. The first publishes a single message to two channels and the second publishes two messages to a single channel:

```[text]
[
  {
    channels: ['channel1', 'channel2'],
    messages: {data: 'My message contents'}
  },
  {
    channels: 'channel3',
    messages: [
      {data: 'My message contents'},
      {name: 'an event', data: 'My event message contents'},
    ]
  }
]
```

The following is an example curl request, querying the "REST API":/api/rest-api#batch-publish directly:

```[sh]
curl -X POST https://rest.ably.io/messages \
    -u "{{API_KEY}}" \
    -H "Content-Type: application/json" \
    --data '{ "channels": [ "test1", "test2"],
"messages": {"data": "My test message text" } }'
```

h4(#batch-responses). Batch responses

Once all requests have been completed in a batch request, a batch response is returned with three possible outcomes:

- Success := If all of the individual requests were successful then an array containing the response of each query is returned in request order.
- Failure := If the batch request itself failed before the individual requests were made, then an error response is returned with a status code and error response body. Examples of why the batch request can fail include an authorization failure or an invalid request.
- Partial success := If one or more of the individual requests failed the response body contains an error object with the error code @40020@ and a status code of @400@. The error body contains a @batchResponse@ array of each individual response in request order. The @batchResponse@ can be inspected if there is a need to know the details of each outcome. If you only need to know whether or not the batch request was completely successful then the status code is sufficient.

The examples for each possible outcome will use the following @BatchSpec@ object as the request data:

```[text]
{
  channels: ['channel0', 'channel1', 'channel2'],
  messages: {data: 'My test message text'}
}
```

The following is an example of a successful batch publish response. The response body contains the @messageId@ of each published message and the @channel@ it was published to. The status code is @201@:

```[json]
[
  {
    "channel":"channel0",
    "messageId":"w234r5t-fr5"
  },
  {
    "channel":"channel1",
    "messageId":"vde4sfc0p"
  },
  {
    "channel":"channel2",
    "messageId":"nh3exv8ih"
  }
]
```

The following is an example of a batch publish failure response. The response body contains the details of the @error@, in this example that the token used for the request has expired. The status code is @401@:

```[json]
{
  "error": {
    "message":"Token expired",
    "statusCode":401,
    "code":40140
  }
}
```

The following is an example of a batch publish partial success response. The successful requests contain the @messageId@ of each published message and the @channel@ they were published to. The failed request contains the @channel@ the request failed for and the details of the @error@, in this example that the credentials used didn't have the capability to publish to that channel. The status code for a partial success is always @400@:

```[json]
{
  "error": {
    "message": "Batched response includes errors",
    "statusCode":400,
    "code":40020
  }
  "batchResponse": [
    {
      "channel":"channel0",
      "messageId":"w234r5t-fr5"
    },
    {
      "channel":"channel1",
      "messageId":"vde4sfc0p"
    },
    {
      "channel":"channel2",
      "error": {
        "message": "Given credentials do not have the required capability",
        "statusCode": 401,
        "code": 40160
      }
    }
  ]
}
```

h3(#server-side-batching). Server-side batching

Server-side batching optimizes message processing and delivery by grouping multiple messages into batches before sending them to subscribers. This feature reduces the overall message count, lowers costs, and mitigates the risk of hitting rate limits during high-throughput scenarios.

Server-side batching is currently in beta status.

h4. Key benefits

* Cost efficiency.
* Message rate limit mitigation.

h4. Use cases

The following use cases explain the benefits of server-side batching:

* *High-volume chat applications*
** Chat platforms experience large spikes in message volumes during live events like sports games or concerts. This scenario increases costs and risks hitting message rate limits.
** Server-side batching groups multiple chat messages and reactions into single batches before delivery, reducing the number of individual messages processed and maintaining a seamless user experience.
* *Fan engagement platforms*
** Sports fan apps see surges in reactions during key moments, like goals, causing spikes in message volume.
** Server-side batching combines multiple reactions into batches before sending them, managing high volumes efficiently and preventing rate limits from being exceeded.

h4. How server-side batching works

The server-side batching process works through a *batching policy* and a *batching interval:*

h5. Batching policy

The batching policy defines the rules and behaviors for aggregating messages during the batching interval. The supported *_simple_* policy groups multiple incoming messages into a single batch without altering their content or metadata.

A batch can contain up to 200 messages by count or total data size. For example, if you have 210 messages, they will be split into two batches: one with 200 messages and another with 10 messages. If the combined data size of 200 messages exceeds the batch data limit, the excess bytes will be allocated to a new batch as separate messages.

h5. Batching interval

The batching interval is a configurable period specified in milliseconds _ranging from 20ms to 1s_, during which incoming messages are collected and grouped into a batch. Messages sent to the server during this interval are temporarily held and aggregated. Once the interval elapses, the collected messages are combined into a single batch and delivered to subscribers as one message.

h5. Choose the right interval for your app

* Longer intervals are preferred for cost efficiency.
* Align the interval with the expected user experience.

h4. Configure server-side batching

The following steps take you through the server-side configuration process:

# On your "dashboard":https://ably.com/accounts/any, select one of your apps.
# Go to *settings*.
# Under "channel rules":#rules, add a *new rule*.
# Enter the *namespace* or *channel ID* to which you want to add a new rule.
# Select *server-side batching enabled*.
# Choose a batching policy (only *simple* is supported in beta).
# Choose an interval range value from 20ms to 1s.
# Click *create channel rule* to save.

h5. Configuration defaults

The following defaults apply when no configuration settings are specified:

# If no batching policy is specified, *simple* is used.
# If no interval value is specified, the default is 20ms.

h2(#options). Channel options

"Channel options":/channels/options can be used to customize the functionality of channels. This includes enabling features such as "encryption":/channels/options/encryption and "deltas":/channels/options/deltas, or for a client to retrieve messages published prior to it attaching to a channel using "rewind":/channels/options/rewind.

h2(#metadata). Channel metadata

"Metadata":/metadata-stats/metadata provides additional information about apps or channels. It includes uses such as enabling clients to be aware of how many other clients are attached to a channel without the need to use the "presence":/presence-occupancy/presence feature. Examples of channel metadata available include the status and occupancy of specific channels.

h2(#rules). Channel rules

Channel rules can be used to enforce settings for specific channels, or channel namespaces. They can be broadly categorized into three different types:

* For message storage
* For client security and identification
* To enable features for a channel or namespace

The channel rules related to message storage are:

- Persist last message := if enabled, the very last message published on a channel will be stored for a year. This message is retrievable using "rewind":/channels/options/rewind by attaching to the channel with @rewind=1@. If you send multiple messages in a single protocol message, for example calling @publish()@ with an array of messages, you would receive all of them as one message. Be aware that presence messages are not stored and that messages stored in this manner are not accessible using "history":/storage-history/history. Note that for each message stored using this rule, an additional message is deducted from your monthly allocation.
- Persist all messages := if enabled, all messages published on a channel will be stored according to the storage rules for your account. This is 24 hours for free accounts and 72 hours for paid accounts. Messages stored in this manner are accessible using "history":/storage-history/history. Note that for each message stored using this rule, an additional message is deducted from your monthly allocation.
- Server-side batching := if enabled, messages are grouped into batches before being sent to subscribers. "Server-side batching":#server-side-batching reduces the overall message count, lowers costs, and mitigates the risk of hitting rate limits during high-throughput scenarios.

The channel rules related to security and client identity are:

- Identified := if enabled, clients will not be permitted to use (including to attach, publish, or subscribe) matching channels unless they are "identified":/auth/identified-clients (they have an assigned client ID). Anonymous clients are not permitted to join these channels. Find out more about "authenticated and identified clients":/auth/identified-clients.
- TLS only := if enabled, only clients who have connected to Ably over TLS will be allowed to use matching channels. By default all of Ably's client libraries use TLS when communicating with Ably over REST or when using our Realtime transports such as Websockets.

The channel rules related to enabling features are:

- Push notifications enabled := If checked, publishing messages with a push payload in the @extras@ field is permitted. This triggers the delivery of a "Push Notification":/push to devices registered for push on the channel.
- Message interactions enabled := If enabled, messages received on a channel will contain a unique @timeserial@ that can be referenced by later messages for use with "message interactions":/channels/messages#interactions.

<!-- DASHBOARD-INSTRUCTION: Setting a channel rule -->
To set a channel rule in the Ably dashboard:

1. Sign in to your Ably account.
2. Select an app.
3. Go to **Settings** tab.
4. Click **Add new rule**.
5. Select channel name or namespace to apply rules to.
6. Check required rules.

h2(#history). Channel history

Channel "history":/storage-history/history enables clients to retrieve messages that have been previously published on the channel. Messages can be retrieved from history for up to 72 hours in the past, depending on the "persistence":/storage-history/storage configured for the channel.

h2(#presence). Presence

The "presence":/presence-occupancy/presence feature enables clients to be aware of other clients that are 'present' on the channel. Client status is updated as they enter or leave the presence set. Clients can also provide an optional payload describing their status or attributes, and trigger an update event at any time.

h2(#states). Channel states

A channel can exist in any of the following states:

- <span lang="default">initialized</span><span lang="csharp">Initialized</span> := The @Channel@ has been initialized, but no attach has been attempted yet.

- <span lang="default">attaching</span><span lang="csharp">Attaching</span> := An attach has been initiated by sending a request to Ably. This is a transient state and will be followed either by a transition to attached, suspended, or failed.

- <span lang="default">attached</span><span lang="csharp">Attached</span> := An attach has succeeded. In the attached state a client can publish and subscribe to messages, and enter the presence set.

- <span lang="default">detaching</span><span lang="csharp">Detaching</span> := A detach has been initiated on the attached @Channel@ by sending a request to Ably. This is a transient state and will be followed either by a transition to detached or failed.

- <span lang="default">detached</span><span lang="csharp">Detached</span> := The @Channel@, having previously been attached, has been detached by the client.

- <span lang="default">suspended</span><span lang="csharp">Suspended</span> := The @Channel@, having previously been attached, has lost continuity. This is normally due to the client being disconnected from Ably for more than two minutes. The client will automatically attempt to reattach as soon as connectivity is restored.

- <span lang="default">failed</span><span lang="csharp">Failed</span> := An indefinite failure condition. This state is entered if a @Channel@ error has been received from the Ably service (such as an attempt to attach without the necessary access rights).

h3(#connection-state). Channel state and connection state

"Connection state":/connect/states also impacts the state of a channel in the following ways:

* If the connection state becomes @CLOSED@, all channels will become @DETACHED@
* If the connection state becomes @FAILED@, all channels will become @FAILED@
* If the connection state becomes @SUSPENDED@, all previously-@ATTACHED@ or @ATTACHING@ channels will become @SUSPENDED@
* If the connection state becomes @CONNECTED@, any channels that were @SUSPENDED@ will be automatically reattached

h3(#listen-for-state). Listen for state changes

The @Channel@ object is an @EventEmitter@. Events are emitted with a @name@ that corresponds to the new channel state, whenever there is a channel state change. Register a channel state change listener with the <span lang="default">"@on()@":/api/realtime-sdk/channels#on</span><span lang="csharp">"@On()@":/api/realtime-sdk/channels#on</span> or <span lang="default">"@once()@":/api/realtime-sdk/channels#once</span><span lang="csharp">"@Once()@":/api/realtime-sdk/channels#once</span> methods, depending on whether you want to monitor all channel state changes, or only the first occurrence of one.

Remove channel state listeners with the <span lang="default">"@off()@":/api/realtime-sdk/channels#off</span><span lang="csharp">"@Off()@":/api/realtime-sdk/channels#off</span> method.

Listeners are passed a "ChannelStateChange":/api/realtime-sdk/channels#channel-state-change object in the first argument. This object has the following properties:

* @current@ / @previous@: the present and last state of the channel.
* @resumed@: a flag indicating whether message continuity on the channel is preserved since the last time the channel was attached.
* @reason@: the reason for the state change, if available.

As with all events from an @EventEmitter@ in the Ably library, @this@ within the listener function is a reference to an event object whose @event@ property is the name of the event that fired. This allows a listener to listen for all events with a single registration and still know which type of event is fired.

The @Channel@ object can also emit one event that is not a state change: an @update@ event. This happens when there's a change to channel conditions for which the channel state doesn't change. For example, a partial loss of message continuity on a channel (typically after a resume) for which the channel state remains @attached@ would lead to an @update@ event being emitted, with both @current@ and @previous@ set to "@attached@", and the @resumed@ flag set to @false@. So if you get such an event, you'll know there may be messages you've missed on the channel, and if necessary you can use "history":/api/realtime-sdk/channels#history to retrieve them.

```[realtime_javascript]
channel.on('attached', (stateChange) => {
  console.log('channel ' + channel.name + ' is now attached');
  console.log('Message continuity on this channel ' + \
    (stateChange.resumed ? 'was' : 'was not') + ' preserved');
});
```

```[realtime_nodejs]
channel.on('attached', (stateChange) => {
  console.log('channel ' + channel.name + ' is now attached');
  console.log('Message continuity on this channel ' + \
    (stateChange.resumed ? 'was' : 'was not') + ' preserved');
});
```

```[realtime_ruby]
channel.on(:attached) do |channel_state_change|
  puts "channel #{channel.name} is now attached"
  puts "Message continuity #{channel_state_change.resumed ? 'was' : 'was not'} preserved"
end
```

```[realtime_python]
def listener(state_change):
  print(f'{channel.name} is now {state_change.current}')
channel.on('attached', listener)
```

```[realtime_java]
channel.on(ChannelEvent.attached, new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelStateChange stateChange) {
    System.out.println("channel " + channel.name + " is now attached");
    if (stateChange.resumed) {
      System.out.println("Message continuity was preserved");
    } else {
      System.out.println("Message continuity was not preserved");
    }
  }
});
```

```[realtime_csharp]
IRealtimeChannel channel = realtime.Channels.Get("chatroom");
channel.On(ChannelEvent.Attached, stateChange => {
  Console.WriteLine("channel " + channel.Name + " is now attached");
  if (stateChange.resumed) {
    Console.WriteLine("Message continuity was preserved");
  } else {
    Console.WriteLine("Message continuity was not preserved");
  }
});
```

```[realtime_objc]
[channel on:ARTChannelEventAttached callback:^(ARTChannelStateChange *stateChange) {
  NSLog(@"channel %@ is now attached", channel.name);
  if (stateChange.resumed) {
    NSLog(@"Message continuity was preserved");
  } else {
    NSLog(@"Message continuity was not preserved");
  }
}];
```

```[realtime_swift]
channel.on(.attached) { stateChange in
  print("channel \(channel.name) is now attached")
  if (stateChange.resumed) {
    print("Message continuity was preserved")
  } else {
    print("Message continuity was not preserved")
  }
}
```

```[realtime_flutter]
final stateChangeListener = channel
    .on(ably.ChannelEvent.attached)
    .listen((ably.ChannelStateChange state) {
  print('channel ${channel.name} is now attached');
  if (state.resumed) {
    print('Message continuity was preserved');
  } else {
    print('Message continuity was not preserved');
  }
});
```

```[realtime_go]
channel.On(ably.ChannelEventAttached, func(stateChange ably.ChannelStateChange) {
  fmt.Printf("channel '%v' is now attached\n", channel.Name)
  if stateChange.Resumed {
    fmt.Printf("Message continuity on this channel was preserved\n")
  } else {
    fmt.Printf("Message continuity on this channel was not preserved\n")
  }
})
```

Alternatively, a listener may be registered so that it receives all state change events.

```[realtime_javascript]
const myListener = (stateChange) => {
  console.log('channel state is ' + stateChange.current);
  console.log('previous state was ' + stateChange.previous);
  if (stateChange.reason) {
    console.log('the reason for the state change was: ' + stateChange.reason.toString());
  }
});
channel.on(myListener);
```

```[realtime_nodejs]
const myListener = (stateChange) => {
  console.log('channel state is ' + stateChange.current);
  console.log('previous state was ' + stateChange.previous);
  if (stateChange.reason) {
    console.log('the reason for the state change was: ' + stateChange.reason.toString());
  }
});
channel.on(myListener);
```

```[realtime_ruby]
channel.on do |channel_state_change|
  puts "channel state is #{channel_state_change.current}"
end
```

```[realtime_python]
def listener(state_change):
  print(f'{channel.name} is now {state_change.current}')
channel.on(listener)
```

```[realtime_java]
channel.on(new ChannelStateListener() {
    @Override
    public void onChannelStateChanged(ChannelStateChange stateChange) {
        ChannelState currentState = stateChange.current;
        ErrorInfo reason = stateChange.reason;

        System.out.println("Channel state is " + currentState);
        if (reason != null) {
            System.out.println("Reason: " + reason.message);
        }
    }
});
```

```[realtime_csharp]
channel.On(stateChange => Console.WriteLine("channel state is " + stateChange.Current));
```

```[realtime_objc]
ARTEventListener *listener = [channel on:^(ARTChannelStateChange *stateChange) {
    NSLog(@"channel state is %@", stateChange.current);
}];
```

```[realtime_swift]
let listener = channel.on { stateChange in
    print("channel state is \(stateChange.current)")
}
```

```[realtime_flutter]
final stateChangeListener = channel
    .on()
    .listen((ably.ChannelStateChange stateChange) {
  print('channel state is ${stateChange.current.name}');
});
```

```[realtime_go]
channel.OnAll(func(stateChange ably.ChannelStateChange) {
  fmt.Printf("channel state is '%v'", stateChange.Current)
  fmt.Printf("previous state was '%v'", stateChange.Previous)

  if stateChange.Reason != nil {
    fmt.Printf("the reason for the state change was: '%v'", stateChange.Reason)
  }
})
```

Previously registered listeners can be removed individually or all together.

```[realtime_javascript]
  /* remove the listener registered for a single event */
  channel.off('attached', myListener);

  /* remove the listener registered for all events */
  channel.off(myListener);
```

```[realtime_nodejs]
  /* remove the listener registered for a single event */
  channel.off('attached', myListener);

  /* remove the listener registered for all events */
  channel.off(myListener);
```

```[realtime_ruby]
  # remove the listener proc registered for a single event
  channel.off(:attached, &my_proc)

  # remove the listener proc registered for all events
  channel.off(&my_proc)
```

```[realtime_python]
  # remove a single listener
  channel.off(listener)

  # remove all listeners
  channel.off()
```

```[realtime_java]
  /* remove the listener registered for a single event */
  channel.off(ChannelEvent.attached, channelStateListener);

  /* remove the listener registered for all events */
  channel.off(channelStateListener);
```

```[realtime_csharp]
  // remove the listener registered for a single event
  channel.Off(ChannelEvent.Attached, channelStateListener);

  // remove the listener registered for all events
  channel.Off(channelStateListener);
```

```[realtime_objc]
  // remove the listener registered for a single event
  [channel off:ARTChannelEventAttached listener:listener];

  // remove the listener registered for all events
  [channel off:listener];
```

```[realtime_swift]
  // remove the listener registered for a single event
  channel.off(.attached, listener: listener)

  // remove the listener registered for all events
  channel.off(listener)
```

```[realtime_flutter]
    // cancel stream subscription on the listener to stop receiving the events
    stateChangeListener.cancel();
```

```[realtime_go]
channel.Off(ably.ChannelEventAttached)
channel.OffAll()
```

Be aware that when registering listeners for channel state changes, certain repeating states may add new listeners each time.

h2(#failure). Handle channel failures

Channel attach and detach operations are asynchronous. After initiating an attach request, the client will wait for a response from Ably that confirms that the channel is established on the service and then trigger a "state change":#states event.

Ably SDKs will attempt to automatically recover from non-fatal error conditions. However, you can handle them yourself if you prefer by subscribing to channel state changes, or <span lang="default">using the callbacks available</span><span lang="java,javascript,nodejs">waiting for a result</span> when explicitly calling "@attach()@":/api/realtime-sdk/channels#attach.

```[realtime_javascript]
const channel = realtime.channels.get('private:chatroom');

channel.on('failed', (stateChange) => {
  console.log('Channel failed, reason: ', stateChange.reason);
});

await channel.attach();
```

```[realtime_nodejs]
const channel = realtime.channels.get('private:chatroom');

channel.on('failed', (stateChange) => {
  console.log('Channel failed, reason: ', stateChange.reason);
});

await channel.attach();
```

```[realtime_ruby]
deferrable = realtime.channels.get('private:chatroom').attach
deferrable.errback do |error|
  puts "Attach failed: #{error}"
end
```

```[realtime_python]
channel = realtime.channels.get('private:chatroom')

# Attach to the channel
try:
    await channel.attach()
    print("Attached to channel successfully")
except Exception as err:
    print("Attach failed:", err)
```

```[realtime_java]
Channel channel = realtime.channels.get("private:chatroom");
channel.on(new ChannelStateListener() {
    @Override
    public void onChannelStateChanged(ChannelStateChange stateChange) {
        switch (stateChange.current) {
            case failed:
                ErrorInfo reason = stateChange.reason;
                System.out.println("Attach failed: " + (reason != null ? reason.message : "Unknown reason"));
                break;
        }
    }
});

channel.attach();
```

```[realtime_csharp]
IRealtimeChannel privateChannel = realtime.Channels.Get("private:chatroom");
privateChannel.Attach((_, error) => {
    if (error != null)
    {
        Console.WriteLine("Attach failed: " + error.Message);
    }
});
```

```[realtime_objc]
[[realtime.channels get:@"private:chatroom"] attach:^(ARTErrorInfo *error) {
    if (error) {
        NSLog(@"Attach failed: %@", error);
    }
}];
```

```[realtime_swift]
realtime.channels.get("private:chatroom").attach { error in
    if let error = error {
        print("Attach failed: \(error)")
    }
}
```

```[realtime_flutter]
final channel = realtime.channels.get('private:chatroom');
channel
    .on()
    .listen((ably.ChannelStateChange stateChange) {
  switch (stateChange.current) {
    case ably.ChannelState.failed:
      print('Attach failed: ${stateChange.reason?.message}');
      break;
  // Add other cases if needed
    default:
      break;
  }
});

channel.attach();
```

```[realtime_go]
channel := realtime.Channels.Get("private:chatroom")
channel.On(ably.ChannelEventFailed, func(stateChange ably.ChannelStateChange) {
  fmt.Printf("Channel failed, reason: '%v'", stateChange.Reason)
})
channel.Attach(context.Background())
```

h3(#fatal-errors). Fatal channel errors

Some classes of errors are fatal. These cause the channel to move to the @FAILED@ state. Ably SDKs will not attempt any automatic recovery actions. For example, when attempting to attach to a channel, with a token that doesn't have the @subscribe@ "capability":/auth/capabilities for that channel, will cause that channel to enter the @FAILED@ state.

Whilst fatal errors won't get better on their own, they are fixable. For example, if a channel goes into the @FAILED@ state due to the client not having the right capabilities to attach to it, that client could call "@authorize()@":/api/realtime-sdk/authentication#authorize to obtain a new token which does have the right capabilities, then call "@attach()@":/api/realtime-sdk/channels#attach on the channel. The library will not automatically reattach in the @FAILED@ state, however explicit calls to "@attach()@":/api/realtime-sdk/channels#attach will make the client try again.

h3(#non-fatal-errors). Non-fatal errors

Some types of errors are non-fatal. For example, a client may have network connectivity issues, or a channel may experience a loss of strict message continuity. Ably SDKs will automatically attempt to recover from these events. If channel continuity is lost in the process, the library will notify you through a @resumed@ flag in the @ATTACHED@ or @UPDATE@ event, so that you can decide how to handle the failure.

For every channel @ATTACHED@ and @UPDATE@ event, the "@ChannelStateChange@":/api/realtime-sdk/types#channel-state-change object contains a @resumed@ attribute. When @true@, there has been no loss of continuity from the last time the channel was attached. When @false@, there has been a loss of continuity.

For example:

* The first time a client attaches to a channel on a fresh connection, @resumed@ will be @false@, as there was nothing to continue from.
* If a client successfully "recovers":/connect/states a connection and reattaches to its channels, the @resumed@ flag on the @ATTACHED@ events will tell it whether message continuity was preserved, or not. Any channel for which it's @true@, is guaranteed to receive every message it missed while the client was disconnected.
* If a client "resumes or recovers":/connect/states a connection unsuccessfully continuity is lost and the client receives a fresh connection. This generally happens because the client was disconnected for more than two minutes, which is how long Ably holds connection state for. If the client were resuming, all the channels (which will have gone into the @SUSPENDED@ state after two minutes) will still reattach automatically, and the client will receive @ATTACHED@ events with @resumed@ set to @false@.
* If Ably needs to signal a loss of message continuity on an attached channel, the client will receive an @UPDATE@ event with @resumed@ set to @false@. This occurs in situations such as a partially successful resume, where the client was disconnected for less than two minutes.
