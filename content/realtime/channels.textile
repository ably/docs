---
title: Channels
section: realtime
index: 2
languages:
  - javascript
  - nodejs
  - ruby
  - java
  - swift
  - objc
  - csharp
  - flutter
jump_to:
  Help with:
    - Getting started#getting-started
    - Channels#channels
    - Subscribing to a channel#subscribing
    - Publishing to a channel#publishing
    - Channel lifecycle#channel-lifecycle
    - Channel metadata#channel-metadata
    - Implicit attach#implicit-attach
    - Attach versus subscribe#attach-vs-subscribe
    - Publishing to multiple channels#multi-publish
    - Transient Publishing#transient-publish
    - Channel states#channel-states
    - Detaching from a channel#channel-detach
    - Handling failures#handling-failures
    - Channel namespaces#channel-namespaces
    - Presence#presence-api
    - API Reference#api-reference
redirect_from:
  - /realtime/channels-messages
---

Ably Platform service organizes the message traffic within applications into named channels. Channels are the medium through which "messages":/realtime/messages are distributed; clients attach to channels to subscribe to "messages":/realtime/messages, and every "message":/realtime/messages published to a unique channel is broadcast by Ably to all subscribers. This scalable and resilient messaging pattern is commonly called "pub/sub":https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern. Connections are used to establish and maintain realtime communication with channels but are separate from channels, see the "connection documentation":/realtime/connection for further information.

h2(#getting-started). Getting started

The Ably Realtime client library provides a straightforward API for "publishing":/realtime/messages#message-publish and "subscribing":/realtime/messages#message-subscription to messages on a channel. If the channel does not exist at the time the client is attached, a channel will be created in the Ably system immediately.

```[javascript](code-editor:realtime/channel-publish)
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  channel.subscribe(function(message) {
    alert('Received: ' + message.data);
  });
  channel.publish('example', 'message data');
```

```[nodejs](code-editor:realtime/channel-publish)
  var Ably = require('ably');
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  channel.subscribe(function(message) {
    console.log("Received: " + message.data);
  });
  channel.publish("example", "message data");
```

```[ruby]
  realtime = Ably::Realtime.new('{{API_KEY}}')
  channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')
  channel.subscribe do |message|
    puts "Received: #{message.data}"
  end
  channel.publish 'example', 'message data'
```

```[java]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");
  channel.subscribe(new MessageListener() {
    @Override
    public void onMessage(Message message) {
      System.out.println("New messages arrived. " + message.name);
    }
  });
  channel.publish("example", "message data");
```

```[csharp]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  IRealtimeChannel channel = realtime.Channels.Get("{{RANDOM_CHANNEL_NAME}}");
  channel.Subscribe(message => {
    Console.WriteLine($"Message: {message.Name}:{message.Data} received");
  });
  channel.Publish("example", "message data");
```

```[objc]
ARTRealtime *realtime = [[ARTRealtime alloc] initWithKey:@"{{API_KEY}}"];
ARTRealtimeChannel *channel = [realtime.channels get:@"{{RANDOM_CHANNEL_NAME}}"];
[channel subscribe:^(ARTMessage *message) {
    NSLog(@"Received: %@", message.data);
}];
[channel publish:@"example" data:@"message data"];
```

```[swift]
let realtime = ARTRealtime(key: "{{API_KEY}}")
let channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}")
channel.subscribe { message in
    print("Received: \(message.data)")
}
channel.publish("example", data: "message data")
```

```[flutter]
  final realtime = ably.Realtime(key: '{{API_KEY}}');
  final channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  final channelMessageSubscription = channel
    .subscribe()
    .listen((ably.Message message) {
      print('Received: ${message.data}');
    }
  );
  await channel.publish(name: 'example', data: 'message data');
```

If you would prefer to just dive into code and see some examples of how to use channels, then we recommend you take a look at our "Realtime tutorials":/tutorials.

h2(#channels). Channels

In order to "publish":/realtime/messages#message-publish, "subscribe":/realtime/messages#message-subscription to, or be "present":/realtime/presence on a channel, you must first obtain a channel instance and then attach to that channel. In most instances, as a convenience, it is unnecessary to explicitly attach a channel as it will implicitly attached when performing any operation on the channel such as publishing or subscribing.

h3(#obtaining-channel). Obtaining a channel instance

A @Channel@ object is a reference to a single channel. A channel instance is obtained from the "@channels@ collection":/realtime/usage/#channels of the <span lang="ruby">@Realtime::Client@</span><span lang="default">@Realtime@</span><span lang="objc,swift">@ARTRealtime@</span><span lang="csharp">@AblyRealtime@</span> instance, and is uniquely identified by its unicode string name. You can only connect to one channel in a single operation, so wildcards are not supported. Find out more about "channel naming":https://faqs.ably.com/what-restrictions-are-there-on-channel-names

bc[jsall](code-editor:realtime/channel). var channel = realtime.channels.get('channelName');

bc[java]. Channel channel = realtime.channels.get("channelName");

bc[csharp]. IRealtimeChannel channel = realtime.Channels.Get("channelName");

bc[ruby]. channel = realtime.channels.get('channelName')

bc[objc]. ARTRealtimeChannel *channel = [realtime.channels get:@"channelName"];

bc[swift]. let channel = realtime.channels.get("channelName")

bc[flutter]. final channel = realtime.channels.get('channelName');

h4(#setting-channel-options). Setting channel options

You can set "channel options":/api/realtime-sdk/channels#channel-options in one of two ways:

* Initially, when you first obtain a channel using "channels.get":#obtaining-channel.
* After creation, when you update a channel using "channels.setOptions":#modifying-options.

h5(#setting-channel-parameters). Setting channel parameters

Channel parameters allow a client to set the properties of a channel. The are two parameters that can be specified:

- rewind := Used to request that an attachment start from a given number of messages or point in time in the past. See "rewind":/realtime/channels/channel-parameters/rewind for more information.
- delta := Used to request that data payloads should be sent as deltas to the previous payload. See "deltas":/realtime/channels/channel-parameters/deltas for more information.

bc[jsall]. const realtime = new Ably.Realtime('{{API_KEY}}');
const channelOptions = {
  params: {
    delta: 'vcdiff',
    rewind: '1'
  }
};
const channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}', channelOptions);

h5(#setting-encryption-options). Setting channel encryption options

You can enable encryption on a channel using the "channel options":/api/realtime-sdk/channels#channel-options.

Find out more about "symmetric message encryption":/realtime/encryption.

bc[jsall]. Ably.Realtime.Crypto.generateRandomKey(function(err, key) {
  var options = { cipher: { key: key } };
  var channel = realtime.channels.get('channelName', options);
});

bc[java]. CipherParams params = Crypto.getDefaultParams(key);
ChannelOptions options = new ChannelOptions();
options.encrypted = true;
options.cipherParams = params;
Channel channel = realtime.channels.get("channelName", options);

bc[csharp]. byte[] key = Crypto.GenerateRandomKey();
CipherParams cipherParams = Crypto.GetDefaultParams(key);
ChannelOptions channelOpts = new ChannelOptions(cipherParams);
IRealtimeChannel encryptedChannel = realtime.Channels.Get("channelName", channelOpts);

bc[ruby]. key = Ably::Util::Crypto.generate_random_key
options = { cipher: { key: key } }
channel = realtime.channels.get('channelName', options)

bc[objc]. NSData *key = [ARTCrypto generateRandomKey];
ARTChannelOptions *options = [[ARTChannelOptions alloc] initWithCipherKey:key];
ARTRealtimeChannel *channel = [realtime.channels get:@"channelName" options:options];

bc[swift]. let key = ARTCrypto.generateRandomKey()
let options = ARTChannelOptions(cipherKey: key)
let channel = realtime.channels.get("channelName", options: options)

h5(#setting-channel-mode-flags). Setting channel mode flags

Channel mode flags enable a client to specify a subset of the "capabilities":/core-features/authentication#capabilities-explained granted by their token or API key as "channel options":#setting-channel-options. Channel mode flags offer the ability for clients to use different capabilities for different channels, however, as they are flags and not permissions they cannot be enforced by an authentication server.

The channel mode flags available are:

|_. Flag |_. Description |
| SUBSCRIBE | Can subscribe to receive messages on the channel. |
| PUBLISH | Can publish messages to the channel. |
| PRESENCE_SUBSCRIBE | Can subscribe to receive presence events on the channel. |
| PRESENCE | Can register presence on the channel. |

Channel mode flags are set as "channel options":#setting-channel-options:

bc[javascript]. const realtime = new Ably.Realtime('{{API_KEY}}');
const channelOptions = {
  modes: ['PUBLISH', 'SUBSCRIBE', 'PRESENCE']
};
const channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}'), channelOptions);

**Note**: Channel mode flags enable clients to be "present on a channel without subscribing to presence events":/best-practice-guide#being-present-without-subscribing-to-presence.

h3(#subscribing). Subscribing to a channel

To subscribe to a channel, use the "subscribe":/api/realtime-sdk/channels#subscribe method of a channel:

```[javascript](code-editor:realtime/channel-publish)
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  channel.subscribe(function(message) {
    alert('Received: ' + message.data);
  });
```

```[nodejs](code-editor:realtime/channel-publish)
  var Ably = require('ably');
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  channel.subscribe(function(message) {
    console.log("Received: " + message.data);
  });
```

```[ruby]
  realtime = Ably::Realtime.new('{{API_KEY}}')
  channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')
  channel.subscribe do |message|
    puts "Received: #{message.data}"
  end
```

```[java]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");
  channel.subscribe(new MessageListener() {
    @Override
    public void onMessage(Message message) {
      System.out.println("New messages arrived. " + message.name);
    }
  });
```

```[csharp]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  IRealtimeChannel channel = realtime.Channels.Get("{{RANDOM_CHANNEL_NAME}}");
  channel.Subscribe(message => {
    Console.WriteLine($"Message: {message.Name}:{message.Data} received");
  });
```

```[objc]
ARTRealtime *realtime = [[ARTRealtime alloc] initWithKey:@"{{API_KEY}}"];
ARTRealtimeChannel *channel = [realtime.channels get:@"{{RANDOM_CHANNEL_NAME}}"];
[channel subscribe:^(ARTMessage *message) {
    NSLog(@"Received: %@", message.data);
}];
```

```[swift]
let realtime = ARTRealtime(key: "{{API_KEY}}")
let channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}")
channel.subscribe { message in
    print("Received: \(message.data)")
}
```

```[flutter]
  final realtime = ably.Realtime(key: '{{API_KEY}}');
  final channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  final channelMessageSubscription = channel
    .subscribe()
    .listen((ably.Message message) {
      print('Received: ${message.data}');
    }
  );
```

h4(#rewind). Subscribing to a channel with the rewind option enabled

It is possible to subscribe to a channel and obtain messages from that channel's "history":/realtime/history with a single API request. To do so you would use the "rewind":/realtime/channels/channel-parameters/rewind feature. This will result in the specified number of messages from "history":/realtime/history being returned as part of the subscription process.

"Rewind":/realtime/channels/channel-parameters/rewind has two methods of obtaining messages from history. You can retrieve a specified number of messages from history or messages from a set period of time into the past.

In current Ably libraries, or when using the "service without a library":https://ably.com/protocols, this is done by qualifying the channel name. It is possible to specify channel params directly via the API. As an example, if you have no metadata and wish to subscribe to channel @my_channel@ and fetch the most recent message from "history":/realtime/history, you would specify the channel as @[?rewind=1]my_channel@. If the channel had some metadata, @[some_metadata]my_channel@, you would apply "rewind":/realtime/channels/channel-parameters/rewind with @[some_metadata?rewind=1]my_channel@. For more details, look at our "channel parameter":/realtime/channels/channel-parameters/overview documentation.

*Note* that "rewind":/realtime/channels/channel-parameters/rewind is limited to a maximum of @100 messages@, and can only get messages no older than 2 minutes by default. If a channel has persistence enabled, then it is possible to rewind back in time by up to the persistence TTL on the channel.

In addition, rewind will only apply upon *attaching* to a channel, so any subsequent subscriptions post-attach will not fetch old messages.

h5. Rewind by number of messages

To rewind by a set number of messages, add @?rewind=NUM_MSG@ to your metadata, where @NUM_MSG@ is the number of messages you wish to get at most. For example, to obtain 1 message from history as you subscribe, you would do the following:

```[javascript](code-editor:realtime/rewind)
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('[?rewind=1]{{RANDOM_CHANNEL_NAME}}');
  channel.subscribe(function(message) {
    alert('Received: ' + message.data);
  });
```

```[nodejs](code-editor:realtime/rewind)
  var Ably = require('ably');
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('[?rewind=1]{{RANDOM_CHANNEL_NAME}}');
  channel.subscribe(function(message) {
    console.log("Received: " + message.data);
  });
```

```[ruby]
  realtime = Ably::Realtime.new('{{API_KEY}}')
  channel = realtime.channels.get('[?rewind=1]{{RANDOM_CHANNEL_NAME}}')
  channel.subscribe do |message|
    puts "Received: #{message.data}"
  end
```

```[java]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  Channel channel = realtime.channels.get("[?rewind=1]{{RANDOM_CHANNEL_NAME}}");
  channel.subscribe(new MessageListener() {
    @Override
    public void onMessage(Message message) {
      System.out.println("New messages arrived. " + message.name);
    }
  });
```

```[csharp]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  IRealtimeChannel channel = realtime.Channels.Get("[?rewind=1]{{RANDOM_CHANNEL_NAME}}");
  channel.Subscribe(message => {
    Console.WriteLine($"Message: {message.Name}:{message.Data} received");
  });
```

```[objc]
ARTRealtime *realtime = [[ARTRealtime alloc] initWithKey:@"{{API_KEY}}"];
ARTRealtimeChannel *channel = [realtime.channels get:@"[?rewind=1]{{RANDOM_CHANNEL_NAME}}"];
[channel subscribe:^(ARTMessage *message) {
    NSLog(@"Received: %@", message.data);
}];
```

```[swift]
let realtime = ARTRealtime(key: "{{API_KEY}}")
let channel = realtime.channels.get("[?rewind=1]{{RANDOM_CHANNEL_NAME}}")
channel.subscribe { message in
    print("Received: \(message.data)")
}
```

h5. Rewind by period of time

To rewind by a time interval, add @?rewind=TIME@ to your metadata, where @TIME@ is the time specifier. For example, to obtain 10 seconds of messages from history as you subscribe, you would do the following:

```[javascript](code-editor:realtime/rewind)
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('[?rewind=10s]{{RANDOM_CHANNEL_NAME}}');
  channel.subscribe(function(message) {
    alert('Received: ' + message.data);
  });
```

```[nodejs](code-editor:realtime/rewind)
  var Ably = require('ably');
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('[?rewind=10s]{{RANDOM_CHANNEL_NAME}}');
  channel.subscribe(function(message) {
    console.log("Received: " + message.data);
  });
```

```[ruby]
  realtime = Ably::Realtime.new('{{API_KEY}}')
  channel = realtime.channels.get('[?rewind=10s]{{RANDOM_CHANNEL_NAME}}')
  channel.subscribe do |message|
    puts "Received: #{message.data}"
  end
```

```[java]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  Channel channel = realtime.channels.get("[?rewind=10s]{{RANDOM_CHANNEL_NAME}}");
  channel.subscribe(new MessageListener() {
    @Override
    public void onMessage(Message message) {
      System.out.println("New messages arrived. " + message.name);
    }
  });
```

```[csharp]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  IRealtimeChannel channel = realtime.Channels.Get("[?rewind=10s]{{RANDOM_CHANNEL_NAME}}");
  channel.Subscribe(message => {
    Console.WriteLine($"Message: {message.Name}:{message.Data} received");
  });
```

```[objc]
ARTRealtime *realtime = [[ARTRealtime alloc] initWithKey:@"{{API_KEY}}"];
ARTRealtimeChannel *channel = [realtime.channels get:@"[?rewind=1]{{RANDOM_CHANNEL_NAME}}"];
[channel subscribe:^(ARTMessage *message) {
    NSLog(@"Received: %@", message.data);
}];
```

```[swift]
let realtime = ARTRealtime(key: "{{API_KEY}}")
let channel = realtime.channels.get("[?rewind=10s]{{RANDOM_CHANNEL_NAME}}")
channel.subscribe { message in
    print("Received: \(message.data)")
}
```

*Note* that currently only seconds (@10s@) and minutes (@2m@) are supported as time periods.

h3(#publishing). Publishing on a channel

In order to publish on a channel, you simply need to make use of the "publish":/api/realtime-sdk/channels#publish method:

```[javascript](code-editor:realtime/channel-publish)
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  channel.publish('example', 'message data');
```

```[nodejs](code-editor:realtime/channel-publish)
  var Ably = require('ably');
  var realtime = new Ably.Realtime('{{API_KEY}}');
  var channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  channel.publish("example", "message data");
```

```[ruby]
  realtime = Ably::Realtime.new('{{API_KEY}}')
  channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}')
  channel.publish 'example', 'message data'
```

```[java]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  Channel channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}");
  channel.publish("example", "message data");
```

```[csharp]
  AblyRealtime realtime = new AblyRealtime("{{API_KEY}}");
  IRealtimeChannel channel = realtime.Channels.Get("{{RANDOM_CHANNEL_NAME}}");
  channel.Publish("example", "message data");
```

```[objc]
ARTRealtime *realtime = [[ARTRealtime alloc] initWithKey:@"{{API_KEY}}"];
ARTRealtimeChannel *channel = [realtime.channels get:@"{{RANDOM_CHANNEL_NAME}}"];
[channel publish:@"example" data:@"message data"];
```

```[swift]
let realtime = ARTRealtime(key: "{{API_KEY}}")
let channel = realtime.channels.get("{{RANDOM_CHANNEL_NAME}}")
channel.publish("example", data: "message data")
```

```[flutter]
  final realtime = ably.Realtime(key: '{{API_KEY}}');
  final channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
  await channel.publish(name: 'example', data: 'message data');
```

h3(#channel-lifecycle). Channel lifecycle

Channels are not pre-configured or provisioned by Ably in advance; they are created on demand when clients attach, and remain active until such time that there are no remaining attached clients. Within the "dashboard for your app":https://faqs.ably.com/how-do-i-access-my-app-dashboard however, you can pre-configure one or more "channel namespaces":#channel-namespaces (i.e. name prefixes), and associate different attributes and access rights with those namespaces. Find out more about "channel namespaces":#channel-namespaces.

The following example explicitly attaches to a channel, which results in the channel being provisioned in Ably's global realtime cluster. This channel will remain available globally until there are no more clients attached to the channel:

bc[jsall]. realtime.channels.get('chatroom').attach(function(err) {
  console.log('"chatroom" exists and is now available globally in every datacenter');
});

bc[ruby]. realtime.channels.get('chatroom').attach do |channel|
  puts "'chatroom' exists and is now available globally in every datacenter"
end

bc[java]. Channel channel = realtime.channels.get("chatroom");
channel.on(new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelStateChange state) {
    switch (state.current) {
      case attached: {
        System.out.println("'chatroom' exists and is now available globally");
      }
    }
  }
});

bc[csharp]. IRealtimeChannel channel = realtime.Channels.Get("chatroom");
channel.Attach((success, error) => {
  Console.WriteLine("'chatroom' exists and is now available globally");
});

bc[objc]. [[realtime.channels get:@"chatroom" options:options] attach:^(ARTErrorInfo *error) {
  NSLog(@"'chatroom' exists and is now available globally in every datacenter");
}];

bc[swift]. realtime.channels.get("chatroom").attach { error in
  print("'chatroom' exists and is now available globally in every datacenter")
}

bc[flutter]. final channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
final channelMessageSubscription = channel
  .on()
  .listen((ably.ChannelStateChange state) {
    switch (state.current) {
      case ably.ChannelStateChange.attached: {
        print("'chatroom' exists and is now available globally");
      }
    }
  }
);

Clients attach to a channel in order to participate on that channel in any way (either to publish, subscribe, or be present on the channel). It is worth noting that some libraries allow for "publishing to a channel without attaching to it":#transient-publish. "See if your chosen SDK supports this":https://ably.com/download.

h3(#channel-metadata). Channel metadata

Ably provides a "REST API":/realtime/channel-metadata to query your app for metadata about channels, as well as a "realtime API":/realtime/channel-metadata to subscribe to channel lifecycle events. Using the "REST API":/rest-api, you can enumerate all active channels, or obtain the status of an individual channel. Using our Realtime API, you can subscribe to "channel lifecycle events":/realtime/metachannels#lifecycle-events (such as being created or closed etc), or subscribe to periodic "occupancy":/realtime/metachannels#occupancy-events updates for all active channels (such as how many people are subscribed to a channel).

h3(#implicit-attach). Implicit attach

Although the attach operation can be initiated explicitly by a client, it is more common for the client to subscribe, which will initiate the attach if the channel is not already attached. This client library allows clients to begin publishing "messages":/realtime/messages without attaching to the channel with "transient publishing":#transient-publish.

bc[jsall](code-editor:realtime/channel-implicit). var channel = realtime.channels.get('chatroom');
channel.subscribe('action', function(message) { // implicit attach
  console.log('Message received '' + message.data);
});
channel.publish('action', 'boom!');

bc[ruby]. channel = realtime.channels.get('chatroom')
channel.subscribe('action') do |message| # implicit attach
  puts "Message received: #{message}";
end
channel.publish 'action', 'boom!'

bc[java]. Channel channel = realtime.channels.get("chatroom");
/* Implicit attach when subscribing */
channel.subscribe(new MessageListener() {
  @Override
  public void onMessage(Message message) {
    System.out.println("Message received: " + message.data);
  }
});
channel.publish("action", "boom!");

bc[csharp]. IRealtimeChannel channel = realtime.Channels.Get("chatroom");
channel.Subscribe(message => Console.WriteLine("Message received: " + message.Data));
channel.Publish("action", "boom");

bc[objc]. ARTRealtimeChannel *channel = [realtime.channels get:@"chatroom" options:options];
[channel subscribe:@"action" callback:^(ARTMessage *message) {
    NSLog(@"Message received: %@", message.data);
}]
[channel publish:@"action" data:@"boom!"];

bc[swift]. let channel = realtime.channels.get("chatroom")
channel.subscribe("action") { message in
    print("Message received: \(message.data)")
}
channel.publish("action", data: "boom!")

bc[flutter]. final channel = realtime.channels.get('chatroom');
/* Implicit attach when subscribing */
channel.subscribe(name: 'action').listen((ably.Message message) {
  print('Received: ${message.data}');
});
channel.publish(name: 'action', data: 'boom!');

Normally, errors in attaching to a channel are communicated through the attach callback. For implicit attaches (and other cases where a channel is attached or reattached automatically, e.g. following the library reconnecting after a period in the @suspended@ state), there is no callback, so if you want to know what happens, you'll need to listen for channel state changes.

h3(#attach-vs-subscribe). Difference between attaching and subscribing

It is important to understand the difference between attaching and subscribing to a channel, and that messages are sent to clients as soon as they attach to a channel.

Published messages are immediately sent to clients on "attaching":/api/realtime-sdk/channels#attach to a channel as long as they have subscribe "capabilities":/core-features/authentication#capabilities-explained for that channel. Messages are sent regardless of whether or not the client has subscribed to the channel.

"Subscribing":/api/realtime-sdk/channels#subscribe to a channel registers a subscribe listener for messages received on the channel and is a client-side operation, meaning that Ably is unaware of whether or not a client is subscribed to a channel.

As subscribing to a channel "implicitly attaches":#implicit-attach a client, it is important to note that if a client subscribes to and then "unsubscribes":/api/realtime-sdk/channels#unsubscribe from a channel, the client remains attached. The client will continue to be sent published messages until they "detach":#detach from the channel.

h3(#modifying-options). Modifying channel options

You can modify the @ChannelOptions@ associated with a given channel instance by calling @setOptions@ and passing a new @ChannelOptions@. The modified options will either take effect at the time of attachment (if an attach for that channel has not yet been initiated), or the @setOptions@ call will trigger an immediate attach operation to apply the modified options. Success or failure of any triggered attach operation triggered is indicated in the result of the @setOptions@ call.

h3(#multi-publish). Publishing to multiple channels

Often it is necessary to publish a single message in multiple channels at the same time. In the realtime API, this is achieved simply by making multiple separate "publish":/api/realtime-sdk/channels#publish requests. If a separate publish is made in each of the channels in question, the realtime protocol will allow for those concurrent requests to be in-flight simultaneously. This ensures that a publish on a channel is not delayed waiting for completion of operations in other channels.

It is also possible to publish one or more messages into multiple channels in a single operation using the "REST batch API":/rest/batch.

h3(#transient-publish). Transient publishing

When attempting to only publish to a client, it is possible to publish without attaching to the channel. This can be beneficial if you intend to publish into many channels, removing the need to attach to a channel each time you wish to publish. Additionally, it avoids the client subscribing to messages, avoiding messages being sent to it redundantly.

*Note* that transient publishing is only available for "certain libraries":https://ably.com/download/sdk-feature-support-matrix, otherwise publishing will also attach you to the channel.

bc[jsall]. var channel = realtime.channels.get('chatroom');
// The publish below will not attach you to the channel
channel.publish('action', 'boom!');

bc[ruby]. channel = realtime.channels.get('chatroom')
# The publish below will not attach you to the channel
channel.publish 'action', 'boom!'

bc[swift]. let channel = realtime.channels.get("chatroom")
// The publish below will not attach you to the channel
channel.publish("action", data: "boom!")

bc[flutter]. final channel = realtime.channels.get('{{RANDOM_CHANNEL_NAME}}');
// The publish below will not attach you to the channel
await channel.publish(name: 'example', data: 'message data');

h3(#channel-states). Channel states

A channel can exist in any of the following states:

- <span lang="default">initialized</span><span lang="csharp">Initialized</span> := A @Channel@ object having this state has been initialized but no attach has yet been attempted

- <span lang="default">attaching</span><span lang="csharp">Attaching</span> := An attach has been initiated by sending a request to Ably. This is a transient state; it will be followed either by a transition to attached, suspended, or failed

- <span lang="default">attached</span><span lang="csharp">Attached</span> := Attach has succeeded. In the attached state a client may publish and subscribe to messages, or be present

- <span lang="default">detaching</span><span lang="csharp">Detaching</span> := A detach has been initiated on the attached @Channel@ by sending a request to Ably. This is a transient state; it will be followed either by a transition to detached or failed

- <span lang="default">detached</span><span lang="csharp">Detached</span> := The @Channel@, having previously been attached, has been detached by the user

- <span lang="default">suspended</span><span lang="csharp">Suspended</span> := The @Channel@, having previously been attached, has lost continuity, usually due to the client being disconnected from Ably for more than two minutes. It will automatically attempt to reattach as soon as connectivity is restored

- <span lang="default">failed</span><span lang="csharp">Failed</span> := An indefinite failure condition. This state is entered if a @Channel@ error has been received from the Ably service (such as an attempt to attach without the necessary access rights)

h3(#listening-state). Listening for state changes

The @Channel@ object is an @EventEmitter@ and emits an event whose name is the new state whenever there is a channel state change. Register a channel state change listener with the <span lang="default">"@on@":/api/realtime-sdk/channels#on</span><span lang="csharp">"@On@":/api/realtime-sdk/channels#on</span> or <span lang="default">"@once@":/api/realtime-sdk/channels#once</span><span lang="csharp">"@Once@":/api/realtime-sdk/channels#once</span> methods, depending on whether you want to monitor all state changes, or only the first occurrence of one. Remove channel state listeners with the <span lang="default">"@off@":/api/realtime-sdk/channels#off</span><span lang="csharp">"@Off@":/api/realtime-sdk/channels#off</span> method.

Listeners are passed a "ChannelStateChange":/api/realtime-sdk/channels#channel-state-change object in the first argument. This object has the following properties:

* @current@ / @previous@: the present and last state of the channel.
* @resumed@: a flag indicating whether message continuity on the channel is preserved since the last time the channel was attached.
* @reason@: the reason for the state change, if available.

As with all events from an @EventEmitter@ in the Ably library, @this@ within the listener function is a reference to an event object whose @event@ property is the name of the event that fired. This allows a listener to listen for all events with a single registration and still know which type of event is fired.

The @Channel@ object can also emit one event that is not a state change: an @update@ event. This happens when there's a change to channel conditions for which the channel state doesn't change. For example, a partial loss of message continuity on a channel (typically after a resume) for which the channel state remains @attached@ would lead to an @update@ event being emitted, with both @current@ and @previous@ set to "@attached@", and the @resumed@ flag set to @false@. So if you get such an event, you'll know there may be messages you've missed on the channel, and if necessary you can use the "History":/api/realtime-sdk/channels#history api to retrieve them.

bc[jsall]. channel.on('attached', function(stateChange) {
  console.log('channel ' + channel.name + ' is now attached');
  console.log('Message continuity on this channel ' + \
    (stateChange.resumed ? 'was' : 'was not') + ' preserved');
});

bc[ruby]. channel.on(:attached) do |channel_state_change|
  puts "channel #{channel.name} is now attached"
  puts "Message continuity #{channel_state_change.resumed ? 'was' : 'was not'} preserved"
end

bc[java]. channel.on(ChannelEvent.attached, new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelStateChange stateChange) {
    System.out.println("channel " + channel.name + " is now attached");
    if (stateChange.resumed) {
      System.out.println("Message continuity was preserved");
    } else {
      System.out.println("Message continuity was not preserved");
    }
  }
});

bc[csharp]. IRealtimeChannel channel = realtime.Channels.Get("chatroom");
channel.On(ChannelEvent.Attached, stateChange => {
  Console.WriteLine("channel " + channel.Name + " is now attached");
  if (stateChange.resumed) {
    Console.WriteLine("Message continuity was preserved");
  } else {
    Console.WriteLine("Message continuity was not preserved");
  }
});

bc[objc]. [channel on:ARTChannelEventAttached callback:^(ARTChannelStateChange *stateChange) {
  NSLog(@"channel %@ is now attached", channel.name);
  if (stateChange.resumed) {
    NSLog(@"Message continuity was preserved");
  } else {
    NSLog(@"Message continuity was not preserved");
  }
}];

bc[swift]. channel.on(.attached) { stateChange in
  print("channel \(channel.name) is now attached")
  if (stateChange.resumed) {
    print("Message continuity was preserved")
  } else {
    print("Message continuity was not preserved")
  }
}

bc[flutter]. final stateChangeListener = channel
  .on(ably.ChannelEvent.attached)
  .listen((ably.ChannelStateChange state) {
    print('channel ${channel.name} is now attached');
    if (stateChange.resumed) {
      print('Message continuity was preserved');
    } else {
      print('Message continuity was not preserved');
    }
  }
);

Alternatively a listener may be registered so that it receives all state change events.

bc[jsall](code-editor:realtime/channel-states). var myListener = function(stateChange) {
  console.log('channel state is ' + stateChange.current);
  console.log('previous state was ' + stateChange.previous);
  if(stateChange.reason) {
    console.log('the reason for the state change was: ' + stateChange.reason.toString());
  }
});
channel.on(myListener);

bc[ruby]. channel.on do |channel_state_change|
  puts "channel state is #{channel_state_change.current}"
end

bc[java]. channel.on(new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelStateChange stateChange, ErrorInfo reason) {
    System.out.println("channel state is " + ChannelState.values()[stateChange.current]);
  }
});

bc[csharp]. channel.On(stateChange => Console.WriteLine("channel state is " + stateChange.Current));

bc[objc]. ARTEventListener *listener = [channel on:^(ARTChannelStateChange *stateChange) {
    NSLog(@"channel state is %@", stateChange.current);
}];

bc[swift]. let listener = channel.on { stateChange in
    print("channel state is \(stateChange.current)")
}

bc[flutter]. final stateChangeListener = channel
  .on()
  .subscribe((ably.ChannelStateChange stateChange) {
    print('channel state is ${stateChange.current.toString().split('.').last}');
  }
);

Previously registered listeners can be removed individually or all together.

```[jsall]
  /* remove the listener registered for a single event */
  channel.off('attached', myListener);

  /* remove the listener registered for all events */
  channel.off(myListener);
```

```[ruby]
  # remove the listener proc registered for a single event
  channel.off(:attached, &my_proc)

  # remove the listener proc registered for all events
  channel.off(&my_proc)
```

```[java]
  /* remove the listener registered for a single event */
  channel.off(ChannelEvent.attached, channelStateListener);

  /* remove the listener registered for all events */
  channel.off(channelStateListener);
```

```[csharp]
  // remove the listener registered for a single event
  channel.Off(ChannelEvent.Attached, channelStateListener);

  // remove the listener registered for all events
  channel.Off(channelStateListener);
```

```[objc]
  // remove the listener registered for a single event
  [channel off:ARTChannelEventAttached listener:listener];

  // remove the listener registered for all events
  [channel off:listener];
```

```[swift]
  // remove the listener registered for a single event
  channel.off(.attached, listener: listener)

  // remove the listener registered for all events
  channel.off(listener)
```

```[flutter]
    // cancel stream subscription on the listener to stop receiving the events
    stateChangeListener.cancel();
```


h3(#channel-detach). Detaching from a channel

A client can detach from a channel so that it no longer receives any messages published to that channel. Detaching is different to unsubscribing from a channel because "@unsubscribe()@":/api/realtime-sdk/channels#unsubscribe is a client-side operation. The Ably platform does not know that a client has unsubscribed and will continue to stream messages to that client until "@Detach()@":/api/realtime-sdk/channels#detach is called.

bc[jsall]. channel.detach();
channel.on('detached', function(stateChange) {
  console.log('detached from the channel ' + channel.name);
};

bc[ruby]. channel.detach
channel.on(:detached) do |channel_state_change|
  puts "detached from the channel #{channel.name}"
end

bc[java]. channel.detach();
channel.on(ChannelEvent.detached, new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelState state, ErrorInfo reason) {
    System.out.println("detached from the channel " + channel.name);
    if (reason != null) System.out.println(reason.toString());
  }
});

bc[csharp]. Channel.Detach();
channel.On(ChannelEvent.Detached, stateChange => {
  Console.WriteLine("detached from the channel " + channel.Name)
});

bc[objc]. [channel detach]
[channel on:ARTChannelEventDetached callback:^(ARTChannelStateChange *stateChange) {
  NSLog(@"detached from the channel ", channel.name);
}];

bc[swift]. channel.detach()
channel.on(.detached) { stateChange in
  print("detached from the channel \(channel.name)")
}

bc[flutter]. channel.detach();
final stateChangeListener = channel
  .on(ably.ChannelEvent.detached)
  .listen((ably.ChannelStateChange state) {
    print('detached from the channel ${channel.name}');
  }
);

A channel will automatically close when there are no more realtime clients attached to it and approximately one minute has passed since the last client detached and since the last message was published to the channel.

h3(#handling-failures). Handling channel failures

Channel attach and detach operations are asynchronous - after initiating an attach request, the client will wait for a response from Ably that confirms that the channel is established on the service and then trigger a state change event.

The client libraries will attempt to automatically recover from non-fatal error conditions. However, you can handle them yourself if you prefer by subscribing to channel state changes, or <span lang="default">using the callbacks available</span><span lang="java">waiting for a result</span> when explicitly calling @attach@.

bc[jsall]. realtime.channels.get('private:chatroom').attach(function(err) {
  if (err) {
    console.error('Attach failed: ' + err);
  }
});

bc[ruby]. deferrable = realtime.channels.get('private:chatroom').attach
deferrable.errback do |error|
  puts "Attach failed: #{error}"
end

bc[java]. Channel channel = realtime.channels.get("private:chatroom");
channel.on(new ChannelStateListener() {
  @Override
  public void onChannelStateChanged(ChannelStateChange stateChange, ErrorInfo reason) {
    switch (stateChange.current) {
      case failed: {
        System.out.println("Attach failed: " + reason.message);
      }
    }
  }
});
channel.attach();

bc[csharp]. IRealtimeChannel privateChannel = realtime.Channels.Get("private:chatroom");
privateChannel.Attach((_, error) => {
    if (error != null)
    {
        Console.WriteLine("Attach failed: " + error.Message);
    }
});

bc[objc]. [[realtime.channels get:@"private:chatroom"] attach:^(ARTErrorInfo *error) {
    if (error) {
        NSLog(@"Attach failed: %@", error);
    }
}];

bc[swift]. realtime.channels.get("private:chatroom").attach { error in
    if let error = error {
        print("Attach failed: \(error)")
    }
}

bc[flutter]. Channel channel = realtime.channels.get('private:chatroom');
channel.on().listen((ably.ChannelStateChange stateChange) {
  switch (stateChange.current) {
    case ably.ChannelStateChange.failed: {
      System.out.println('Attach failed: ${stateChange.reason.message}');
    }
  }
});
channel.attach();

h4(#fatal-errors). Fatal channel errors

Some classes of errors are fatal. These cause the channel to move to the @FAILED@ state. The client library will not attempt any automatic recovery actions. For example: attempting to attach to a channel that the token you're using does not have the @subscribe@ capability for will cause that channel to enter the @FAILED@ state.

Note that while fatal errors won't get better on their own, they can be fixable. For example, if a channel goes into the @FAILED@ state due to the client not having the right capabilities to attach to it, that client could use "@Auth#authorize()@":/api/realtime-sdk/authentication#authorize to obtain a new token which does have the right capabilities, then call "@attach()@":/api/realtime-sdk/channels#attach on the channel. While the library will not automatically reattach in the @FAILED@ state, explicit calls to "@attach()@":/api/realtime-sdk/channels#attach will make the client try again.

h4(#nonfatal-errors). Nonfatal errors

Other types of errors are nonfatal. For example, a client may have network connectivity issues, or a channel may experience a loss of strict message continuity. The library will automatically attempt to recover from these events. If channel continuity is lost in the process, the library will notify you though a @resumed@ flag in the @ATTACHED@ or @UPDATE@ event, so you can decide how to handle that failure.

For every channel @ATTACHED@ and @UPDATE@ event, the "@ChannelStateChange@ object":/api/realtime-sdk/types#channel-state-change contains a @resumed@ attribute. When true, there has been no loss of continuity from the last time the channel was attached. When false, there has been a loss of continuity. So for example:

* The first time you attach to a channel on a fresh connection, @resumed@ will be false, as there was nothing to continue from.
* If you successfully "recover":/realtime/connection#connection-state-recovery a connection and reattach to your channels, the @resumed@ flag on the @ATTACHED@ events will tell you whether messages continuity was preserved. Any channel for which it's @true@ is guaranteed to receive every message it missed while the client was disconnected.
* If you "resume or recover":/realtime/connection#connection-state-recovery a connection unsuccessfully (so you get a fresh connection) — generally because you were disconnected for more than two minutes, which is how long Ably holds connection state for — continuity is lost. If you were resuming, all your channels (which will have gone into the @SUSPENDED@ state after two minutes) will still reattach automatically, and you will get @ATTACHED@ events with @resumed@ false.
* If Ably needs to signal a loss of message continuity on an attached channel (for example, during a partially successful resume where the client was disconnected for less than two minutes), you will get an @UPDATE@ event with @resumed@ false.

h4(#connection-state-change). Connection state change side effects on channels

* If the connection state becomes @CLOSED@, all channels will become @DETACHED@
* If the connection state becomes @FAILED@, all channels will become @FAILED@
* If the connection state becomes @SUSPENDED@, all previously-@ATTACHED@ or @ATTACHING@ channels will become @SUSPENDED@
* If the connection state becomes @CONNECTED@, any channels that were @SUSPENDED@ will be automatically reattached

h3(#channel-namespaces). Channel namespaces

<%= partial partial_version('shared/_channel_namespaces') %>

h2(#presence-api). Presence

Channels expose a <span lang="default">@presence@</span><span lang="csharp">@Presence@</span> member which a client can use to obtain channel presence information and to enter and leave the presence channel itself. See the "presence documentation":/realtime/presence for details.

h2(#api-reference). API Reference

View the "Channels and Channel API Reference":/api/realtime-sdk/channels.
