---
title: "JWTs"
meta_description: "JWT authentication is the recommended approach for authenticating clients with Ably. Create JWTs signed with your Ably API key."
---

JWT is the recommended token format for most applications. Your server creates a JWT signed with your Ably API key, and no Ably SDK is required on the server.

<Aside data-type='note'>
Use native [Ably Tokens](/docs/auth/ably-tokens) when:
- Your capability list is very large (exceeds JWT size limits)
- You need to keep capabilities confidential (JWTs can be decoded by clients)
</Aside>

## Quick start

Get a client connected with JWT authentication in two steps:

**1. Client setup** - fetch JWTs from your server:

<Code>
```javascript
const realtime = new Ably.Realtime({
  authCallback: async (tokenParams, callback) => {
    try {
      const response = await fetch('/api/ably-token');
      const jwt = await response.text();
      callback(null, jwt);
    } catch (error) {
      callback(error, null);
    }
  },
});
```
</Code>

**2. Server setup** - create JWTs (no Ably SDK required):

<Code>
```javascript
import jwt from 'jsonwebtoken';

const [keyName, keySecret] = process.env.ABLY_API_KEY.split(':');

app.get('/api/ably-token', (req, res) => {
  const ablyJwt = jwt.sign(
    {
      'x-ably-capability': JSON.stringify({ '*': ['publish', 'subscribe'] }),
      'x-ably-clientId': req.user.id,
    },
    keySecret,
    { algorithm: 'HS256', keyid: keyName, expiresIn: '1h' }
  );
  res.send(ablyJwt);
});
```
</Code>

## Client setup

### authCallback (recommended) <a id="auth-callback"/>

Use `authCallback` to fetch JWTs from your server. The SDK automatically calls this function when connecting and when the token is near expiry.

<Code>
```realtime_javascript
const realtime = new Ably.Realtime({
  authCallback: async (tokenParams, callback) => {
    try {
      const response = await fetch('/api/ably-token', {
        credentials: 'include',
      });
      if (!response.ok) throw new Error('Auth failed');
      callback(null, await response.text());
    } catch (error) {
      callback(error, null);
    }
  },
});
```

```realtime_python
import aiohttp

async def get_ably_jwt(*args, **kwargs):
    async with aiohttp.ClientSession() as session:
        async with session.get('/api/ably-token') as response:
            if response.status != 200:
                raise Exception(f"Auth failed: {response.status}")
            return await response.text()

realtime = AblyRealtime(auth_callback=get_ably_jwt)
```

```realtime_java
ClientOptions options = new ClientOptions();
options.authCallback = new Auth.TokenCallback() {
    @Override
    public Object getTokenRequest(Auth.TokenParams params) throws AblyException {
        // Make HTTP request to your auth server and return JWT string
        return fetchJwtFromServer();
    }
};
AblyRealtime realtime = new AblyRealtime(options);
```
</Code>

The [`tokenParams`](/docs/api/realtime-sdk/authentication#token-params) argument is available for convenience but should not be trusted. Your auth endpoint should authenticate clients separately using cookies, headers, or request body.

### authUrl <a id="auth-url"/>

You can specify an `authUrl` for simpler setups. The SDK makes a request to this URL to obtain a JWT.

<Code>
```realtime_javascript
const realtime = new Ably.Realtime({ authUrl: '/auth' });
```

```realtime_nodejs
const realtime = new Ably.Realtime({ authUrl: '/auth' });
```

```realtime_ruby
realtime = Ably::Realtime.new(auth_url: '/auth')
```

```realtime_python
  realtime = AblyRealtime(auth_url='/auth')
```

```realtime_java
ClientOptions options = new ClientOptions();
options.authUrl = "/auth";
AblyRealtime realtime = new AblyRealtime(options);
```

```realtime_objc
ARTClientOptions *options = [[ARTClientOptions alloc] init];
options.authUrl = [NSURL URLWithString:@"/auth"];
ARTRealtime *realtime = [[ARTRealtime alloc] initWithOptions:options];
```

```realtime_swift
let options = ARTClientOptions()
options.authUrl = NSURL(string: "/auth")
let realtime = ARTRealtime(options: options)
```

```realtime_csharp
ClientOptions options = new ClientOptions();
options.AuthUrl = new Uri("/auth");
AblyRealtime realtime = new AblyRealtime(options);
```

```realtime_go
client, err := ably.NewRealtime(ably.WithAuthURL("/auth"))
```

```realtime_flutter
final clientOptions = ably.ClientOptions(
    authUrl: '/auth'
);
final realtime = ably.Realtime(options: clientOptions);
```

```rest_javascript
  const rest = new Ably.Rest({ authUrl: '/auth' });
```

```rest_nodejs
  const rest = new Ably.Rest({ authUrl: '/auth' });
```

```rest_ruby
  rest = Ably::Rest.new(auth_url: '/auth')
```

```rest_python
  rest = AblyRest(auth_url='/auth')
```

```rest_php
  $rest = new Ably\AblyRest(['authUrl' => '/auth']);
```

```rest_java
  ClientOptions options = new ClientOptions();
  options.authUrl = "/auth";
  AblyRest rest = new AblyRest(options);
```

```rest_csharp
  AblyRest rest = new AblyRest(new ClientOptions { AuthUrl = new Uri("/auth") });
```

```rest_objc
  ARTClientOptions *options = [[ARTClientOptions alloc] init];
  options.authUrl = [NSURL URLWithString:@"/auth"];
  ARTRest *rest = [[ARTRest alloc] initWithOptions:options];
```

```rest_swift
  let options = ARTClientOptions()
  options.authUrl = NSURL(string: "/auth")
  let rest = ARTRest(options: options)
```

```rest_go
  client, err := ably.NewREST(ably.WithAuthURL("/auth"))
```

```rest_flutter
final clientOptions = ably.ClientOptions(
    authUrl: '/auth'
);
final rest = ably.Rest(options: clientOptions);
```
</Code>

An `authURL` is recommended for web-based clients as they can utilize cookies. For non-web clients, `authCallback` is the recommended strategy.

### AuthOptions <a id="auth-options"/>

Use properties set with [`AuthOptions`](/docs/api/realtime-sdk/authentication#auth-options) to customize authentication behavior:

- `authMethod` - when `authUrl` is called, the default `GET` method will be used, unless `POST` is specified.
- `authHeaders` - pass additional headers as required.
- `authParams` - pass additional query parameters.

<Code>
```realtime_javascript
const realtime = new Ably.Realtime({
  authUrl: "/auth",
  authMethod: "POST",
  authParams: {p1: param1, b: param2},
  authHeaders: {h1: header1, h2: header2}
});
```

```realtime_nodejs
const realtime = new Ably.Realtime({
  authUrl: "/auth",
  authMethod: "POST",
  authParams: {p1: param1, b: param2},
  authHeaders: {h1: header1, h2: header2}
});
```

```realtime_python
realtime = AblyRealtime(auth_url='/auth',
                        auth_method="GET",
                        auth_headers={'h1': 'v1'},
                        auth_params={'param1': 'param2'})
```

```realtime_go
headers := http.Header{}
headers.Set("h1", "header1")
headers.Set("h2", "header2")

client, err := ably.NewRealtime(
  ably.WithAuthURL("/auth"),
  ably.WithAuthMethod("GET"),
  ably.WithAuthHeaders(headers),
  ably.WithAuthParams(url.Values{
    "p1": {"param1"},
    "p2": {"param2"},
  }))
if err != nil {
  panic(err)
}
```

```realtime_flutter
final clientOptions = ably.ClientOptions(
  authUrl: '/auth',
  authMethod: 'GET',
  authParams: {
    'p1': 'param1',
    'b': 'param2',
  },
  authHeaders: {
    'h1': 'header1',
    'h2': 'header2',
  },
);
final realtime = ably.Realtime(options: clientOptions);
```

```realtime_java
ClientOptions options = new ClientOptions();
options.authUrl = "/auth";
options.authMethod = "POST";
options.authParams = new Param[]{
        new Param("p1", "param1"),
        new Param("p2", "param2")
};
options.authHeaders = new Param[]{
        new Param("h1", "header1"),
        new Param("h2", "header2")
};

AblyRealtime realtime = new AblyRealtime(options);
```

```rest_javascript
const rest = new Ably.Rest({
  authUrl: "/auth",
  authMethod: "POST",
  authParams: {p1: param1, b: param2},
  authHeaders: {h1: header1, h2: header2}
});
```

```rest_nodejs
const rest = new Ably.Rest({
  authUrl: "/auth",
  authMethod: "POST",
  authParams: {p1: param1, b: param2},
  authHeaders: {h1: header1, h2: header2}
});
```

```rest_python
rest = AblyRest(auth_url='/auth',
                    auth_method="GET",
                    auth_headers={'h1': 'v1'},
                    auth_params={'param1': 'param2'})
```

```rest_go
headers := http.Header{}
headers.Set("h1", "header1")
headers.Set("h2", "header2")

client, err := ably.NewREST(
  ably.WithAuthURL("/auth"),
  ably.WithAuthMethod("GET"),
  ably.WithAuthHeaders(headers),
  ably.WithAuthParams(url.Values{
    "p1": {"param1"},
    "p2": {"param2"},
  }))
if err != nil {
  panic(err)
}
```

```rest_flutter
final clientOptions = ably.ClientOptions(
  authUrl: '/auth',
  authMethod: 'GET',
  authParams: {
    'p1': 'param1',
    'b': 'param2',
  },
  authHeaders: {
    'h1': 'header1',
    'h2': 'header2',
  },
);
final rest = ably.Rest(options: clientOptions);
```

```rest_java
ClientOptions options = new ClientOptions();
options.authUrl = "/auth";
options.authMethod = "POST";
options.authParams = new Param[]{
        new Param("p1", "param1"),
        new Param("p2", "param2")
};
options.authHeaders = new Param[]{
        new Param("h1", "header1"),
        new Param("h2", "header2")
};

AblyRest rest = new AblyRest(options);
```
</Code>

## Server setup

### Creating JWTs <a id="creating-jwts"/>

Your server creates JWTs signed with your Ably API key secret. No Ably SDK is required. Any JWT library works.

<If lang="flutter">
To generate a JWT token in Flutter, you will need to install the [`crypto`](https://pub.dev/packages/crypto) library
</If>

<If lang="java">
To generate a JWT token in Java, you will need to install the [`java-jwt`](https://github.com/auth0/java-jwt) library.
</If>

<Code>
```javascript
  var header = {
    "typ":"JWT",
    "alg":"HS256",
    "kid": "{{API_KEY_NAME}}"
  }
  var currentTime = Math.round(Date.now()/1000);
  var claims = {
    "iat": currentTime, /* current time in seconds */
    "exp": currentTime + 3600, /* time of expiration in seconds */
    "x-ably-capability": "{\"*\":[\"*\"]}"
  }
  var base64Header = btoa(header);
  var base64Claims = btoa(claims);
  /* Apply the hash specified in the header */
  var signature = hash((base64Header + "." + base64Claims), "{{API_KEY_SECRET}}");
  var ablyJwt = base64Header + "." + base64Claims + "." + signature;
```

```python
  import jwt
  import time

  def createAblyJwt(ably_api_key: str):
      # Split the API key into key ID and secret
      parts = ably_api_key.split(":")
      kid = parts[0]

      # Prepare JWT headers
      headers = {
          "typ": "JWT",
          "alg": "HS256",
          "kid": kid
      }

      # Prepare JWT claims
      claims = {
          "iat": int(time.time()),  # Issued at time
          "exp": int(time.time()) + 120,  # Expiration time (2 minutes from now)
          "x-ably-capability": "{\"*\":[\"*\"]}"  # Full capability
      }

      # Encode the JWT
      jwtToken = jwt.encode(headers=headers, payload=claims, key=parts[1])
      return jwtToken
```

```java
Map<String, Object> headerClaims = new HashMap<>();
headerClaims.put("typ", "JWT");
headerClaims.put("alg", "HS256");
headerClaims.put("kid", "{{API_KEY_NAME}}");

// Define the current time
long currentTimeInSeconds = System.currentTimeMillis() / 1000;

// Define the claims
Map<String, Object> claims = new HashMap<>();
claims.put("iat", currentTimeInSeconds);
claims.put("exp", currentTimeInSeconds + 3600);
claims.put("x-ably-capability", "{\"*\":[\"*\"]}");

// Create the JWT
Algorithm algorithm = Algorithm.HMAC256("{{API_KEY_SECRET}}");
String token = JWT.create()
        .withHeader(headerClaims)
        .withPayload(claims)
        .sign(algorithm);
```

```php
$header = [
    'typ' => 'JWT',
    'alg' => 'HS256',
    'kid' => '{{API_KEY_NAME}}'
];
$currentTime = time();
$claims = [
    'iat' => $currentTime, /* current time in seconds */
    'exp' => $currentTime + 3600, /* time of expiration in seconds (an hour) */
    'x-ably-capability' => '{\"*\":[\"*\"]}'
];
$base64Header = base64_encode(json_encode($header));
$base64Claims = base64_encode(json_encode($claims));
$signature = hash_hmac(
    'sha256',
    $base64Header . '.' . $base64Claims,
    '{{API_KEY_SECRET}}',
    true
);
$jwt = $base64Header . '.' . $base64Claims . '.' . $signature;
```

```go
  // Create JWT header
  header := map[string]string{
    "typ": "JWT",
    "alg": "HS256",
    "kid": "{{API_KEY_NAME}}",
  }

  // Get current time in seconds
  currentTime := time.Now().Unix()

  // Create JWT claims
  claims := map[string]interface{}{
    "iat":               currentTime,        // current time in seconds
    "exp":               currentTime + 3600, // time of expiration in seconds
    "x-ably-capability": "{\"*\":[\"*\"]}",
  }

  // Encode header to base64
  headerJSON, err := json.Marshal(header)
  if err != nil {
    log.Fatalf("Failed to marshal header: %v", err)
  }
  base64Header := base64.RawURLEncoding.EncodeToString(headerJSON)

  // Encode claims to base64
  claimsJSON, err := json.Marshal(claims)
  if err != nil {
    log.Fatalf("Failed to marshal claims: %v", err)
  }
  base64Claims := base64.RawURLEncoding.EncodeToString(claimsJSON)

  // Create the signature
  dataToSign := base64Header + "." + base64Claims
  h := hmac.New(sha256.New, []byte("{{API_KEY_SECRET}}"))
  h.Write([]byte(dataToSign))
  signature := base64.RawURLEncoding.EncodeToString(h.Sum(nil))

  // Combine the parts to form the final JWT
  ablyJwt := base64Header + "." + base64Claims + "." + signature
  log.Println("Ably JWT:", ablyJwt)
```

```flutter
final header = {
  "typ": "JWT",
  "alg": "HS256",
  "kid": "{{API_KEY_NAME}}"
};

final currentTime = (DateTime.now().millisecondsSinceEpoch / 1000).round();
final claims = {
  "iat": currentTime, /* current time in seconds */
  "exp": currentTime + 3600, /* time of expiration in seconds */
  "x-ably-capability": "{\"*\":[\"*\"]}"
};

final base64Header = base64UrlEncode(utf8.encode(json.encode(header)));
final base64Claims = base64UrlEncode(utf8.encode(json.encode(claims)));
final hmacSha256 = Hmac(sha256, utf8.encode("$base64Header.$base64Claims"));
final digest = hmacSha256.convert(utf8.encode("{{API_KEY_SECRET}}"));
final signature = base64UrlEncode(digest.bytes);
final ablyJwt = "$base64Header.$base64Claims.$signature";
```
</Code>

At present Ably does not support asymmetric signatures based on a key pair belonging to a third party.

### JWT claims <a id="jwt-claims"/>

| Claim | Required | Description |
|-------|----------|-------------|
| `x-ably-capability` | Yes | JSON string defining [capabilities](/docs/auth/capabilities) |
| `x-ably-clientId` | No | Sets a trusted [client ID](/docs/auth/identified-clients) |
| `exp` | Yes | Expiration time (Unix timestamp) |
| `iat` | Yes | Issued at time (Unix timestamp) |

## JWT features

JWTs support features not available with other token mechanisms.

### Channel-scoped claims <a id="channel-claims"/>

Embed trusted metadata in JWTs that other clients can read. Use the `ably.channel.*` claim pattern:

<Code>
```javascript
const ablyJwt = jwt.sign(
  {
    'x-ably-capability': JSON.stringify({
      'chat:*': ['publish', 'subscribe', 'presence'],
    }),
    'x-ably-clientId': userId,
    // Channel-scoped claim - other clients can read this
    'ably.channel.chat:lobby': JSON.stringify({
      role: 'moderator',
      displayName: 'Alice',
    }),
  },
  keySecret,
  { algorithm: 'HS256', keyid: keyName, expiresIn: '1h' }
);
```
</Code>

Other clients can read these claims from presence or message metadata, providing trusted user information without additional server calls.

### Per-connection rate limits <a id="rate-limits"/>

Restrict how fast specific clients can publish messages using the `ably.limits.publish.*` claim:

<Code>
```javascript
const ablyJwt = jwt.sign(
  {
    'x-ably-capability': JSON.stringify({ '*': ['publish', 'subscribe'] }),
    'x-ably-clientId': userId,
    // Per-connection rate limit - max 10 messages per second
    'ably.limits.publish.perAttachment.maxRate.*': 10,
  },
  keySecret,
  { algorithm: 'HS256', keyid: keyName, expiresIn: '1h' }
);
```
</Code>

<Aside data-type='important'>
**JWT-only features:** Channel-scoped claims and per-connection rate limits are only available with JWTs. If you use [Ably Tokens](/docs/auth/ably-tokens), you will not have access to these features.
</Aside>

## Token mechanism comparison <a id="comparison"/>

| Feature | JWT (Recommended) | TokenRequest | Ably Token (direct) | Embedded Token JWT |
|---------|:-----------------:|:------------:|:-------------------:|:------------------:|
| **Server SDK required** | No | Yes | Yes | Yes |
| **Client round-trip to Ably** | No | Yes | No | No |
| **Channel-scoped claims** | Yes | No | No | No |
| **Per-connection rate limits** | Yes | No | No | No |
| Works with any MQTT client | Yes | Yes | Yes | Yes |
| Automatic SDK token refresh | Yes | Yes | Yes | Yes |
| Capabilities hidden from client | No | Yes | Yes | Yes |

## Common scenarios <a id="scenarios"/>

### Standard application <a id="scenario-standard"/>

For web and mobile applications, create an endpoint that validates users and returns JWTs. This works with any authentication system: sessions, JWT middleware (Auth0, Firebase, Cognito), or custom auth.

#### Server (no Ably SDK required)

<Code>
```rest_nodejs
import jwt from 'jsonwebtoken';

const [keyName, keySecret] = process.env.ABLY_API_KEY.split(':');

app.get('/api/ably-token', async (req, res) => {
  // Validate user with your auth system (session, JWT middleware, etc.)
  const userId = req.user?.id || req.session?.userId;
  if (!userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const ablyJwt = jwt.sign(
    {
      'x-ably-capability': JSON.stringify({
        '*': ['publish', 'subscribe', 'presence'],
      }),
      'x-ably-clientId': userId,
    },
    keySecret,
    { algorithm: 'HS256', keyid: keyName, expiresIn: '1h' }
  );

  res.send(ablyJwt);
});
```

```rest_python
from flask import Flask, request, session
import jwt
import os
import json
import time

app = Flask(__name__)
api_key = os.environ['ABLY_API_KEY']
key_name, key_secret = api_key.split(':')

@app.route('/api/ably-token')
def get_token():
    # Validate user with your auth system
    user_id = getattr(request, 'user', {}).get('id') or session.get('user_id')
    if not user_id:
        return {'error': 'Not authenticated'}, 401

    now = int(time.time())
    ably_jwt = jwt.encode(
        {
            'iat': now,
            'exp': now + 3600,
            'x-ably-capability': json.dumps({
                '*': ['publish', 'subscribe', 'presence'],
            }),
            'x-ably-clientId': user_id,
        },
        key_secret,
        algorithm='HS256',
        headers={'kid': key_name}
    )

    return ably_jwt
```
</Code>

#### Client

<Code>
```realtime_javascript
const realtime = new Ably.Realtime({
  authCallback: async (tokenParams, callback) => {
    try {
      const response = await fetch('/api/ably-token');
      const token = await response.text();
      callback(null, token);
    } catch (error) {
      callback(error, null);
    }
  },
});
```
</Code>

### IoT and serverless <a id="scenario-serverless"/>

For IoT devices and serverless functions, JWTs are ideal because they require no SDK and are stateless.

#### Serverless function (AWS Lambda, Cloud Functions)

<Code>
```rest_nodejs
import jwt from 'jsonwebtoken';

const [keyName, keySecret] = process.env.ABLY_API_KEY.split(':');

export const handler = async (event) => {
  const userId = event.requestContext.authorizer.claims.sub;

  const ablyJwt = jwt.sign(
    {
      'x-ably-capability': JSON.stringify({ '*': ['*'] }),
      'x-ably-clientId': userId,
    },
    keySecret,
    { algorithm: 'HS256', keyid: keyName, expiresIn: '1h' }
  );

  return { statusCode: 200, body: ablyJwt };
};
```
</Code>

#### IoT device provisioning

<Code>
```rest_python
import jwt
import time
import json
import os

def create_device_jwt(device_id: str) -> str:
    api_key = os.environ['ABLY_API_KEY']
    key_name, key_secret = api_key.split(':')

    now = int(time.time())
    return jwt.encode(
        {
            'iat': now,
            'exp': now + 86400,  # 24 hours
            'x-ably-capability': json.dumps({
                f'devices:{device_id}': ['publish'],
                'control': ['subscribe'],
            }),
            'x-ably-clientId': device_id,
        },
        key_secret,
        algorithm='HS256',
        headers={'kid': key_name}
    )
```
</Code>

Devices can use this JWT with any MQTT client. See [MQTT with JWT authentication](/docs/protocols/mqtt#jwt-auth) for examples.

## Token refresh <a id="refresh"/>

One of the important benefits of using an Ably SDK is that automatic token refresh is handled for you.

When you provide either an `authUrl` or an `authCallback`, the SDK automatically:
1. Calls your auth endpoint when connecting
2. Requests a new token before the current token expires
3. Maintains the connection seamlessly during refresh

### Token TTL limits

Ably enforces maximum TTL (time-to-live) limits on tokens:

- Access tokens: Maximum TTL of 24 hours.
- Device tokens (for push notifications): Maximum TTL of 5 years.
- Revocable tokens: Maximum TTL of 1 hour (when [token revocation](/docs/auth/revocation) is enabled).

<Aside data-type="important">
Attempting to create a token with a TTL that exceeds these limits will result in an error code [40003](/docs/platform/errors/codes#40003).
</Aside>

## Dynamic channel access control <a id="dynamic-access"/>

Token authentication allows you to dynamically change a client's channel access permissions without disconnecting. Use the [`authorize()`](/docs/api/realtime-sdk/authentication#authorize) method to re-authenticate with updated [capabilities](/docs/auth/capabilities).

When you call `client.auth.authorize()`:

1. The client obtains a new token with different capabilities from your authentication server.
2. The new token is sent to Ably using the existing realtime connection.
3. The updated permissions are automatically applied without disconnecting.

### Use cases

You can trigger re-authentication in response to:
- Detect error code [40160](/docs/platform/errors/codes#40160) when a client attempts to attach to a channel.
- Instruct clients to re-authenticate via Ably channels or other communication methods.

<If lang="javascript">
The following example shows how to re-authenticate with updated capabilities:

<Code>
```javascript
// Re-authenticate to get new capabilities
try {
  const newTokenDetails = await client.auth.authorize({
    clientId: 'user123',
    // Your auth server will return a token with updated capabilities
  });
  console.log('Successfully updated permissions');
} catch (error) {
  console.error('Failed to re-authenticate:', error);
}
```
</Code>
</If>

For security purposes, handle non-compliant clients by:
- Set shorter token TTL expiry times to force frequent re-authentication (minimum 10 minutes recommended).
- Use the [token revocation API](/docs/auth/revocation) to immediately invalidate tokens.

<Aside data-type="important">
The `authorize()` method maintains the existing connection while updating permissions, making it ideal for real-time applications where connection continuity is important.
</Aside>

## When to use Ably Tokens instead

Use [Ably Tokens](/docs/auth/ably-tokens) when:

- **Capability list is very large**: JWTs have size limits. If your capabilities JSON is very large, use a TokenRequest.
- **Capabilities must be confidential**: JWTs can be decoded by clients. If you need to hide what capabilities a token has, use an Ably Token.
- **Existing JWT infrastructure**: If you already have a JWT-based auth system and want to embed Ably tokens within your existing JWTs, use an Embedded Token JWT.
