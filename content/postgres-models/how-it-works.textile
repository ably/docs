---
title: How it works
meta_description: "LiveSync enables you to synchronize changes in your database to frontend clients at scale."
product: livesync
---

LiveSync Postgres and Models SDK has three key components:

# *Postgres Database connector* that watches changes in your database broadcast those updates over Ably channels.
# *Models SDK* in the frontend that merges changes into your models and supports optimistic updates for the publisher.
# *Pub/Sub* channels that form the mechanism behind the scenes to broadcast updates from the postgres connector to the frontend models.

<a href="@content/diagrams/what-is-livesync.png" target="_blank">
  <img src="@content/diagrams/what-is-livesync.png" style="width: 100%" alt="What is LiveSync">
</a>

h2(#postgres-connector). Postgres Database connector

The "Postgres database connector":/postgres-models/postgres-connetor watches for changes in your database and will publish those as messages over Ably channels. The connector is a standalone service that you can "self-host":postgres-models/postgres-connector#self-hosted in your infrastructure. Ably also provides a "hosted version":http://localhost:8000/postgres-models/postgres-connector#hosted-with-ably of the connector that you can use.

The connector makes use of the outbox pattern to track changes in your database. Records that you write to the "outbox table":/postgres-models/postgres-connector#table-schema will be read by the database connector and published as messages to Ably Pub/Sub channels.

h2(#models-sdk). Models SDK

The "Models SDK":/postgres-models/models-sdk is a library that you can include in your frontend application to listen to changes in your database. The SDK will merge those changes into your models and support optimistic updates for the publisher. The SDK is available as a "NPM package":npm-package.

[npm-package]https://www.npmjs.com/package/@ably-labs/models

h2(#use-cases). Use cases

LiveSync can benefit a wide range of applications including Customer Relationship Management (CRM) applications, customer support applications, productivity or task management applications, online auctions, collaborative form editing, e-commerce systems, chat conversations, multiplayer turn-based games and realtime newsfeeds. You can enable collaboration between multiple users, while ensuring the app data is always securely stored in your own database and serves as the final source of truth.

To understand this further, let's take the example of a CRM application -- In a CRM app, an individual customer details page can be represented as a single data model with its own channel. When a user updates the customer's information, optimistic updates can immediately reflect the changes in the UI while the confirmation goes to a roundtrip through the database. When confirmed, the original user's UI update can be confirmed and all other clients can also see that update without needing to refresh the page.

h2(#limitations). Known limitations

LiveSync's current design might be limiting to data models that rely on graph data structures. Each data model and access to that model is based on a dedicated Pub/Sub channel, any application changes that apply to multiple data models will need to be published separately using the outbox table to each model's channel.

Postgres LiveSync with Models SDK uses the database as the source of conflict resolution, based on last-write-wins. That is, when transactionally writing to the DB, the conflict resolution of model changes is done by the transaction ordering and serialisation in Postgres. This works well for lots of types of concurrent updates, but might not work for every case.

To compensate, LiveSync can be easily coupled with the component locking feature in "Spaces":/products/spaces to make sure the individual UI components can be locked; avoiding the need to resolve conflicts.  For most use-cases like collaborative form building, component locking might actually a better user experience compared to co-editing capabilities.
