---
title: How LiveSync works
meta_description: "LiveSync enables you to synchronize changes in your database to frontend clients at scale."
product: livesync
---

LiveSync is a powerful realtime data synchronization feature designed to facilitate broadcasting realtime updates from backend databases to frontend clients at scale. Leveraging Pub/Sub Channels, LiveSync ensures that data updates are propagated reliably and in order to all connected clients in realtime.

LiveSync can be used for realtime collaboration, including collaborative form editing, online auctions, task management applications, or simple multiplayer turn-based games, where maintaining data consistency and low latency are important. Furthermore, developers can also build highly responsive and interactive applications with the optimistic updates design pattern offered out of the box.

LiveSync has three key components, 1) a Models SDK that facilitates optimistic updates for the publisher and helps merge confirmed changes from the backend with the overall frontend state 2) a Database Connector at the backend that can watch changes in your database table using the outbox pattern and broadcast those updates and 3) the default Ably Pub/Sub channels that form the mechanism behind the scenes to broadcast those updates.

<a href="@content/diagrams/what-is-livesync.png" target="_blank">
  <img src="@content/diagrams/what-is-livesync.png" style="width: 100%" alt="What is LiveSync">
</a>

h2(#channel-based-broadcasting). Channel-based broadcasting

The mechanism for synchronizing data updates across devices using Ably's LiveSync uses Ably's "pub/sub channels":https://ably.com/docs/channels to publish realtime messages to subscribers. When a message is published on an Ably channel, it is immediately broadcasted to all subscribers of that channel. Similarly, with LiveSync, data updates added to the outbox table are then published to all subscribed clients in realtime, ensuring seamless data synchronization from the database to all clients.

h2(#frontend). Frontend

Clients consume realtime updates reflecting database tables through the Models SDK, which carries out the following steps:

h3(#initial-load). Initial state load

When a client initiates the LiveSync Models SDK, for example, when the page is loaded, it will call the @sync@ function. The @sync@ function retrieves the initial state of the model from your backend and stores it within your applications state.

h3(#receiving-messages). Receiving a message

In the Models SDK, incoming messages on a channel trigger the @merge@ function, which integrates the message content into the existing state of your application.

h3(#subscribing). Subscribing to changes

In the Models SDK, you can subscribe to a model to receive its updated state whenever changes occur. This enables you to seamlessly integrate the updated model state into your user interface or react to changes in various ways.

h3(#optimistic-updates). Optimistic updates

@Optimistic@ updates enhance UI responsiveness, allowing updates to be applied optimistically in the UI before being confirmed in the database. Each optimistic update is associated with a mutation ID, which enables tracking and matching with events received on the channel. This ID should be included in the mutation sent to your backend and recorded in the outbox table to confirm or reject the update. Unconfirmed optimistic updates will be rolled back by the Models SDK automatically.

h2(#backend). Backend

h3(#outbox-table). Database Outbox table

The @outbox table@ serves as the equivalent of publishing to clients subscribed with Ably LiveSync. Automatically reacting to new records written to the outbox, the database connector publishes these records to clients. This approach ensures transactionality between database changes and records published to clients, enhancing data consistency and reliability.

h3(#sequence-id). Sequence ID

The Models SDK utilizes a sequence ID to ensure accurate matching of the model's state with the corresponding point in the change events stream obtained from Ably. This sequence ID, retrieved from your backend during the @sync@ function call, enables the Models SDK to synchronize the model's state effectively during the initial load process.

h2(#use-cases). Use-cases

There are many possible problems that LiveSync can solve or simplify for projects. Below is a list of some products / applications that LiveSync can help along with some of the data models that would be involved:

Similarly to "CRM systems":#crm-systems above, LiveSync would assist on a specific task within a task management application, rendering the details and updating when a change has been persisted to the database by another person or part of the system.

| Customer relationship management (CRM) systems | Within a CRM system, an individual customer page would be represented as a single data Model with its own channel. When a user updates the customer's information, optimistic updates can be used to show in the UI the update as greyed until the server returns a confirmation or rejection. The server will save this change in the database. The Database Connector will pick this change up and publish the changes to the frontend where the Model will update and reflect the changes in the UI for every actively subscribed frontend client. |
| Customer support applications | Similarly to the CRM systems above, the individual entities being updated and viewed will be those seeking support. |
| Productivity applications / Task management apps | Similar to CRM systems above the task management system would be represented as a Model, when someone adds a task or updates an existing task, optimistic updates can show this change as grey for the user making the change. The server will then confirm or reject the change, where the Database Connector will pick up this change and publish it to the frontend clients to render the changes in the UI. |
| Online auction | A single lot would be represented as a single data Model with its own channel. When a user makes a bid, optimistic updates can show their bid in the UI as grey until the server processes the bid and updates the database, the single source of truth. The Database Connector will pick up this update and publish these changes to the frontend to be picked up by the Model. |
| Collaborative form editing and building | LiveSync integrates seamlessly with tools like "Spaces":/products/spaces. Each collaborative form would be represented as a single data Model. When a collaborator locked a form element, this event will be sent to the server, optimistic updates can show this element as locked in the UI for the collaborator until the server confirms the locking or rejects it. The Database Connector will pick up this result and publish a confirmation or rejection to the frontend. The Model in the frontend will then update the UI to relect this result. Other updates can be when a field is successfully modified or unlocked. |
| Inventory availability in ecommerce | An inventory item would be represented as a single data Model with its own channel. This model would contain available sizes, item counts, among other key pieces of updatable information. When a customer makes a purchase, this will be stored in the database, and the remaining inventory would be updated. The Database Connector would pick up and publish these changes to the frontend where the Model will reflect the changes in the UI. |
| Chat applications | Short and transient chat conversations such as customer service chats would be represented as a single data Model with its own channel. When a new message is sent by customer, optimistic updates can show this message in the chat UI as grey until the server processes the message and updates the database. The Database Connector will pick up this new message and publish these changes to the frontend to be confirmed as valid or rejected. |
| Simple multiplayer turn-based games (e.g. multiplayer scrabble) | The game state, such as the letters on the Scrabble board, can be represented as a Model. When a player takes their turn, optimistic updates can show their action in the UI as grey until the server processes the action and updates the database. The Database Connector will pick up this update and publish these changes to the frontend to be picked up by the Model and confirm or reject the turn by the player. |
| Realtime news feeds | Each news post would be represented as a single data Model with its own channel. When a new post is added to the database, or an existing one is updated, the Database Connector will pick this up and publish these changes to the frontend to be picked up by the model and update the UI for all actively connected frontend clients. A possible use for optimistic updates is when submitting a comment on a news post or reacting to the post such as with a thumbs up or thumbs down. |

h2(#development-status). Development status

LiveSync is in public alpha so that you can explore its capabilities. Your "feedback":https://docs.google.com/forms/d/e/1FAIpQLSd00n1uxgXWPGvMjKwMVL1UDhFKMeh3bSrP52j9AfXifoU-Pg/viewform will help prioritize improvements and fixes in a subsequent release. The features have been validated for a set of use-cases and are stable and perform well, but API changes may occur that impact functionality. The alpha is implemented to work under real-world situations and load, but you should use caution when deciding under what conditions to use it.
