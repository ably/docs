---
title: "Guide: Integrate external systems with Ably Chat"
meta_description: "Extend Ably Chat with external integrations: process messages with AI, webhooks, and custom logic at scale."
meta_keywords: "chat integrations, external systems, webhooks, AI chat, message processing, chat automation, integration rules, message routing"
---

Ably Chat is designed for extensibility. Whether you need to process messages with AI, translate content in real-time, trigger business workflows, or enrich messages with external data, Ably's integration capabilities enable you to extend your chat application without compromising on scale, reliability, or performance.

This guide explains how to architect integrations that process chat messages through external systems and respond back to the chat in real-time. Before diving into the technical implementation, it's important to understand your architectural goals and the role your external system will play.

## Why integrate external systems?

Integrating external systems with Ably Chat enables you to extend your chat application beyond simple message delivery. Common integration use cases include:

* **AI-powered assistants:** Process commands or questions through language models and respond with helpful information.
* **Real-time translation:** Automatically translate messages for multilingual chat rooms.
* **Content enrichment:** Expand URLs into rich previews, detect and process mentions, or add contextual information.
* **Analytics and monitoring:** Analyze sentiment, track engagement metrics, or identify trending topics.
* **Workflow automation:** Trigger external business processes based on chat activity.
* **Command processing:** Handle slash commands that invoke server-side logic.

Unlike [chat moderation](/docs/chat/moderation), which filters or blocks content before or after publication, integrations focus on processing messages and responding with new content or triggering external actions. Also unlike [exporting chat data](/docs/guides/chat/export-chat), which stores all messages for long-term retention, integrations process specific messages matched by integration rules.

## Why Ably for external integrations?

Ably Chat integrations are built on Ably's proven platform architecture, designed to handle integration workloads at any scale:

* **Reliable message delivery:** Every integration benefits from Ably's [four pillars of dependability](/docs/platform/architecture): Performance, Integrity, Reliability, and Availability.
* **Flexible routing:** Use channel filters to selectively route only the messages on channels that need processing to your integration.
* **Multiple integration methods:** Choose webhooks, queues, or streaming based on your architecture and scale requirements.
* **Proven at scale:** Ably processes over 500 million messages per day for customers, with [serverless scalability](/docs/platform/architecture/platform-scalability) that eliminates infrastructure management.
* **No vendor lock-in:** Integrate with any external service, using any language or platform that can handle HTTP requests or consume from queues.

Because Ably Chat rooms use Pub/Sub channels as their underlying transport, you can leverage all of Ably's [platform integrations](/docs/platform/integrations) to extend your chat application.

## Key considerations <a id="key-considerations"/>

Consider the following when integrating external systems with Ably Chat:

* **Processing latency:** Integration adds latency to the message flow. Webhooks offer the lowest latency, while queues add asynchronous processing time. Design your system to handle the expected processing time.
* **Avoiding infinite loops:** When your integration responds back to chat, ensure responses don't trigger the same integration rule. Use separate channels or the [privileged skip integration flag](/docs/platform/integrations/skip-integrations) to break potential loops.
* **Scale and reliability:** Different integration methods offer different reliability guarantees. Webhooks have limited retry windows, while queues provide guaranteed delivery with dead letter queues.
* **External system limitations:** Your external service may have rate limits, processing constraints, or availability issues. Implement retry logic, circuit breakers, and caching to handle these limitations gracefully.
* **Cost optimization:** Only process messages that require processing. Use channel filters and message headers to minimize unnecessary integration executions.
* **Security:** Validate webhook signatures, use token authentication with limited capabilities, and never embed API keys in client code.

## Implementation options <a id="implementation-options"/>

With your strategy in mind, choose the technical approach that fits your needs:

1. Using [outbound webhooks](#webhook). [HTTP endpoint](/docs/platform/integrations/webhooks/generic), [AWS Lambda](/docs/platform/integrations/webhooks/lambda), and others.
2. Using [Ably queues](#ably-queue).
3. Using [outbound streaming](#outbound-streaming). Stream to your own [Kafka](/docs/platform/integrations/streaming/kafka), [Kinesis](/docs/platform/integrations/streaming/kinesis), and others.

## Understanding the integration pattern

Ably Chat integrations follow a message-driven architecture that enables bidirectional communication between your chat application and external systems.

### Core concepts

* **Chat rooms use Pub/Sub channels:** Each chat room is built on an Ably channel, enabling the full range of Ably's integration capabilities.
* **Message structure:** Chat messages are encoded as Pub/Sub messages with a specific structure. See the [Chat integrations documentation](/docs/chat/integrations) for details on the mapping.
* **Integration rules:** Configure rules that filter which messages trigger integrations based on channel name patterns and event types.
* **Bidirectional flow:** Integrations can both receive messages from chat and publish responses back to the chat room.

### Integration flow

The typical integration flow works as follows:

1. A user sends a message to a chat room, optionally including headers, metadata, or trigger patterns.
2. The message is published to the Ably Chat channel.
3. An integration rule evaluates the message based on channel name pattern matching.
4. If the rule matches, Ably forwards the message to your external system via the configured integration method.
5. Your external system processes the message (AI inference, translation, business logic, etc.).
6. The external system publishes a response back to an Ably Chat channel.
7. All subscribed clients receive the response in real-time.

**Diagram:** *Integration flow showing: Client → Ably Chat → Integration Rule → External System → Response → Ably Chat → Clients*

### Triggering integrations

Integration rules are triggered by **channel name patterns** only. Use consistent channel naming conventions to route messages from specific chat rooms to your integration.

**Channel naming patterns:**

Use typical chat room naming patterns like `chat:support` for support channels or `chat:group:123` for group chats. The integration rule's channel filter is a regular expression that matches against the channel name.

<Code>
```javascript
// Get a chat room - this determines which channel the message goes to
const supportRoom = await chatClient.rooms.get('chat:support');
const groupRoom = await chatClient.rooms.get('chat:group:123');
const generalRoom = await chatClient.rooms.get('chat:general');

// Messages sent to these rooms will trigger an integration
// if your rule's channel filter is: ^chat:support.*
await supportRoom.messages.send({ text: 'Need help' });

// Or for a specific group
await groupRoom.messages.send({ text: 'Hello' });

// Messages sent to other channel patterns will NOT trigger the integration
await generalRoom.messages.send({ text: 'Hi' }); // Won't trigger if filter is ^chat:support.*
```
</Code>

**Using metadata and headers for message routing:**

Your external system receives all messages from channels matching the integration rule's filter. Use message headers or metadata to efficiently route messages to the appropriate handler:

<Code>
```javascript
const Ably = require('ably');

// In your webhook handler or queue consumer
function processIntegrationPayload(envelopeData) {
  // Decode messages using Ably SDK
  const messages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of messages) {
    const text = msg.data?.text;
    const headers = msg.extras?.headers || {};
    const metadata = msg.data?.metadata || {};

    // Use headers for efficient routing (no string parsing needed)
    const action = headers['x-integration-action'];

    switch (action) {
      case 'weather':
        // Handle weather command
        handleWeatherRequest(text, envelopeData.channel);
        break;

      case 'translate':
        // Handle translation request
        const targetLang = headers['x-target-language'] || 'es';
        handleTranslation(text, targetLang, envelopeData.channel);
        break;

      case 'analyze':
        // Handle analysis request
        handleAnalysis(text, metadata, envelopeData.channel);
        break;

      default:
        // Ignore messages without integration actions
        break;
    }
  }
}
```
</Code>

This approach is more efficient than string parsing and provides clean separation between user-visible content and integration routing logic.

## Filtering rooms and event types <a id="filtering"/>

Integrations allow you to filter which Ably channels are forwarded to your external system using a regular expression on the channel name. This is a simple way to reduce the volume of messages you need to process by only receiving messages from the chat rooms you are interested in. Use a common prefix in the name of chat rooms that you want to trigger an integration for, and use the prefix as the filter.

Use `channel.message` as the event type for all integration types. This will forward all messages published to the relevant channels and exclude presence messages and channel lifecycle messages.

Select **enveloped messages** when setting up your integrations to receive all the metadata about the message, including the `serial`, `version`, and `extras` (which include the [`headers`](/docs/chat/rooms/messages#structure) of a chat message).

## Decoding and processing messages <a id="decoding-and-processing"/>

Regardless of the delivery mechanism, you will need to decode the received messages into Chat messages. Details of the mapping from Ably Pub/Sub messages to Chat messages are available in the [chat integrations](/docs/chat/integrations) documentation.

After performing the decoding to get your chat `Message` object, you can proceed to process it through your external system.

### Enveloped messages

With enveloping enabled (the default), Ably wraps messages in additional metadata:

```javascript
{
  "source": "channel.message",
  "appId": "your-app-id",
  "channel": "chat:support:room-123",
  "site": "eu-west-1-A",
  "ruleId": "integration-rule-id",
  "messages": [
    {
      "id": "message-id",
      "name": "event-name",
      "connectionId": "connection-id",
      "timestamp": 1234567890,
      "data": {
        "text": "Message content",
        "metadata": {}
      },
      "extras": {
        "headers": {
          "x-integration-trigger": "assistant"
        }
      }
    }
  ]
}
```

### Processing messages with the Ably SDK

The recommended approach is to use the Ably SDK to decode messages, which handles encoding, data types, and converts numeric action values to strings:

```javascript
const Ably = require('ably');

// In your webhook handler or queue consumer
function processIntegrationPayload(envelopeData) {
  // Decode messages using Ably SDK
  const decodedMessages = Ably.Realtime.Message.fromEncodedArray(
    envelopeData.messages
  );

  for (const msg of decodedMessages) {
    // Extract chat message fields
    const text = msg.data?.text;
    const metadata = msg.data?.metadata || {};
    const headers = msg.extras?.headers || {};

    // Check for integration triggers
    if (headers['x-integration-trigger']) {
      const trigger = headers['x-integration-trigger'];
      processMessage(text, trigger, metadata, envelopeData.channel);
    }
  }
}
```

### Message action types

Chat messages have different action types that indicate their lifecycle state:

* `message.create` (numeric: `0`) - A new message
* `message.update` (numeric: `1`) - An edited message
* `message.delete` (numeric: `2`) - A deleted message
* `message.summary` (numeric: `4`) - A message with reaction updates

If you're not using an Ably SDK, you'll need to convert these numeric values to their string representations. See the [Chat integrations documentation](/docs/chat/integrations) for full details on message structure mapping.

## Using a webhook <a id="webhook"/>

Ably can forward messages to your external system via a webhook. This is the simplest to set up and offers the lowest latency. This section covers the simple HTTP endpoint webhook, but the same principles apply to other webhook integrations such as AWS Lambda, Azure Function, Google Cloud Function, and others.

Read the guide on [outbound webhooks](/docs/platform/integrations/webhooks) for more details on how to set up a webhook with Ably for the platform of your choice.

**Benefits:**
* Easiest to set up and understand
* No infrastructure to manage with serverless functions
* Direct HTTP invocation with automatic retries
* Native support for major cloud providers
* Lowest latency option

**You need to consider:**
* **Cold start latency:** Serverless functions may have cold start delays. Consider keeping functions warm for latency-sensitive use cases.
* **Limited retry window:** Ably will retry delivering the message to your webhook, but only for a short period. Monitor the [`[meta]log` channel](/docs/platform/errors#meta) for delivery failures.
* **Scale limits:** Webhook scale depends on your function's concurrency configuration. Ensure your function can handle expected message volumes.
* **[At-least-once delivery](/docs/platform/architecture/idempotency#protocol-support-for-exactly-once-delivery):** You need to handle duplicate messages. Implement idempotency using message IDs.
* **Ordering:** Messages can arrive out-of-order. Use `serial` and `version.serial` properties to order them correctly if needed.

### Example webhook handler

```javascript
const Ably = require('ably');
const crypto = require('crypto');

// Webhook handler (e.g., AWS Lambda, Express.js)
exports.handler = async (event) => {
  // Verify webhook signature for security
  const signature = event.headers['x-ably-signature'];
  if (!verifySignature(event.body, signature)) {
    return { statusCode: 401, body: 'Invalid signature' };
  }

  // Parse the enveloped message
  const envelope = JSON.parse(event.body);
  const channel = envelope.channel;

  // Decode messages using Ably SDK
  const messages = Ably.Realtime.Message.fromEncodedArray(envelope.messages);

  for (const msg of messages) {
    // Check if message should be processed
    const headers = msg.extras?.headers || {};
    if (headers['x-integration-trigger'] === 'assistant') {
      const text = msg.data?.text;
      const response = await processWithExternalSystem(text);
      await sendResponseToChat(channel, response);
    }
  }

  return { statusCode: 200 };
};

function verifySignature(payload, signature) {
  const expectedSignature = crypto
    .createHmac('sha256', process.env.WEBHOOK_SECRET)
    .update(payload)
    .digest('hex');
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}
```

## Using an Ably queue <a id="ably-queue"/>

Ably can forward messages from chat room channels to an [Ably Queue](/docs/platform/integrations/queues), which you can then consume from your own servers to process messages through your external system and respond back to chat. Read the guide on [Ably queues](/docs/platform/integrations/queues) for more details on how to set up the queue integration with Ably.

Ably ensures that each message is delivered to only one consumer even if multiple consumers are connected.

**Benefits:**
* Guaranteed at-least-once delivery with dead letter queue support
* Backpressure management via queue depth monitoring
* No message loss if your consumers temporarily disconnect
* Scale consumers independently by running multiple instances
* Ably manages the queue infrastructure for you

**You need to consider:**
* **Processing latency:** Asynchronous queue processing adds latency compared to webhooks. Consider if your use case can tolerate this delay.
* **Queue limits:** Each message has a time-to-live (TTL) in the queue. The default and maximum is 60 minutes. Monitor queue depth during peak times.
* **Consumer scaling:** During peak times you may need to scale up your consumers to avoid overloading the queue past the maximum queue length allowed.
* **Dead letter queue:** Oldest messages are dropped if the maximum queue length is exceeded. Always consume messages from the [dead letter queue](/docs/platform/integrations/queues#deadletter) to monitor errors.
* **Consumer infrastructure:** You need to manage and maintain your consumer servers or containers that process messages from the queue.

### Example queue consumer

```javascript
const Ably = require('ably');
const amqp = require('amqplib');

async function consumeFromQueue() {
  // Connect to Ably Queue using AMQP
  const url = 'amqps://APPID.KEYID:SECRET@us-east-1-a-queue.ably.io/shared';
  const conn = await amqp.connect(url);
  const channel = await conn.createChannel();

  // Consume messages from the queue
  await channel.consume('your-app-id:chat-integrations', async (item) => {
    try {
      // Parse enveloped message
      const envelope = JSON.parse(item.content.toString());
      const chatChannel = envelope.channel;

      // Decode messages using Ably SDK
      const messages = Ably.Realtime.Message.fromEncodedArray(envelope.messages);

      for (const msg of messages) {
        // Process message with external system
        const text = msg.data?.text;
        const headers = msg.extras?.headers || {};

        if (headers['x-integration-trigger']) {
          const response = await processWithExternalSystem(text);
          await sendResponseToChat(chatChannel, response);
        }
      }

      // ACK message to remove from queue
      channel.ack(item);
    } catch (error) {
      console.error('Processing failed:', error);
      // NACK with requeue=false to send to dead letter queue
      channel.nack(item, false, false);
    }
  });
}
```

## Using outbound streaming <a id="outbound-streaming"/>

Ably can stream messages directly to your own queueing or streaming service: Kafka, Kinesis, AMQP, SQS, Pulsar. Read the guide on [outbound streaming](/docs/platform/integrations/streaming) for more details on how to set up the streaming integration with Ably for the service of your choice.

**Benefits:**
* Massive scale (millions of messages/second)
* Multiple consumers can process the same stream
* Integration with existing data infrastructure
* Message replay capability for reprocessing
* Use your existing queue system to process messages from Ably

**You need to consider:**
* **Infrastructure complexity:** You need to maintain and be responsible for a reliable streaming system. If you don't already have such a system, it increases complexity.
* **Consistency:** If your streaming system is not reachable, messages may be lost. Errors can be seen in the [`[meta]log` channel](/docs/platform/errors#meta).
* **Processing latency:** Similar to queues, streaming adds asynchronous processing latency.
* **Setup complexity:** Most complex integration method to set up and operate.

## Responding back to chat <a id="responding"/>

The critical consideration when responding back to chat is avoiding infinite loops where responses trigger the same integration rule. This section explains strategies to safely publish responses back to the chat room.

### Strategy 1: Use separate response channels

Respond to a different channel pattern that doesn't trigger the integration:

```javascript
const Ably = require('ably');

async function sendResponseToChat(originalChannel, responseText) {
  // Use REST client for efficient one-off publishing
  const ably = new Ably.Rest({ key: process.env.ABLY_API_KEY });

  // Respond to a different channel that doesn't match your integration filter
  // If integration triggers on 'chat:support' or 'chat:group:*',
  // respond to 'responses:support' or 'responses:group:123'
  const responseChannel = originalChannel.replace('chat:', 'responses:');

  await ably.channels.get(responseChannel).publish('assistant-reply', {
    text: responseText,
    metadata: {
      source: 'integration',
      timestamp: Date.now()
    }
  });
}
```

Your client subscribes to both the original chat channel and the response channel:

```javascript
// Subscribe to regular chat messages in the room
room.messages.subscribe((event) => {
  displayMessage(event.message);
});

// Subscribe to integration responses on a separate channel
const realtimeClient = new Ably.Realtime({ key: 'your-token' });
const responseChannel = realtimeClient.channels.get('responses:support');

responseChannel.subscribe('assistant-reply', (message) => {
  displayIntegrationResponse(message.data);
});
```

### Strategy 2: Skip integration rules on response messages

Use Ably's [skip integrations](/docs/platform/integrations/skip-integrations) feature to publish messages that bypass integration rules.

<Aside data-type='important'>
Your API key or token must have the [`privileged-headers`](/docs/auth/capabilities#capability-operations) capability to use this feature.
</Aside>

**Skip all integration rules:**

```javascript
async function sendResponseToChat(channel, responseText) {
  // Requires privileged-headers capability
  const ably = new Ably.Rest({ key: process.env.ABLY_API_KEY });

  await ably.channels.get(channel).publish({
    name: 'assistant-reply',
    data: { text: responseText },
    extras: {
      privileged: {
        skipRule: '*'  // Skip ALL integration rules
      }
    }
  });
}
```

**Skip specific integration rules:**

If you only want to skip specific rules (e.g., the one that triggered your integration), you can provide the rule ID:

```javascript
async function sendResponseToChat(channel, responseText, ruleIdToSkip) {
  const ably = new Ably.Rest({ key: process.env.ABLY_API_KEY });

  await ably.channels.get(channel).publish({
    name: 'assistant-reply',
    data: { text: responseText },
    extras: {
      privileged: {
        skipRule: [ruleIdToSkip]  // Skip only this specific rule
      }
    }
  });
}
```

The rule ID is available in the integration webhook envelope's `ruleId` field, or you can find it in your Ably [dashboard](https://ably.com/dashboard) under Integrations.

## Common integration patterns

The following patterns demonstrate practical integration scenarios. These are generic examples that you can adapt to your specific external services.

### Pattern 1: Command processing

Process commands that trigger server-side logic using metadata/headers:

**User experience:**
1. User types `/weather London` in the chat UI
2. Client app detects the slash command and extracts the action and arguments
3. Message sent with `x-integration-action` header set to 'weather'
4. Integration processes the request
5. Response published back to chat: "Weather in London: 18°C, Partly cloudy"

**Client-side implementation:**

<Code>
```javascript
// Detect slash commands in your UI
function handleMessageInput(inputText, command) {
  // Send message with integration action header
  await room.messages.send({
    text: inputText,
    headers: {
      'x-integration-action': command,  // 'weather', 'help', etc.
    }
  });
}
```
</Code>

**Server-side handler:**

<Code>
```javascript
const Ably = require('ably');

async function handleIntegrationMessage(envelopeData) {
  const messages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of messages) {
    const action = msg.extras?.headers?.['x-integration-action'];
    if (!action) continue;  // Skip messages without integration action

    const text = msg.data?.text || '';
    const channel = envelopeData.channel;

    switch (action) {
      case 'weather':
        const weather = await fetchWeatherData(text);
        await publishResponse(channel, `Weather in ${text}: ${weather}`);
        break;

      case 'help':
        await publishResponse(channel, 'Available commands: /weather, /help');
        break;

      default:
        await publishResponse(channel, `Unknown command: /${action}`);
    }
  }
}

async function fetchWeatherData(location) {
  // Call weather API
  const response = await fetch(`https://api.weather.example.com?q=${location}`);
  const data = await response.json();
  return `${data.temp}°C, ${data.conditions}`;
}
```
</Code>

### Pattern 2: Content enrichment

Automatically enhance messages with metadata using headers:

**User experience:**
1. User shares a URL in chat
2. Client detects the URL and adds enrichment header
3. Integration fetches metadata (title, description, preview image)
4. Enriched message published with preview data

**Client-side implementation:**

<Code>
```javascript
function detectURLs(text) {
  const urlPattern = /(https?:\/\/[^\s]+)/g;
  return text.match(urlPattern) || [];
}

async function sendMessageWithURLDetection(text) {
  const urls = detectURLs(text);

  if (urls.length > 0) {
    // Request URL enrichment via integration
    await room.messages.send({
      text: text,
      headers: {
        'x-integration-action': 'enrich-urls',
        'x-urls': JSON.stringify(urls)
      }
    });
  } else {
    // Regular message
    await room.messages.send({ text: text });
  }
}
```
</Code>

**Server-side handler:**

<Code>
```javascript
const Ably = require('ably');

async function handleURLEnrichment(envelopeData) {
  const messages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of messages) {
    const action = msg.extras?.headers?.['x-integration-action'];
    if (action !== 'enrich-urls') continue;

    const urls = JSON.parse(msg.extras.headers['x-urls'] || '[]');
    const channel = envelopeData.channel;

    for (const url of urls) {
      const metadata = await fetchURLMetadata(url);

      await publishEnrichedContent(channel, {
        type: 'url-preview',
        url: url,
        title: metadata.title,
        description: metadata.description,
        image: metadata.image,
        originalMessageText: msg.data?.text
      });
    }
  }
}

async function fetchURLMetadata(url) {
  // Call metadata extraction service
  const response = await fetch(
    `https://metadata-api.example.com?url=${encodeURIComponent(url)}`
  );
  return response.json();
}
```
</Code>

### Pattern 3: Multi-step workflows

Handle complex processes with status updates using metadata:

**User experience:**
1. User initiates action: `/analyze attachment-id`
2. System responds: "Starting analysis..."
3. Progress updates: "Processing... 50% complete"
4. Final result: "Analysis complete: [results]"

**Client-side implementation:**

<Code>
```javascript
// User initiates analysis command
async function initiateAnalysis(attachmentId) {
  await room.messages.send({
    text: attachmentId,
    headers: {
      'x-integration-action': 'analyze',
      'x-workflow-id': generateWorkflowId()
    }
  });
}
```
</Code>

**Server-side handler:**

<Code>
```javascript
const Ably = require('ably');

async function handleAnalysisWorkflow(envelopeData) {
  const messages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of messages) {
    const action = msg.extras?.headers?.['x-integration-action'];
    if (action !== 'analyze') continue;

    const attachmentId = msg.data?.text;
    const workflowId = msg.extras.headers['x-workflow-id'];
    const channel = envelopeData.channel;

    // Step 1: Acknowledge start
    await publishStatus(channel, workflowId, {
      status: 'started',
      message: 'Starting analysis...'
    });

    try {
      // Step 2: Fetch attachment
      const attachment = await fetchAttachment(attachmentId);
      await publishStatus(channel, workflowId, {
        status: 'progress',
        message: 'Processing...',
        progress: 25
      });

      // Step 3: Analyze
      const results = await performAnalysis(attachment);
      await publishStatus(channel, workflowId, {
        status: 'progress',
        message: 'Finalizing...',
        progress: 75
      });

      // Step 4: Complete
      await publishStatus(channel, workflowId, {
        status: 'complete',
        message: 'Analysis complete',
        results: results
      });

    } catch (error) {
      await publishStatus(channel, workflowId, {
        status: 'failed',
        message: `Analysis failed: ${error.message}`
      });
    }
  }
}
```
</Code>

## Best practices for production

When building production-ready integrations, follow these best practices:

### Error handling and resilience

* **Retry logic:** Implement exponential backoff for failed external API calls to handle transient failures gracefully
* **Circuit breakers:** Prevent cascading failures by temporarily stopping requests to failing external services
* **Timeouts:** Set appropriate timeouts for external API calls to avoid indefinite blocking
* **Graceful degradation:** Design your system to handle external service failures without breaking the entire integration
* See [Ably's architecture documentation](/docs/platform/architecture/fault-tolerance) for resilience patterns

### Idempotency

* **Message deduplication:** Track processed message IDs to safely handle Ably's [at-least-once delivery](/docs/platform/architecture/idempotency#protocol-support-for-exactly-once-delivery)
* **Idempotent operations:** Design your external system operations to be safely retryable
* **Cleanup strategy:** Implement cleanup for tracked message IDs to prevent memory leaks (LRU cache, TTL-based cleanup)

### Rate limiting and caching

* **Cache responses:** Cache frequent external API responses to reduce latency and costs
* **Rate limits:** Respect external service rate limits with throttling and queuing
* **Batching:** Consider batching multiple operations to reduce external API calls
* **CDN integration:** Use CDNs for static content enrichment (images, metadata)

### Security

* **Webhook signatures:** Always validate webhook signatures using Ably's provided signature headers
* **Token authentication:** Use short-lived [JWT tokens](/docs/auth/token#jwt) with minimal capabilities for client connections
* **API key security:** Never embed API keys in client code; use server-side endpoints to generate tokens
* **TLS/HTTPS:** Ensure all connections use TLS encryption
* **Secret management:** Store API keys and secrets in secure management systems (AWS Secrets Manager, Azure Key Vault, etc.)
* See [Ably's authentication documentation](/docs/auth) for security best practices

### Monitoring and observability

* **[Meta channel](/docs/metadata-stats/metadata/subscribe) monitoring:** Subscribe to `[meta]log:integration` to track integration errors
* **Dead letter queues:** Monitor [dead letter queues](/docs/platform/integrations/queues#deadletter) if using Ably Queues
* **Metrics tracking:** Monitor error rates, latency, throughput, and external service response times
* **Alerting:** Set up alerts for integration failures, queue depth issues, and performance degradation
* **Logging:** Implement structured logging with correlation IDs for debugging

## Testing your integration

Validate your integration before deploying to production:

### Local testing

Use webhook testing tools to develop locally:

* **[ngrok](https://ngrok.com/):** Create a secure tunnel to your local development server
* **[webhook.site](https://webhook.site/):** Inspect webhook payloads without writing code

```bash
# Example: Expose local server with ngrok
ngrok http 3000

# Use the generated URL in your Ably integration rule
# Example: https://abc123.ngrok.io/webhook
```

### Load testing

Simulate production message volumes to verify scale:

```javascript
async function loadTest(roomName, messageCount) {
  const room = await chatClient.rooms.get(roomName);

  console.log(`Sending ${messageCount} messages...`);

  for (let i = 0; i < messageCount; i++) {
    await room.messages.send({
      text: `Load test message ${i}`,
      headers: { 'x-load-test': 'true' }
    });

    // Add delay to simulate realistic traffic
    if (i % 100 === 0) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  console.log('Load test complete');
}
```

## Production checklist

Before deploying your integration to production, verify:

- [ ] Integration rule filters correctly match target channels
- [ ] External system authenticated and authorized properly
- [ ] Response messages configured to avoid infinite loops (separate channels or privileged skipRule)
- [ ] API key has `privileged-headers` capability if using skipRule feature
- [ ] Error handling and logging implemented
- [ ] Retry logic and exponential backoff in place
- [ ] Monitoring and alerting configured
  - [ ] Subscribe to `[meta]log` channel
  - [ ] Track error rates and latency
  - [ ] Monitor queue depths (if using queues)
  - [ ] Alert on dead letter queue messages
- [ ] Load tested at expected scale (+ 50% buffer)
- [ ] Cost estimation validated based on message volume
- [ ] Security review completed
  - [ ] No API keys embedded in client code
  - [ ] TLS/HTTPS enabled for all connections
  - [ ] Webhook signatures validated
  - [ ] Secrets stored in secure management system
- [ ] Idempotency handling implemented
- [ ] Documentation for your team on how integration works
- [ ] Rollback plan prepared in case of issues
- [ ] Test in staging environment before production

## Next steps

Explore related documentation to deepen your integration knowledge:

* [Chat SDK documentation](/docs/chat) - Comprehensive guide to Ably Chat features
* [Platform Integrations](/docs/platform/integrations) - Detailed setup for webhooks, queues, and streaming
* [Chat Integrations](/docs/chat/integrations) - Technical reference for Chat message structure
* [Export Chat Data](/docs/guides/chat/export-chat) - Guide for storing all chat messages long-term
* [Architecture Overview](/docs/platform/architecture) - Learn how Ably achieves scale and reliability
* [Authentication](/docs/auth) - Security best practices for production apps
* [Chat Moderation](/docs/chat/moderation) - Filter and moderate chat content

For custom integration requirements or questions, [contact Ably support](https://ably.com/support).
