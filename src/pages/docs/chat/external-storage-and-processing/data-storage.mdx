---
title: "Data storage"
meta_description: "Store chat messages from Ably Chat in your own data storage for long-term retention, compliance, and analytics."
meta_keywords: "chat storage, data storage, data retention, compliance, analytics, message history, chat export"
---

Store chat messages from Ably Chat in your own data storage for long-term retention, compliance, analytics, or to maintain your data storage as the canonical source of truth.

While Ably Chat provides flexible data retention for messages (30 days by default, up to a year on request), this page discusses options for longer-term storage and additional control over your chat data.

## What Ably Chat history gives you <a id="history-endpoint"/>

You can fetch the message history of a chat room using the [Chat History endpoint](/docs/api/chat-rest#tag/rooms/paths/~1chat~1%7Bversion%7D~1rooms~1%7BroomName%7D~1messages/get) or the [Chat SDK](/docs/chat/rooms/history). The chat room history endpoint is a paginated HTTP endpoint that allows you to retrieve messages from a chat room. The Chat SDK provides a convenient way to fetch the history of a chat room.

The intended use of the chat history endpoint is to retrieve messages for pre-filling a chat window, not for continuous ingestion into other systems. As a result, there are some important things to consider:
- The history endpoint is not a changelog, it is a snapshot of the messages in the room at the time the request is made. It returns only the latest version of each message.
- The history API returns messages in their canonical global order (sorted by `serial`).
- During some offline period, to capture all updates and deletes that may have occurred, you will need to re-fetch all messages each time, which can be impractical for long-running chats with large message histories.
- The maximum retention period for chat messages is 365 days (on request). Messages older than this will not be available via the history endpoint.

## Why store chat data externally? <a id="why"/>

Ably Chat history is designed for pre-filling chat windows and retrieving recent messages. If your requirements go beyond this, storing chat data in your own data storage gives you full control over retention, querying, and how that data is used.

Common reasons to use external storage include:

- Meeting compliance and legal requirements such as data retention policies and audit trails
- Building analytics, dashboards, or training ML models from chat data
- Implementing features like full-text search that need flexible access to message history
- Retaining data beyond Ably Chat's maximum retention period of 365 days

Maintaining your own data storage also allows you to treat it as the canonical source of truth, giving you the ability to query, transform, and serve chat data in whatever way your application needs.

## Key considerations <a id="key-considerations"/>

Consider the following when storing chat data:

### Data storage schema design <a id="schema-design"/>

Design your schema to support the features you need while keeping scale and reliability in mind. An early decision is whether you need to store all versions of messages or just the latest version (see [Decision 1](#decision-1) below), and whether to store full message objects or normalized relational data.

New messages, updates, and deletes will arrive concurrently, so your data storage must handle this. Consider:

- Reducing roundtrips and managing locks to handle race conditions
- Planning indexes for efficient queries on room name, timestamp, serial, and version serial

### Scale and reliability <a id="scale-reliability"/>

Consider how many messages per second your data storage needs to handle and how you will scale up consumers during peak times. Ensure your data storage can handle the write volume, for example by using write-optimized databases or batch writes. Also plan for query performance, particularly how you will efficiently retrieve messages for chat windows or search results.

### Data latency and consistency <a id="latency-consistency"/>

When using integrations, there will be a small delay between a message being published and it arriving in your data storage. This delay is typically milliseconds to seconds depending on the integration method, with additional time for the write to your data storage. Accept that your data storage will be eventually consistent with Ably Chat.

If you need your data storage to be immediately consistent, consider [publishing via your own servers](#publish-via-own).

### Messages beyond retention period <a id="retention-period"/>

Consider how to retrieve and display messages older than Ably Chat's retention period. You may need to fetch recent messages from both your data storage and Ably Chat history, so think about how you will merge messages from these two sources and whether you need to indicate to users which messages came from long-term storage.

## Implementation approaches <a id="implementation-approaches"/>

Choose the approach that fits your requirements:

### 1. Using integrations (recommended) <a id="using-integrations"/>

Extract messages via [webhooks, queues, or streaming](/docs/chat/external-storage-and-processing/data-extraction) and save them to your data storage. This is the recommended approach for most use cases.

This approach provides a proven, scalable solution that leverages Ably's infrastructure with multiple integration methods to choose from and built-in monitoring and error handling.

Use this approach when you want reliable, continuous ingestion, you're comfortable with eventual consistency (milliseconds to seconds delay), and you need to store messages from ongoing or long-running chats.

See the [data extraction guide](/docs/chat/external-storage-and-processing/data-extraction) for complete setup details.

### 2. Publishing via your own servers <a id="publish-via-own"/>

Proxy message publishing through your own servers to save messages as they're produced.

This approach provides full control over the publishing flow with immediate consistency (no integration delay), the opportunity to add validation or business logic before publishing, and the ability to use the Chat REST API or SDK to publish.

**Considerations:**
- You must handle updates and deletes yourself, including all consistency issues
- Message reactions require using integrations (you won't have access to reaction summaries otherwise)
- Your servers become part of the critical publish path (availability and latency impact)
- Must handle the scale of realtime publishes
- Keeping both systems in sync is complex - need mitigation strategies for all failure scenarios

Use this approach when your data storage must be immediately consistent, you need to validate or transform messages before publishing, or you already proxy messages through your servers for other reasons.

### 3. Using the Chat History endpoint <a id="history-endpoint"/>

Fetch completed chat histories using the [Chat History endpoint](/docs/api/chat-rest#tag/rooms/paths/~1chat~1%7Bversion%7D~1rooms~1%7BroomName%7D~1messages/get) or [Chat SDK](/docs/chat/rooms/history).

This approach provides a simple, reliable solution for archival with no integration setup required, and is perfect for chats with clear start and end times.

**Considerations:**
- Intended for pre-filling chat windows, not continuous ingestion
- Returns only the latest version of each message (not a full changelog)
- Returns messages sorted by `serial` (canonical global order)
- Must decide when to trigger export (closed ticket, ended session, etc.)
- Impractical for long-running chats if you need all updates/deletes (must fetch from start each time)
- You will need to decide when and which rooms to import messages from. The metachannel [`[meta]channel.lifecycle`](/docs/metadata-stats/metadata/subscribe#channel-lifecycle) provides events when channels are opened and closed, but your business logic might provide a better solution. For example, import when a support ticket is closed or game session ends.
- You can import the same room multiple times (deduplicate by `serial` and `version.serial`). However, to capture all updates and deletes, you will need to fetch from the first message each time, which can be impractical for long-running chats with large message histories.

Use this approach when archiving completed chats (closed support tickets, ended game sessions), there are clear start and end boundaries for chats, and you don't need continuous ingestion or full version history.

Use the [`[meta]channel.lifecycle`](/docs/metadata-stats/metadata/subscribe#channel-lifecycle) metachannel to detect when channels close, or use your business logic (ticket closed, session ended) to trigger exports.

## Storing messages <a id="storing-messages"/>

After [extracting messages via integrations](/docs/chat/external-storage-and-processing/data-extraction), you need to make decisions about how to store them in your data storage.

### Decision 1: Full version history or just the latest version? <a id="decision-1"/>

Do you need all versions of a message or just the latest version?
  - Messages are uniquely identified by their `serial`. Message versions are identified by the message's `version.serial` property.
  - Lexicographically higher `version.serial` means a newer version.
  - If you need to store all versions of a message, uniquely index by `roomName`, `serial` and `version.serial`.
  - If you only need the latest version of a message, uniquely index by `roomName` and `serial`, and only update if the received `version.serial` is greater than what you have stored. This handles out-of-order delivery.
  - When performing a message search or lookup, do you want to return only the latest version of each message, even if you store the full version history?
  - If you are looking to hydrate chat windows from your own data storage, think of how to efficiently retrieve the latest version of each message for a time window. For example, this can be implemented via a separate table or by iterating through all versions and filtering old versions out.

<Code>
  ```javascript
  const saveMessageVersion = (roomName, message) => {
  if (message.action === 'message.summary') {
  // summary events are not part of the message version history, so discard
  return;
}

  // Pseudo-code: only insert if you don't already have this message version
  // Implementation depends on your database's upsert/conflict handling capabilities
  await insertIfNotExists(roomName, message.serial, message.version.serial, message);
};
  ```
</Code>

Read more about [message versioning and sorting](/docs/chat/rooms/messages#ordering-update-delete) in the messages documentation.

### Decision 2: How to store message reactions? <a id="decision-2"/>

If you need to store message reactions you need to consider the following:

1. Do you need to store only the current state of the reactions, historic snapshots of the current state, or the full history of all individual reactions?
 - If you only need the current state (latest summary), simply save the values provided in the latest message with action `message.summary`. Uniquely index by `roomName` and `serial`.
 - If you need to store historic snapshots, store all `message.summary` events for every message. Note that when a message receives many reactions in a short amount of time, summaries can be rolled up for cost and bandwidth optimisation, so not every reaction gets a summary event published.
2. Do you have a requirement to store the list of clientIds who reacted to a message, or just the totals?
 - If you only need the totals, simply use the values provided in each message with action `message.summary`.
 - If you need the list of clientIds who reacted, use the values from reaction summaries.

If you do not need to store message reactions, you can simply discard them. Never store the `reactions` (or `annotations`) field and ignore messages with action `message.summary`.

## Publishing via your own servers <a id="publish-via-own"/>

Change the publish path: instead of publishing Chat messages, updates, and deletes to Ably directly, proxy them through your own server. This gives you the opportunity to also save the messages as they are produced, and also apply different validation schemes if needed.

This approach provides full control over publishing with the opportunity to add extra validation or processing and business logic before publishing to Ably. You can publish messages directly via the Chat REST API and avoid having to encode/decode Chat Messages to and from Ably Pub/Sub messages, and if you are using a supported language, you have the option to publish via the Chat SDK.

You need to consider:
- You need to handle updates and deletes on your own, including all consistency issues that arise from this.
- Storing message reactions will require using one of the other methods presented in this guide, otherwise you will not have access to the aggregates (summaries) that Ably provides.
- Your own servers are in the middle of the message publish path, so they can become a bottleneck in availability and will add latency in the publish path.
- Your own servers will need to handle the scale you operate at for realtime publishes.
- Keeping both systems in sync can be a difficult problem to solve in all edge cases. Inconsistencies can happen if either publishing to Ably or saving to your own data storage fails. You will need mitigation strategies to handle all failure scenarios to ensure eventual consistency.
