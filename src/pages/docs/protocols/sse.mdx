---
title: SSE
meta_description: "Ably provides support for Server-Sent Events (SSE). This is useful for where browser clients support SSE, and the use case does not require or support the resources used by an Ably SDK."
languages:
  - javascript
redirect_from:
  - /docs/sse
  - /docs/sse/versions/v1.1
---

The Ably SSE (Server-Sent Events) API provides realtime event streams without needing a full SDK or an [MQTT](/docs/protocols/mqtt) library. [SSE](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) is a lightweight streaming layer over HTTP, primarily accessed through the [EventSource API](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) in modern web browsers â€” the preferred method to harness SSE.

With HTTP streaming, servers can maintain client requests and transmit data without repetitive requests, offering efficiency akin to WebSockets.

SSE allows subscribe-only functionality. This means you can't:

* Publish
* Enter presence
* Query the existing presence set
* Attach and detach from channels without restarting the stream.

Ably advise SSE for simplified, subscribe-only streams on platforms. Its status as an open standard eliminates the need for client-side SDKs. However, the [Ably SDK](/docs/sdks) is recommended overall for its [expanded features and superior reliability](/docs/basics).

## When to use the SSE adapter <a id="when-to-use"/>

SSE is an excellent alternative to Ably SDK in memory-limited environments.

### Applicability of SSE <a id="Applicability-of-SSE"/>

* When operating under severe memory constraints
* Where no Ably native library is available for your desired platform
* When Ably provides only a REST SDK for your designated platform, but a realtime client interface is requisite
* Where the sole operation is the subscription to channel events

### Advantages of Ably SDKs and Realtime Protocol <a id="Advantages-of-Ably-SDKs-and-Realtime-Protocol"/>

* Assured high service quality and resilience, particularly in DNS (Domain Name System) disruptions or network partitioning scenarios.
* Access to a comprehensive range of features including, but not limited to, [publishing](/docs/push/publish), [presence](/docs/presence-occupancy/presence), [history](/docs/storage-history/history), [push notifications](/docs/push), [automatic payload encoding](/docs/channels/options/encryption), and [symmetric encryption](/docs/channels/options/encryption).
* Optimal compatibility with browsers via the WebSocket protocol.

## Configuration <a id="config"/>

The following code sample provides an example of how to use SSE with Ably:

<Aside data-type='important'>
The examples use [basic authentication](/docs/platform/auth/basic) to demonstrate features for convenience. In your own applications, basic authentication should never be used on the client-side as it exposes your Ably API key. Instead use [token authentication](#auth).
</Aside>

<Code>
```javascript
var apiKey ='{{API_KEY}}';
var url ='https://main.realtime.ably.net/event-stream?channels=your-channel&v=1.2&key=' + apiKey;
var eventSource = new EventSource(url);

eventSource.onmessage = function(event) {
  var message = JSON.parse(event.data);
  console.log('Message: ' + message.name + ' - ' + message.data);
};
```
</Code>

## Authentication <a id="auth"/>

SSE supports [basic authentication](/docs/platform/auth/basic) with an API key, or [token authentication](/docs/platform/auth/token) with tokens from your server. **For client-side applications, [JWT token authentication](/docs/platform/auth/token#choosing-jwt) is recommended.**

- **Basic auth**: Use the `key` querystring parameter or `Authorization: Basic <base64-encoded key>` header
- **Token auth**: Use the `accessToken` querystring parameter or `Authorization: Bearer <token>` header

Note that [connection state](/docs/connect) is only retained for two minutes.

### JWT Authentication (recommended) <a id="jwt-auth"/>

<Aside data-type='note'>
For SSE clients, JWT authentication is recommended because JWTs can be created with any JWT library (no Ably SDK required on your server) and provide features like channel-scoped claims.
</Aside>

Your server creates JWTs for clients to use with the `accessToken` parameter:

**Server-side JWT creation:**

<Code>
```javascript
import jwt from 'jsonwebtoken';

const [keyName, keySecret] = process.env.ABLY_API_KEY.split(':');

function createAblyJwt(clientId) {
  return jwt.sign(
    {
      'x-ably-capability': JSON.stringify({ '*': ['subscribe'] }),
      'x-ably-clientId': clientId,
    },
    keySecret,
    {
      algorithm: 'HS256',
      keyid: keyName,
      expiresIn: '1h',
    }
  );
}
```

```python
import jwt
import os
import json
import time

def create_ably_jwt(client_id: str) -> str:
    api_key = os.environ['ABLY_API_KEY']
    key_name, key_secret = api_key.split(':')

    now = int(time.time())

    return jwt.encode(
        {
            'iat': now,
            'exp': now + 3600,
            'x-ably-capability': json.dumps({'*': ['subscribe']}),
            'x-ably-clientId': client_id,
        },
        key_secret,
        algorithm='HS256',
        headers={'kid': key_name}
    )
```
</Code>

**Client-side SSE connection with JWT:**

<Code>
```javascript
// Fetch JWT from your auth server
const response = await fetch('/api/ably-token');
const jwt = await response.text();

// Connect to SSE with the JWT
const url = `https://main.realtime.ably.net/event-stream?channels=your-channel&v=1.2&accessToken=${jwt}`;
const eventSource = new EventSource(url);

eventSource.onmessage = function(event) {
  const message = JSON.parse(event.data);
  console.log('Message:', message.name, '-', message.data);
};
```
</Code>

### Token expiration and message continuity <a id="token-continuity"/>

The SSE protocol and EventSource API seamlessly resume dropped connections. The client reconnects, supplying a `lastEventId` parameter, ensuring no event is missed from the previous connection's endpoint.

At the point of token expiration, the connection terminates. The default EventSource reconnection won't function due to the expired credentials embedded in the connection URL. The solution is initiating a new connection with an updated token, ensuring continuity by providing the right `lastEventId`.

To enable transparent connection resumption when tokens must be renewed:

1. Detect token expiration (error codes `40140` to `40149`)
2. Fetch a new JWT from your auth server
3. Resume the connection with the `lastEventId` from the previous connection

The following example shows message continuity with JWT authentication:

<Code>
```javascript
let lastEvent;
let eventSource;
const channel = 'your-channel';

async function connectToAbly() {
  // Fetch JWT from your auth server
  const response = await fetch('/api/ably-token');
  const jwt = await response.text();

  // Establish connection with JWT, resuming from lastEvent if available
  const lastEventParam = lastEvent ? ('&lastEvent=' + lastEvent) : '';
  eventSource = new EventSource(
    `https://main.realtime.ably.net/sse?v=1.2&accessToken=${jwt}&channels=${channel}${lastEventParam}`
  );

  // Track lastEventId for message continuity
  eventSource.onmessage = msg => {
    lastEvent = msg.lastEventId;
    // ... process message
  };

  // Handle token expiry
  eventSource.onerror = msg => {
    const err = JSON.parse(msg.data);
    const isTokenErr = err.code >= 40140 && err.code < 40150;
    if (isTokenErr) {
      eventSource.close();
      connectToAbly(); // Reconnect with fresh JWT
    }
  };
}

connectToAbly();
```
</Code>

The EventSource API will automatically attempt to reconnect and re-subscribe to the SSE endpoint in case of errors, even if the token has expired.

Manually re-subscribing to the SSE endpoint with a fresh token inadvertently creates two active subscriptions:
1. The expired token _that will consistently error out_
2. The new token

To avoid this, close the previous `EventSource` subscription with `eventSource.close()` before starting a new one, as shown in the code snippet.

## Channel options <a id="channel-options"/>

In an SSE connection you can specify [channel options](/docs/channels/options) in two different ways:

1. With a query string in the channel name qualifier
2. As a query string in the connection URL

By including options in the connection URL, they will apply to all attached channels. However, if you use a channel name qualifier, you can apply options to individual channels. This is useful if you need to override the options set in the connection URL for specific channels.

When creating a channel, you can use a qualifier in the form of square brackets at the beginning of the channel name. For example, to indicate the channel option with the name `foo` with value `bar` on a channel named `baz` the qualified channel name would be `[?foo=bar]baz`. If the channel name already has a qualifier, like `[meta]log`, you can add a query string after the existing qualifier, such as `[meta?foo=bar]log`.

The [rewind](/docs/channels/options/rewind) and [delta](/docs/channels/options/deltas) channel options are supported with SSE.

### Delta with SSE <a id="delta-sse"/>

If you subscribe to a channel in delta mode using SSE, you must decode any delta messages you receive.

Certain transports may only provide the content of the `data` attribute of a `message`, without any accompanying metadata. This means that the receiver of the message may not have access to the `extras` or `encoding` attributes typically used to decode message updates.

To help applications utilizing these transports, `vcdiff` decoder libraries can examine the message payload's start for the vcdiff header. This is an approximate method for determining whether the message is a standard message or a delta. It's important to understand that, to depend on this check, you must ensure that the header is not present in any valid (uncompressed) message in your application. JSON messages, for instance, do not match the vcdiff header check, making it secure to conduct this sniffing on JSON message payloads.

For more information, see [Deltas](/docs/channels/options/deltas).

### Delta example with SSE <a id="delta-example"/>

You can subscribe to messages in delta mode, using the SSE transport, as follows.

<Aside data-type='important'>
The examples use [basic authentication](/docs/platform/auth/basic) to demonstrate features for convenience. In your own applications, basic authentication should never be used on the client-side as it exposes your Ably API key. Instead use [token authentication](#auth).
</Aside>

<Code>
```javascript
  /* Make sure to include <script src="https://cdn.ably.com/lib/delta-codec.min-1.js"></script> in your head */
  var key = '{{API_KEY}}';
  var channel = 'your-channel';
  var baseUrl = 'https://main.realtime.ably.net/event-stream';
  var urlParams = `?channels=${channel}&v=1.1&key=${key}&delta=vcdiff`;
  var url = baseUrl + urlParams;
  var eventSource = new EventSource(url);
  var channelDecoder = new DeltaCodec.CheckedVcdiffDecoder();

  eventSource.onmessage = function(event) {
    /* event.data is JSON-encoded Ably Message
       (see https://ably.com/docs/docs/realtime/types#message) */
    var message = JSON.parse(event.data);
    var { id, extras } = message;
    var { data } = message;

    try {
      if (extras && extras.delta) {
        data = channelDecoder.applyBase64Delta(data, id, extras.delta.from).asUtf8String();
      } else {
        channelDecoder.setBase(data, id);
      }
    } catch(e) {
      /* Delta decoder error */
      console.log(e);
    }

    /* Process decoded data */
    console.log(data);
  };
```
</Code>

### Delta example with unenveloped SSE <a id="delta-example-unenv"/>

For more information on enveloped and unenveloped SSE, please see the [SSE API](/docs/api/sse#sse)

<Aside data-type='important'>
The examples use [basic authentication](/docs/platform/auth/basic) to demonstrate features for convenience. In your own applications, basic authentication should never be used on the client-side as it exposes your Ably API key. Instead use [token authentication](#auth).
</Aside>

<Code>
```javascript
  /* Make sure to include <script src="https://cdn.ably.com/lib/delta-codec.min-1.js"></script> in your head */
  var DeltaCodec = require('@ably/delta-codec');

  var key = '{{API_KEY}}';
  var channel = 'your-channel';
  var baseUrl = 'https://main.realtime.ably.net/event-stream';
  var urlParams = `?channels=${channel}&v=1.1&key=${key}&delta=vcdiff&enveloped=false`;
  var url = baseUrl + urlParams;
  var eventSource = new EventSource(url);
  var channelDecoder = new DeltaCodec.VcdiffDecoder();

  eventSource.onmessage = function(event) {
      var data = event.data;

      try {
          if (DeltaCodec.VcdiffDecoder.isBase64Delta(data)) {
              data = channelDecoder.applyBase64Delta(data).asUtf8String();
          } else {
              channelDecoder.setBase(data);
          }
      } catch(e) {
          /* Delta decoder error */
          console.log(e);
      }

      /* Process decoded data */
      console.log(data);
  };
```
</Code>

### Rewind with SSE <a id="rewind-sse"/>

You can use the [`rewind`](/docs/channels/options/rewind) channel option to choose the starting point of an attachment, either by specifying a specific moment in the past or a certain number of messages. For example, apply the `rewind` channel option with a value of `1` to all channels using a querystring parameter.

<Aside data-type='important'>
The examples use [basic authentication](/docs/platform/auth/basic) to demonstrate features for convenience. In your own applications, basic authentication should never be used on the client-side as it exposes your Ably API key. Instead use [token authentication](#auth).
</Aside>

<Code>
```javascript
  var querystring = 'v=1.2&channels=your-channel&rewind=1&key={{API_KEY}}';
  var eventSource = new EventSource('https://main.realtime.ably.net/event-stream?' + querystring);
```
</Code>

Or to specify the same parameter but only applying to one channel of two, using a qualified channel name:

<Code>
```javascript
  var channelOne = encodeURIComponent('[?rewind=1]channel-one');
  var channelTwo = 'channel-two';
  var channels = channelOne + ',' + channelTwo;
  var querystring = 'v=1.2&key={{API_KEY}}&channels=' + channels';
  var eventSource = new EventSource('https://main.realtime.ably.net/event-stream?' + querystring);
```
</Code>

## Statistics <a id="stats"/>

You can stream app [statistics](/docs/metadata-stats/stats) directly to the console using SSE by connecting and subscribing to the metachannel [`[meta]stats:minute`](/docs/metadata-stats/metadata/subscribe#stats).

The following is an example of subscribing to `[meta]stats:minute`:

<Code>
```shell
curl -s -u "{{API_KEY}}" "https://main.realtime.ably.net/sse?channel=[meta]stats:minute&v=1.2"
```
</Code>

The following is an example statistics event returned to the console from `[meta]stats:minute`:

<Code>
```json
{
  "id": "1083hjuJAB3NbG@1633679346115-0",
  "event": "message",
  "data": {
    "id": "MVphZHA7l9:0:0",
    "timestamp": 1633679346026,
    "encoding": "json",
    "channel": "[meta]stats:minute",
    "data": {
      "intervalId": "2021-10-08:07:48",
      "unit": "minute",
      "schema": "https://schemas.ably.com/json/app-stats-0.0.1.json",
      "entries": {
        "messages.all.all.count": 1,
        "messages.all.messages.count": 1,
        "messages.outbound.realtime.all.count": 1,
        "messages.outbound.realtime.messages.count": 1,
        "messages.outbound.all.all.count": 1,
        "messages.outbound.all.messages.count": 1,
        "connections.all.peak": 2,
        "connections.all.min": 1,
        "connections.all.mean": 1,
        "connections.all.opened": 1
      }
    },
    "name": "update"
  }
}
```
</Code>

There may be a delay of up to one minute before receiving the initial statistics event. Use the [rewind channel option](#rewind-sse) to retrieve the most recent event and subscribe to subsequent events.

The following is an example curl command subscribing to `[meta]stats:minute` with a rewind value of 1:

<Code>
```shell
curl -s -u "{{API_KEY}}" "https://main.realtime.ably.net/sse?channel=[meta]stats:minute&v=1.2&rewind=1"
```
</Code>
