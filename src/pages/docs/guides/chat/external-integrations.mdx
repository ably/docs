---
title: "Guide: Integrate external systems with Ably Chat"
meta_description: "Extend Ably Chat with external integrations: process messages with AI, webhooks, and custom logic at scale."
meta_keywords: "chat integrations, external systems, webhooks, AI chat, message processing, chat automation, integration rules, message routing"
---

Ably Chat is designed for extensibility. Whether you need to process messages with AI, translate content in real-time, trigger business workflows, or enrich messages with external data, Ably's integration capabilities enable you to extend your chat application without compromising on scale, reliability, or performance.

This guide explains how to architect integrations that process chat messages through external systems and respond back to the chat in real-time. Before diving into the technical implementation, it's important to understand your architectural goals and the role your external system will play.

## Why integrate external systems?

Integrating external systems with Ably Chat enables you to extend your chat application beyond simple message delivery. Common integration use cases include:

* **AI-powered assistants:** Process commands or questions through language models and respond with helpful information.
* **Real-time translation:** Automatically translate messages for multilingual chat rooms.
* **Content enrichment:** Expand URLs into rich previews, detect and process mentions, or add contextual information.
* **Analytics and monitoring:** Analyze sentiment, track engagement metrics, or identify trending topics.
* **Workflow automation:** Trigger external business processes based on chat activity.
* **Command processing:** Handle slash commands that invoke server-side logic.

Unlike [chat moderation](/docs/chat/moderation), which filters or blocks content before or after publication, integrations focus on processing messages and responding with new content or triggering external actions. Also unlike [exporting chat data](/docs/guides/chat/export-chat), which stores all messages for long-term retention, integrations process specific messages matched by integration rules.

## Why Ably for external integrations?

Ably Chat integrations are built on Ably's proven platform architecture, designed to handle integration workloads at any scale:

* **Reliable message delivery:** Every integration benefits from Ably's [four pillars of dependability](/docs/platform/architecture): Performance, Integrity, Reliability, and Availability.
* **Flexible routing:** Use channel filters, message headers, and metadata to selectively route only the messages that need processing.
* **Multiple integration methods:** Choose webhooks, queues, or streaming based on your architecture and scale requirements.
* **Proven at scale:** Ably processes over 500 million messages per day for customers, with [serverless scalability](/docs/platform/architecture/platform-scalability) that eliminates infrastructure management.
* **No vendor lock-in:** Integrate with any external service, using any language or platform that can handle HTTP requests or consume from queues.

Because Ably Chat rooms use Pub/Sub channels as their underlying transport, you can leverage all of Ably's [platform integrations](/docs/platform/integrations) to extend your chat application.

## Key considerations <a id="key-considerations"/>

Consider the following when integrating external systems with Ably Chat:

* **Processing latency:** Integration adds latency to the message flow. Webhooks offer the lowest latency, while queues add asynchronous processing time. Design your system to handle the expected processing time.
* **Avoiding infinite loops:** When your integration responds back to chat, ensure responses don't trigger the same integration rule. Use separate channels, skip integration flags, or message headers to break potential loops.
* **Scale and reliability:** Different integration methods offer different reliability guarantees. Webhooks have limited retry windows, while queues provide guaranteed delivery with dead letter queues.
* **External system limitations:** Your external service may have rate limits, processing constraints, or availability issues. Implement retry logic, circuit breakers, and caching to handle these limitations gracefully.
* **Cost optimization:** Only process messages that require processing. Use channel filters and message headers to minimize unnecessary integration executions.
* **Security:** Validate webhook signatures, use token authentication with limited capabilities, and never embed API keys in client code.

## Implementation options <a id="implementation-options"/>

With your strategy in mind, choose the technical approach that fits your needs:

1. Using [outbound webhooks](#webhook). [HTTP endpoint](/docs/platform/integrations/webhooks/generic), [AWS Lambda](/docs/platform/integrations/webhooks/lambda), and others.
2. Using [Ably queues](#ably-queue).
3. Using [outbound streaming](#outbound-streaming). Stream to your own [Kafka](/docs/platform/integrations/streaming/kafka), [Kinesis](/docs/platform/integrations/streaming/kinesis), and others.

## Understanding the integration pattern

Ably Chat integrations follow a message-driven architecture that enables bidirectional communication between your chat application and external systems.

### Core concepts

* **Chat rooms use Pub/Sub channels:** Each chat room is built on an Ably channel, enabling the full range of Ably's integration capabilities.
* **Message structure:** Chat messages are encoded as Pub/Sub messages with a specific structure. See the [Chat integrations documentation](/docs/chat/integrations) for details on the mapping.
* **Integration rules:** Configure rules that filter which messages trigger integrations based on channel patterns, event types, or other criteria.
* **Bidirectional flow:** Integrations can both receive messages from chat and publish responses back to the chat room.

### Integration flow

The typical integration flow works as follows:

1. A user sends a message to a chat room, optionally including headers, metadata, or trigger patterns.
2. The message is published to the Ably Chat channel.
3. An integration rule evaluates the message based on channel name, message headers, or other criteria.
4. If the rule matches, Ably forwards the message to your external system via the configured integration method.
5. Your external system processes the message (AI inference, translation, business logic, etc.).
6. The external system publishes a response back to an Ably Chat channel.
7. All subscribed clients receive the response in real-time.

**Diagram:** *Integration flow showing: Client → Ably Chat → Integration Rule → External System → Response → Ably Chat → Clients*

### Triggering integrations

You have several options for controlling which messages trigger integrations:

**Channel naming patterns:**
Use consistent channel naming conventions to route messages selectively. For example, use `chat:support:*` for support channels or `chat:commands:*` for command processing.

**Message headers:**
Add custom headers to messages that should trigger integration processing:

```javascript
await room.messages.send({
  text: '/ask What are your business hours?',
  headers: {
    'x-integration-trigger': 'assistant',
    'x-priority': 'high'
  }
});
```

**Message metadata:**
Use structured metadata for more complex trigger logic:

```javascript
await room.messages.send({
  text: 'Please translate this message',
  metadata: {
    action: 'translate',
    targetLanguage: 'es',
    sourceLanguage: 'en'
  }
});
```

**Content patterns:**
Your integration can detect patterns in the message text itself, such as slash commands (`/weather London`) or specific keywords.

## Filtering rooms and event types <a id="filtering"/>

Integrations allow you to filter which Ably channels are forwarded to your external system using a regular expression on the channel name. This is a simple way to reduce the volume of messages you need to process by only receiving messages from the chat rooms you are interested in. Use a common prefix in the name of chat rooms that you want to trigger an integration for, and use the prefix as the filter.

Use `channel.message` as the event type for all integration types. This will forward all messages published to the relevant channels and exclude presence messages and channel lifecycle messages.

Select **enveloped messages** when setting up your integrations to receive all the metadata about the message, including the `serial`, `version`, and `extras` (which include the [`headers`](/docs/chat/rooms/messages#structure) of a chat message).

## Decoding and processing messages <a id="decoding-and-processing"/>

Regardless of the delivery mechanism, you will need to decode the received messages into Chat messages. Details of the mapping from Ably Pub/Sub messages to Chat messages are available in the [chat integrations](/docs/chat/integrations) documentation.

After performing the decoding to get your chat `Message` object, you can proceed to process it through your external system.

### Enveloped messages

With enveloping enabled (the default), Ably wraps messages in additional metadata:

```javascript
{
  "source": "channel.message",
  "appId": "your-app-id",
  "channel": "chat:support:room-123",
  "site": "eu-west-1-A",
  "ruleId": "integration-rule-id",
  "messages": [
    {
      "id": "message-id",
      "name": "event-name",
      "connectionId": "connection-id",
      "timestamp": 1234567890,
      "data": {
        "text": "Message content",
        "metadata": {}
      },
      "extras": {
        "headers": {
          "x-integration-trigger": "assistant"
        }
      }
    }
  ]
}
```

### Processing messages with the Ably SDK

The recommended approach is to use the Ably SDK to decode messages, which handles encoding, data types, and converts numeric action values to strings:

```javascript
const Ably = require('ably');

// In your webhook handler or queue consumer
function processIntegrationPayload(envelopeData) {
  // Decode messages using Ably SDK
  const decodedMessages = Ably.Realtime.Message.fromEncodedArray(
    envelopeData.messages
  );
  
  for (const msg of decodedMessages) {
    // Extract chat message fields
    const text = msg.data?.text;
    const metadata = msg.data?.metadata || {};
    const headers = msg.extras?.headers || {};
    
    // Check for integration triggers
    if (headers['x-integration-trigger']) {
      const trigger = headers['x-integration-trigger'];
      processMessage(text, trigger, metadata, envelopeData.channel);
    }
  }
}
```

### Message action types

Chat messages have different action types that indicate their lifecycle state:

* `message.create` (numeric: `0`) - A new message
* `message.update` (numeric: `1`) - An edited message
* `message.delete` (numeric: `2`) - A deleted message
* `message.summary` (numeric: `4`) - A message with reaction updates

If you're not using an Ably SDK, you'll need to convert these numeric values to their string representations. See the [Chat integrations documentation](/docs/chat/integrations) for full details on message structure mapping.

## Using a webhook <a id="webhook"/>

Ably can forward messages to your external system via a webhook. This is the simplest to set up and offers the lowest latency. This section covers the simple HTTP endpoint webhook, but the same principles apply to other webhook integrations such as AWS Lambda, Azure Function, Google Cloud Function, and others.

Read the guide on [outbound webhooks](/docs/platform/integrations/webhooks) for more details on how to set up a webhook with Ably for the platform of your choice.

**Benefits:**
* Easiest to set up and understand
* No infrastructure to manage with serverless functions
* Direct HTTP invocation with automatic retries
* Native support for major cloud providers
* Lowest latency option

**You need to consider:**
* **Cold start latency:** Serverless functions may have cold start delays. Consider keeping functions warm for latency-sensitive use cases.
* **Limited retry window:** Ably will retry delivering the message to your webhook, but only for a short period. Monitor the [`[meta]log` channel](/docs/platform/errors#meta) for delivery failures.
* **Scale limits:** Webhook scale depends on your function's concurrency configuration. Ensure your function can handle expected message volumes.
* **[At-least-once delivery](/docs/platform/architecture/idempotency#protocol-support-for-exactly-once-delivery):** You need to handle duplicate messages. Implement idempotency using message IDs.
* **Ordering:** Messages can arrive out-of-order. Use `serial` and `version.serial` properties to order them correctly if needed.

### Example webhook handler

```javascript
const Ably = require('ably');
const crypto = require('crypto');

// Webhook handler (e.g., AWS Lambda, Express.js)
exports.handler = async (event) => {
  // Verify webhook signature for security
  const signature = event.headers['x-ably-signature'];
  if (!verifySignature(event.body, signature)) {
    return { statusCode: 401, body: 'Invalid signature' };
  }
  
  // Parse the enveloped message
  const envelope = JSON.parse(event.body);
  const channel = envelope.channel;
  
  // Decode messages using Ably SDK
  const messages = Ably.Realtime.Message.fromEncodedArray(envelope.messages);
  
  for (const msg of messages) {
    // Check if message should be processed
    const headers = msg.extras?.headers || {};
    if (headers['x-integration-trigger'] === 'assistant') {
      const text = msg.data?.text;
      const response = await processWithExternalSystem(text);
      await sendResponseToChat(channel, response);
    }
  }
  
  return { statusCode: 200 };
};

function verifySignature(payload, signature) {
  const expectedSignature = crypto
    .createHmac('sha256', process.env.WEBHOOK_SECRET)
    .update(payload)
    .digest('hex');
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}
```

## Using an Ably queue <a id="ably-queue"/>

Ably can forward messages from chat room channels to an [Ably Queue](/docs/platform/integrations/queues), which you can then consume from your own servers to process messages through your external system and respond back to chat. Read the guide on [Ably queues](/docs/platform/integrations/queues) for more details on how to set up the queue integration with Ably.

Ably ensures that each message is delivered to only one consumer even if multiple consumers are connected.

**Benefits:**
* Guaranteed at-least-once delivery with dead letter queue support
* Backpressure management via queue depth monitoring
* No message loss if your consumers temporarily disconnect
* Scale consumers independently by running multiple instances
* Ably manages the queue infrastructure for you

**You need to consider:**
* **Processing latency:** Asynchronous queue processing adds latency compared to webhooks. Consider if your use case can tolerate this delay.
* **Queue limits:** Each message has a time-to-live (TTL) in the queue. The default and maximum is 60 minutes. Monitor queue depth during peak times.
* **Consumer scaling:** During peak times you may need to scale up your consumers to avoid overloading the queue past the maximum queue length allowed.
* **Dead letter queue:** Oldest messages are dropped if the maximum queue length is exceeded. Always consume messages from the [dead letter queue](/docs/platform/integrations/queues#deadletter) to monitor errors.
* **Consumer infrastructure:** You need to manage and maintain your consumer servers or containers that process messages from the queue.

### Example queue consumer

```javascript
const Ably = require('ably');
const amqp = require('amqplib');

async function consumeFromQueue() {
  // Connect to Ably Queue using AMQP
  const url = 'amqps://APPID.KEYID:SECRET@us-east-1-a-queue.ably.io/shared';
  const conn = await amqp.connect(url);
  const channel = await conn.createChannel();
  
  // Consume messages from the queue
  await channel.consume('your-app-id:chat-integrations', async (item) => {
    try {
      // Parse enveloped message
      const envelope = JSON.parse(item.content.toString());
      const chatChannel = envelope.channel;
      
      // Decode messages using Ably SDK
      const messages = Ably.Realtime.Message.fromEncodedArray(envelope.messages);
      
      for (const msg of messages) {
        // Process message with external system
        const text = msg.data?.text;
        const headers = msg.extras?.headers || {};
        
        if (headers['x-integration-trigger']) {
          const response = await processWithExternalSystem(text);
          await sendResponseToChat(chatChannel, response);
        }
      }
      
      // ACK message to remove from queue
      channel.ack(item);
    } catch (error) {
      console.error('Processing failed:', error);
      // NACK with requeue=false to send to dead letter queue
      channel.nack(item, false, false);
    }
  });
}
```

## Using outbound streaming <a id="outbound-streaming"/>

Ably can stream messages directly to your own queueing or streaming service: Kafka, Kinesis, AMQP, SQS, Pulsar. Read the guide on [outbound streaming](/docs/platform/integrations/streaming) for more details on how to set up the streaming integration with Ably for the service of your choice.

**Benefits:**
* Massive scale (millions of messages/second)
* Multiple consumers can process the same stream
* Integration with existing data infrastructure
* Message replay capability for reprocessing
* Use your existing queue system to process messages from Ably

**You need to consider:**
* **Infrastructure complexity:** You need to maintain and be responsible for a reliable streaming system. If you don't already have such a system, it increases complexity.
* **Consistency:** If your streaming system is not reachable, messages may be lost. Errors can be seen in the [`[meta]log` channel](/docs/platform/errors#meta).
* **Processing latency:** Similar to queues, streaming adds asynchronous processing latency.
* **Setup complexity:** Most complex integration method to set up and operate.

## Responding back to chat <a id="responding"/>

The critical consideration when responding back to chat is avoiding infinite loops where responses trigger the same integration rule. This section explains strategies to safely publish responses back to the chat room.

### Strategy 1: Use separate channels

Respond to a different channel pattern that doesn't trigger the integration:

```javascript
const Ably = require('ably');

async function sendResponseToChat(originalChannel, responseText) {
  // Use REST client for efficient one-off publishing
  const ably = new Ably.Rest({ key: process.env.ABLY_API_KEY });
  
  // Respond to a different channel pattern
  // Integration triggers on 'chat:*', respond to 'chat-responses:*'
  const responseChannel = originalChannel.replace('chat:', 'chat-responses:');
  
  await ably.channels.get(responseChannel).publish('assistant-reply', {
    text: responseText,
    metadata: {
      source: 'integration',
      timestamp: Date.now()
    }
  });
}
```

Your client subscribes to both the original chat channel and the response channel:

```javascript
// Subscribe to regular chat messages
room.messages.subscribe((event) => {
  displayMessage(event.message);
});

// Subscribe to integration responses on a separate channel
const realtimeClient = new Ably.Realtime({ key: 'your-token' });
const responseChannel = realtimeClient.channels.get('chat-responses:room-123');

responseChannel.subscribe('assistant-reply', (message) => {
  displayIntegrationResponse(message.data);
});
```

### Strategy 2: Skip integrations on response messages

Use Ably's [skip integrations](/docs/platform/integrations/skip-integrations) feature to publish messages that bypass integration rules:

```javascript
async function sendResponseToChat(channel, responseText) {
  const ably = new Ably.Rest({ key: process.env.ABLY_API_KEY });
  
  await ably.channels.get(channel).publish({
    name: 'assistant-reply',
    data: { text: responseText },
    extras: {
      push: { 
        skipIntegrations: true 
      }
    }
  });
}
```

### Strategy 3: Use message headers to filter

Configure your integration rule to exclude messages with specific headers:

```javascript
// Send response with a header that your integration rule filters out
await ably.channels.get(channel).publish({
  name: 'assistant-reply',
  data: { text: responseText },
  extras: {
    headers: {
      'x-skip-integration': 'true'
    }
  }
});
```

Then configure your integration rule's channel filter to exclude these messages based on the header presence.

## Common integration patterns

The following patterns demonstrate practical integration scenarios. These are generic examples that you can adapt to your specific external services.

### Pattern 1: Command processing

Process slash commands that trigger server-side logic:

**User experience:**
1. User types `/weather London` in chat
2. Integration detects the command pattern
3. External service fetches weather data
4. Response published back to chat: "Weather in London: 18°C, Partly cloudy"

**Implementation:**

```javascript
function detectCommand(text) {
  const commandPattern = /^\/(\w+)\s*(.*)$/;
  const match = text.match(commandPattern);
  
  if (match) {
    return {
      command: match[1],
      args: match[2]
    };
  }
  return null;
}

async function handleCommand(text, channel) {
  const cmd = detectCommand(text);
  if (!cmd) return;
  
  switch (cmd.command) {
    case 'weather':
      const weather = await fetchWeatherData(cmd.args);
      await publishResponse(channel, `Weather in ${cmd.args}: ${weather}`);
      break;
      
    case 'help':
      await publishResponse(channel, 'Available commands: /weather, /help');
      break;
      
    default:
      await publishResponse(channel, `Unknown command: /${cmd.command}`);
  }
}
```

### Pattern 2: Content enrichment

Automatically enhance messages with metadata:

**User experience:**
1. User shares a URL in chat
2. Integration detects the URL
3. Metadata fetched (title, description, preview image)
4. Enriched message published with preview data

**Implementation:**

```javascript
async function enrichMessageWithURLs(text, channel) {
  const urlPattern = /(https?:\/\/[^\s]+)/g;
  const urls = text.match(urlPattern);
  
  if (!urls) return;
  
  for (const url of urls) {
    const metadata = await fetchURLMetadata(url);
    
    await publishEnrichedContent(channel, {
      type: 'url-preview',
      url: url,
      title: metadata.title,
      description: metadata.description,
      image: metadata.image,
      originalMessageText: text
    });
  }
}

async function fetchURLMetadata(url) {
  // Call metadata extraction service
  const response = await fetch(
    `https://metadata-api.example.com?url=${encodeURIComponent(url)}`
  );
  return response.json();
}
```

### Pattern 3: Multi-step workflows

Handle complex processes with status updates:

**User experience:**
1. User initiates action: `/analyze attachment-id`
2. System responds: "Starting analysis..."
3. Progress updates: "Processing... 50% complete"
4. Final result: "Analysis complete: [results]"

**Implementation:**

```javascript
async function handleAnalysisWorkflow(attachmentId, channel) {
  const workflowId = generateWorkflowId();
  
  // Step 1: Acknowledge start
  await publishStatus(channel, workflowId, {
    status: 'started',
    message: 'Starting analysis...'
  });
  
  try {
    // Step 2: Fetch attachment
    const attachment = await fetchAttachment(attachmentId);
    await publishStatus(channel, workflowId, {
      status: 'progress',
      message: 'Processing...',
      progress: 25
    });
    
    // Step 3: Analyze
    const results = await performAnalysis(attachment);
    await publishStatus(channel, workflowId, {
      status: 'progress',
      message: 'Finalizing...',
      progress: 75
    });
    
    // Step 4: Complete
    await publishStatus(channel, workflowId, {
      status: 'complete',
      message: 'Analysis complete',
      results: results
    });
    
  } catch (error) {
    await publishStatus(channel, workflowId, {
      status: 'failed',
      message: `Analysis failed: ${error.message}`
    });
  }
}
```

## Best practices for production

When building production-ready integrations, follow these best practices:

### Error handling and retry logic

Implement exponential backoff for failed external API calls:

```javascript
async function retryWithBackoff(fn, maxRetries = 3) {
  let delay = 1000; // Start with 1 second
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      await new Promise(resolve => setTimeout(resolve, delay));
      delay *= 2; // Exponential backoff
    }
  }
}
```

### Idempotency

Design your handlers to safely process duplicate messages:

```javascript
const processedMessages = new Set();

function isProcessed(messageId) {
  return processedMessages.has(messageId);
}

function markProcessed(messageId) {
  processedMessages.add(messageId);
  // Implement cleanup to prevent memory leaks
  // e.g., use LRU cache or periodic cleanup
}

async function processMessage(message) {
  if (isProcessed(message.id)) {
    console.log('Message already processed, skipping');
    return;
  }
  
  // Process the message
  await handleMessage(message);
  
  // Mark as processed
  markProcessed(message.id);
}
```

### Rate limiting and caching

Cache frequent requests to reduce latency and cost:

```javascript
const cache = new Map();

async function getCachedTranslation(text, targetLang) {
  const cacheKey = `${targetLang}:${text}`;
  
  if (cache.has(cacheKey)) {
    return cache.get(cacheKey);
  }
  
  const translation = await translateText(text, targetLang);
  cache.set(cacheKey, translation);
  
  return translation;
}
```

### Security

Secure your webhook endpoints and validate signatures:

```javascript
const crypto = require('crypto');

function verifyWebhookSignature(payload, signature, secret) {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}
```

### Monitoring

Monitor integration health using the `[meta]log` channel:

```javascript
const metaChannel = ably.channels.get('[meta]log:integration');

metaChannel.subscribe((message) => {
  if (message.data.level === 'error') {
    console.error('Integration error:', message.data);
    // Send alert to your monitoring system
    sendAlert('Integration error detected', message.data);
  }
});
```

## Testing your integration

Validate your integration before deploying to production:

### Local testing

Use webhook testing tools to develop locally:

* **[ngrok](https://ngrok.com/):** Create a secure tunnel to your local development server
* **[webhook.site](https://webhook.site/):** Inspect webhook payloads without writing code

```bash
# Example: Expose local server with ngrok
ngrok http 3000

# Use the generated URL in your Ably integration rule
# Example: https://abc123.ngrok.io/webhook
```

### Load testing

Simulate production message volumes to verify scale:

```javascript
async function loadTest(roomName, messageCount) {
  const room = await chatClient.rooms.get(roomName);
  
  console.log(`Sending ${messageCount} messages...`);
  
  for (let i = 0; i < messageCount; i++) {
    await room.messages.send({
      text: `Load test message ${i}`,
      headers: { 'x-load-test': 'true' }
    });
    
    // Add delay to simulate realistic traffic
    if (i % 100 === 0) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  
  console.log('Load test complete');
}
```

## Production checklist

Before deploying your integration to production, verify:

- [ ] Integration rule filters correctly match target channels
- [ ] External system authenticated and authorized properly
- [ ] Response messages configured to avoid infinite loops (separate channels or skip flag)
- [ ] Error handling and logging implemented
- [ ] Retry logic and exponential backoff in place
- [ ] Monitoring and alerting configured
  - [ ] Subscribe to `[meta]log` channel
  - [ ] Track error rates and latency
  - [ ] Monitor queue depths (if using queues)
  - [ ] Alert on dead letter queue messages
- [ ] Load tested at expected scale (+ 50% buffer)
- [ ] Cost estimation validated based on message volume
- [ ] Security review completed
  - [ ] No API keys embedded in client code
  - [ ] TLS/HTTPS enabled for all connections
  - [ ] Webhook signatures validated
  - [ ] Secrets stored in secure management system
- [ ] Idempotency handling implemented
- [ ] Documentation for your team on how integration works
- [ ] Rollback plan prepared in case of issues
- [ ] Test in staging environment before production

## Next steps

Explore related documentation to deepen your integration knowledge:

* [Chat SDK documentation](/docs/chat) - Comprehensive guide to Ably Chat features
* [Platform Integrations](/docs/platform/integrations) - Detailed setup for webhooks, queues, and streaming
* [Chat Integrations](/docs/chat/integrations) - Technical reference for Chat message structure
* [Export Chat Data](/docs/guides/chat/export-chat) - Guide for storing all chat messages long-term
* [Architecture Overview](/docs/platform/architecture) - Learn how Ably achieves scale and reliability
* [Authentication](/docs/auth) - Security best practices for production apps
* [Chat Moderation](/docs/chat/moderation) - Filter and moderate chat content

For custom integration requirements or questions, [contact Ably support](https://ably.com/support).