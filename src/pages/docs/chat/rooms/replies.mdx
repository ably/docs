---
title: "Message replies"
meta_description: "Add reply functionality to messages in a chat room."
meta_keywords: "ably chat, message replies, chat replies, javascript chat replies, typescript chat replies, chat metadata"
---

Reply to messages that have been previously sent in the chat room.

Message replies are implemented using the `metadata` field when you [send a message](/docs/chat/rooms/messages#send).

## Send a reply <a id="send-reply"/>

Use the [`metadata`](/docs/chat/rooms/messages#structure) field of a message to store the reply when you [send a message](/docs/chat/rooms/messages#send).

You need to at least include the `serial` of the parent message that you're replying to. Other information can be included such as a preview of the text:

<Code>
```javascript
async function sendReply(replyToMessage, replyText) {
  const metadata = {
    reply: {
      serial: replyToMessage.serial,
      timestamp: replyToMessage.createdAt.getTime(),
      clientId: replyToMessage.clientId,
      previewText: replyToMessage.text.substring(0, 140)
    }
  };

  await room.messages.send({
    text: replyText,
    metadata: metadata
  });
}
```

```react
import { useMessages } from '@ably/chat/react';

const ReplyComponent = ({ messageToReplyTo }) => {
  const { sendMessage } = useMessages();

  const sendReply = async (replyText) => {
    const metadata = {
      reply: {
        serial: messageToReplyTo.serial,
        createdAt: messageToReplyTo.createdAt.getTime(),
        clientId: messageToReplyTo.clientId,
        previewText: messageToReplyTo.text.substring(0, 140)
      }
    };

    await sendMessage({
      text: replyText,
      metadata: metadata
    });
  };

  return (
    <div>
      <button onClick={() => sendReply("My reply")}>Send Reply</button>
    </div>
  );
};
```

```swift
func sendReply(replyToMessage: Message, replyText: String) async throws {
    let metadata: MessageMetadata = [
        "reply": .object([
            "serial": .string(replyToMessage.serial),
            "timestamp": .number(Double(replyToMessage.timestamp.timeIntervalSince1970 * 1000)),
            "clientId": .string(replyToMessage.clientID),
            "previewText": .string(String(replyToMessage.text.prefix(140)))
        ])
    ]

    try await room.messages.send(withParams: .init(
        text: replyText,
        metadata: metadata
    ))
}
```

```kotlin
suspend fun sendReply(replyToMessage: Message, replyText: String) {
    val metadata = buildJsonObject {
        put("reply", buildJsonObject {
            put("serial", replyToMessage.serial)
            put("timestamp", replyToMessage.timestamp)
            put("clientId", replyToMessage.clientId)
            put("previewText", replyToMessage.text.take(140))
        })
    }

    room.messages.send(
        text = replyText,
        metadata = metadata
    )
}
```

```jetpack
import androidx.compose.material.*
import androidx.compose.runtime.*
import com.ably.chat.Message
import com.ably.chat.Room
import kotlinx.coroutines.launch
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.put

@Composable
fun SendReplyComponent(room: Room, messageToReplyTo: Message) {
    val coroutineScope = rememberCoroutineScope()

    Button(onClick = {
        coroutineScope.launch {
            val metadata = buildJsonObject {
                put("reply", buildJsonObject {
                    put("serial", messageToReplyTo.serial)
                    put("timestamp", messageToReplyTo.timestamp)
                    put("clientId", messageToReplyTo.clientId)
                    put("previewText", messageToReplyTo.text.take(140))
                })
            }

            room.messages.send(
                text = "My reply",
                metadata = metadata
            )
        }
    }) {
        Text("Send Reply")
    }
}
```
</Code>

## Subscribe to message replies <a id="subscribe"/>

Message replies will be received as normal messages in the room using the [`subscribe()`](/docs/chat/rooms/messages#subscribe) method.

You just need to handle storing and displaying the reply:

### Store reply information <a id="store"/>

When a user replies to a message, extract and store the parent message details:

<Code>
```javascript
function prepareReply(parentMessage) {
  return {
    serial: parentMessage.serial,
    createdAt: parentMessage.createdAt.getTime(),
    clientId: parentMessage.clientId,
    previewText: parentMessage.text.substring(0, 140)
  };
}
```

```react
const prepareReply = (parentMessage) => {
  return {
    serial: parentMessage.serial,
    createdAt: parentMessage.createdAt.getTime(),
    clientId: parentMessage.clientId,
    previewText: parentMessage.text.substring(0, 140)
  };
};
```

```swift
func prepareReply(parentMessage: Message) -> JSONObject {
    return [
        "serial": .string(parentMessage.serial),
        "timestamp": .number(Double(parentMessage.timestamp.timeIntervalSince1970 * 1000)),
        "clientId": .string(parentMessage.clientID),
        "previewText": .string(String(parentMessage.text.prefix(140)))
    ]
}
```

```kotlin
fun prepareReply(parentMessage: Message) = buildJsonObject {
    put("serial", parentMessage.serial)
    put("timestamp", parentMessage.timestamp)
    put("clientId", parentMessage.clientId)
    put("previewText", parentMessage.text.take(140))
}
```

```jetpack
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.put
import com.ably.chat.Message

fun prepareReply(parentMessage: Message) = buildJsonObject {
    put("serial", parentMessage.serial)
    put("timestamp", parentMessage.timestamp)
    put("clientId", parentMessage.clientId)
    put("previewText", parentMessage.text.take(140))
}
```
</Code>

If a parent message isn't in local state, fetch it directly using its `serial`:

<Code>
```javascript
async function fetchParentMessage(replyData) {
  const message = await room.messages.get(replyData.serial);
  return message;
}
```

```react
const FetchParentMessage = ({ replyData }) => {
  const [parentMessage, setParentMessage] = useState();

  useEffect(() => {
    const fetchMessage = async () => {
      const message = await room.messages.get(replyData.serial);
      setParentMessage(message);
    };

    fetchMessage();
  }, [replyData]);

  return parentMessage ? (
    <div>{parentMessage.text}</div>
  ) : null;
};
```

```swift
func fetchParentMessage(replyData: JSONObject) async throws -> Message {
    guard case let .string(serial) = replyData["serial"] else {
        throw NSError(domain: "ReplyError", code: 1, userInfo: [NSLocalizedDescriptionKey: "Invalid serial"])
    }
    let message = try await room.messages.get(withSerial: serial)
    return message
}
```

```kotlin
suspend fun fetchParentMessage(replyData: JsonObject): Message {
    val serial = replyData["serial"]?.jsonPrimitive?.content
        ?: throw IllegalArgumentException("Invalid serial")
    return room.messages.get(serial)
}
```

```jetpack
import androidx.compose.material.*
import androidx.compose.runtime.*
import com.ably.chat.Message
import com.ably.chat.Room
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.jsonPrimitive

@Composable
fun FetchParentMessageComponent(room: Room, replyData: JsonObject) {
    var parentMessage by remember { mutableStateOf<Message?>(null) }

    LaunchedEffect(replyData) {
        val serial = replyData["serial"]?.jsonPrimitive?.content
        if (serial != null) {
            parentMessage = room.messages.get(serial)
        }
    }

    parentMessage?.let { message ->
        Text(text = message.text)
    }
}
```
</Code>

### Display replies <a id="display"/>

Check incoming messages for reply `metadata` and display accordingly:

<Code>
```javascript
room.messages.subscribe((messageEvent) => {
  const message = messageEvent.message;

  if (message.metadata?.reply) {
    const replyData = message.metadata.reply;
    const parentMessage = localMessages.find(msg => msg.serial === replyData.serial);

    if (parentMessage) {
      console.log(`Reply to ${parentMessage.clientId}: ${parentMessage.text}`);
    } else {
      console.log(`Reply to ${replyData.clientId}: ${replyData.previewText}`);
    }
  }

  console.log(`Message: ${message.text}`);
});
```

```react
import { useMessages } from '@ably/chat/react';
import { ChatMessageEventType } from '@ably/chat';

const MessageList = () => {
  const [messages, setMessages] = useState([]);

  useMessages({
    listener: (event) => {
      if (event.type === ChatMessageEventType.Created) {
        setMessages(prev => [...prev, event.message]);
      }
    }
  });

  const findParentMessage = (replyData) => {
    return messages.find(msg => msg.serial === replyData.serial);
  };

  return (
    <div>
      {messages.map(message => (
        <div key={message.serial}>
          {message.metadata?.reply && (
            <div>
              Replying to: {message.metadata.reply.previewText}
            </div>
          )}
          <div>{message.text}</div>
        </div>
      ))}
    </div>
  );
};
```

```swift
// Subscribe to messages and handle replies
var localMessages: [Message] = []

room.messages.subscribe { event in
    let message = event.message

    if let replyMetadata = message.metadata["reply"],
       case let .object(replyData) = replyMetadata {
        if case let .string(replySerial) = replyData["serial"] {
            if let parentMessage = localMessages.first(where: { $0.serial == replySerial }) {
                print("Reply to \(parentMessage.clientID): \(parentMessage.text)")
            } else if case let .string(replyClientId) = replyData["clientId"],
                      case let .string(previewText) = replyData["previewText"] {
                print("Reply to \(replyClientId): \(previewText)")
            }
        }
    }

    print("Message: \(message.text)")
    localMessages.append(message)
}
```

```kotlin
// Subscribe to messages and handle replies
val localMessages = mutableListOf<Message>()

room.messages.subscribe { event ->
    val message = event.message

    val replyData = message.metadata["reply"]?.jsonObject
    if (replyData != null) {
        val replySerial = replyData["serial"]?.jsonPrimitive?.content
        val parentMessage = localMessages.find { it.serial == replySerial }

        if (parentMessage != null) {
            println("Reply to ${parentMessage.clientId}: ${parentMessage.text}")
        } else {
            val replyClientId = replyData["clientId"]?.jsonPrimitive?.content
            val previewText = replyData["previewText"]?.jsonPrimitive?.content
            println("Reply to $replyClientId: $previewText")
        }
    }

    println("Message: ${message.text}")
    localMessages.add(message)
}
```

```jetpack
import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import com.ably.chat.Message
import com.ably.chat.Room
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive

@Composable
fun MessageListComponent(room: Room) {
    var messages by remember { mutableStateOf<List<Message>>(emptyList()) }

    DisposableEffect(room) {
        val (unsubscribe) = room.messages.subscribe { event ->
            messages = messages + event.message
        }

        onDispose {
            unsubscribe()
        }
    }

    Column {
        messages.forEach { message ->
            Column {
                // Display reply information if present
                val replyData = message.metadata["reply"]?.jsonObject
                if (replyData != null) {
                    val previewText = replyData["previewText"]?.jsonPrimitive?.content
                    Text(text = "Replying to: $previewText")
                }

                // Display the message text
                Text(text = message.text)
            }
        }
    }
}
```
</Code>

## Considerations

Consider the following when implementing message replies:

- Older messages may not be available depending on message persistence settings.
- Messages can be [updated](/docs/chat/rooms/messages#update), potentially removing references to replies.
- The `metadata` field is not server-validated.
- Nested replies can be complex and expensive to implement, so consider limiting reply depth.
