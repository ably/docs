---
title: "Store messages in your database"
meta_description: "Store chat messages from Ably Chat in your own database for long-term retention, compliance, and analytics."
meta_keywords: "chat storage, database, data retention, compliance, analytics, message history, chat export"
---

Store chat messages from Ably Chat in your own database for long-term retention, compliance, analytics, or to maintain your database as the canonical source of truth.

While Ably Chat provides flexible data retention for messages (30 days by default, up to a year on request), this page discusses options for longer-term storage and additional control over your chat data.

## Why store chat data? <a id="why"/>

Storing chat data in your own database enables many use cases:

- **Compliance and legal requirements**: Meet data retention policies, maintain audit trails for support conversations, or fulfill regulatory requirements
- **Analytics and business intelligence**: Build dashboards, train ML models, analyze customer sentiment, or track support quality metrics
- **Enhanced functionality**: Implement features that need chat history, such as full-text search across all messages
- **Single source of truth**: Maintain your database as the canonical source of data
- **Long-term storage**: Store chat data for longer than Ably Chat's retention period

## Key considerations <a id="key-considerations"/>

Consider the following when storing chat data:

### Database schema design <a id="schema-design"/>

Design your schema to support the features you need while considering scale and reliability:
- **Database schema**: Design your schema to allow you to easily build the features you need, keeping in mind scale and reliability.
- **Version history requirements**: Decide whether you need to store all versions of messages or just the latest version (see [Decision 1](#decision-1) below)
- **Concurrent writes**: New messages, updates, and deletes will arrive concurrently, so your database must handle this. Consider reducing roundtrips, managing locks, and handling race conditions
- **Indexing strategy**: Plan indexes for efficient queries on room name, timestamp, serial, and version serial
- **Storage optimization**: Consider whether to store full message objects or normalized relational data

### Scale and reliability <a id="scale-reliability"/>

Depending on your application's scale, consider:

- **Message ingestion throughput**: How many messages per second will your database need to handle?
- **Consumer scaling**: How will you scale up consumers during peak times?
- **Database performance**: Will your database handle the write volume? Consider write-optimized databases or batch writes
- **Query performance**: How will you efficiently retrieve messages for chat windows or search results?

### Data latency and consistency <a id="latency-consistency"/>

When using integrations, there will be a small delay between a message being published and it arriving in your database:

- **Integration delay**: Typically milliseconds to seconds depending on the integration method
- **Database write time**: Additional time to write to your database
- **Eventual consistency**: Accept that your database will be eventually consistent with Ably Chat

If you need your database to be immediately consistent, consider [publishing via your own servers](#publish-via-own).

### Messages beyond retention period <a id="retention-period"/>

Consider how to retrieve and display messages older than Ably Chat's retention period:

- **Hydrating chat windows**: Can you efficiently fetch recent messages from both your database and Ably Chat history?
- **Mixed sources**: How will you merge messages from your database with messages from Ably Chat history?
- **UI consistency**: How will you indicate to users which messages came from long-term storage?

## Implementation approaches <a id="implementation-approaches"/>

Choose the approach that fits your requirements:

### 1. Using integrations (recommended) <a id="using-integrations"/>

Extract messages via [webhooks, queues, or streaming](/docs/chat/external-storage-and-processing/data-extraction) and save them to your database. This is the recommended approach for most use cases.

**Benefits:**
- Proven, scalable solution
- Leverage Ably's infrastructure
- Multiple integration methods to choose from
- Monitoring and error handling built-in

**When to use:**
- You want reliable, continuous ingestion
- You're comfortable with eventual consistency (milliseconds to seconds delay)
- You need to store messages from ongoing or long-running chats

See the [data extraction guide](/docs/chat/external-storage-and-processing/data-extraction) for complete setup details.

### 2. Publishing via your own servers <a id="publish-via-own"/>

Proxy message publishing through your own servers to save messages as they're produced.

**Benefits:**
- Full control over publishing flow
- Immediate consistency (no integration delay)
- Opportunity to add validation or business logic before publishing
- Can use Chat REST API or SDK to publish

**Considerations:**
- You must handle updates and deletes yourself, including all consistency issues
- Message reactions require using integrations (you won't have access to reaction summaries otherwise)
- Your servers become part of the critical publish path (availability and latency impact)
- Must handle the scale of realtime publishes
- Keeping both systems in sync is complex - need mitigation strategies for all failure scenarios

**When to use:**
- Your database must be immediately consistent
- You need to validate or transform messages before publishing
- You already proxy messages through your servers for other reasons

### 3. Using the Chat History endpoint <a id="history-endpoint"/>

Fetch completed chat histories using the [Chat History endpoint](/docs/api/chat-rest#tag/rooms/paths/~1chat~1%7Bversion%7D~1rooms~1%7BroomName%7D~1messages/get) or [Chat SDK](/docs/chat/rooms/history).

**Benefits:**
- Simple, reliable solution for archival
- No integration setup required
- Perfect for chats with clear start and end times

**Considerations:**
- Intended for pre-filling chat windows, not continuous ingestion
- Returns only the latest version of each message (not a full changelog)
- Returns messages sorted by `serial` (canonical global order)
- Must decide when to trigger export (closed ticket, ended session, etc.)
- Impractical for long-running chats if you need all updates/deletes (must fetch from start each time)

**When to use:**
- Archiving completed chats (closed support tickets, ended game sessions)
- Clear start and end boundaries for chats
- Don't need continuous ingestion or full version history

Use the [`[meta]channel.lifecycle`](/docs/metadata-stats/metadata/subscribe#channel-lifecycle) metachannel to detect when channels close, or use your business logic (ticket closed, session ended) to trigger exports.

## Storing messages <a id="storing-messages"/>

After [extracting messages via integrations](/docs/chat/external-storage-and-processing/data-extraction), you need to make decisions about how to store them in your database.

### Decision 1: Full version history or just the latest version? <a id="decision-1"/>

Do you need all versions of a message or just the latest version?
  - Messages are uniquely identified by their `serial`. Message versions are identified by the message's `version.serial` property.
  - Lexicographically higher `version.serial` means a newer version.
  - If you need to store all versions of a message, uniquely index by `roomName`, `serial` and `version.serial`.
  - If you only need the latest version of a message, uniquely index by `roomName` and `serial`, and only update if the received `version.serial` is greater than what you have stored. This handles out-of-order delivery.
  - When performing a message search or lookup, do you want to return only the latest version of each message, even if you store the full version history?
  - If you are looking to hydrate chat windows from your own database, think of how to efficiently retrieve the latest version of each message for a time window. For example, this can be implemented via a separate table or by iterating through all versions and filtering old versions out.

<Code>
  ```javascript
  const saveMessageVersion = (roomName, message) => {
  if (message.action === 'message.summary') {
  // summary events are not part of the message version history, so discard
  return;
}

  // Pseudo-code: only insert if you don't already have this message version
  // Implementation depends on your database's upsert/conflict handling capabilities
  await insertIfNotExists(roomName, message.serial, message.version.serial, message);
};
  ```
</Code>

Read more about [message versioning and sorting](/docs/chat/rooms/messages#ordering-update-delete) in the messages documentation.

### Decision 2: How to store message reactions? <a id="decision-2"/>

If you need to store message reactions you need to consider the following:

1. Do you need to store only the current state of the reactions, historic snapshots of the current state, or the full history of all individual reactions?
 - If you only need the current state (latest summary), simply save the values provided in the latest message with action `message.summary`. Uniquely index by `roomName` and `serial`.
 - If you need to store historic snapshots, store all `message.summary` events for every message. Note that when a message receives many reactions in a short amount of time, summaries can be rolled up for cost and bandwidth optimisation, so not every reaction gets a summary event published.
2. Do you have a requirement to store the list of clientIds who reacted to a message, or just the totals?
 - If you only need the totals, simply use the values provided in each message with action `message.summary`.
 - If you need the list of clientIds who reacted, use the values from reaction summaries.

If you do not need to store message reactions, you can simply discard them. Never store the `reactions` (or `annotations`) field and ignore messages with action `message.summary`.

## Using a webhook <a id="webhook"/>

Ably can forward messages to your own system via a webhook. This is the simplest to set up if you don't already have other systems in place for message ingestion. This section covers the simple HTTP endpoint webhook, but the same principles apply to other webhook integrations such as AWS Lambda, Azure Function, Google Function, and others.

Read the guide on [outbound webhooks](/docs/platform/integrations/webhooks) for more details on how to set up a webhook with Ably for the platform of your choice.

You need to consider:
- **Redundancy**: In case of failure, Ably will retry delivering the message to your webhook, but only for a short period. You can see errors in the [`[meta]log` channel](/docs/platform/errors#meta).
- **Ordering**: Messages can arrive out-of-order. You can sort them using their `serial` and `version.serial` properties.
- **Consistency**: Webhook calls that fail will lead to inconsistencies between your database and Ably, which can be difficult to resolve. Detect if this happens using the `[meta]log` channel and use the [history endpoint](#history-endpoint) to backfill missing data.
- **[At-least-once delivery](/docs/platform/architecture/idempotency#protocol-support-for-exactly-once-delivery)**: You need to handle duplicate messages. Deduplication can be done by checking `serial` and `version.serial`.

## Using outbound streaming <a id="outbound-streaming"/>

Ably can stream messages directly to your own queueing or streaming service: Kinesis, Kafka, AMQP, SQS. Read the guide on [outbound streaming](/docs/platform/integrations/streaming) for more details on how to set up the streaming integration with Ably for the service of your choice.

Benefits:
- Use your existing queue system to process and save messages from Ably.
- You control your own queue system, so you have full control over message ingestion from queue to database in terms of retry strategies, retention policies, queue lengths, and so on.

You need to consider:
- You need to maintain and be responsible for a reliable queue system. If you don't already have such a system, it increases complexity on your end.
- Consistency. If your queue system is not reachable, you will lose messages. Errors can be seen in the [`[meta]log` channel](/docs/platform/errors#meta).

## Using an Ably queue <a id="ably-queue"/>

Ably can forward messages from chat room channels to an [Ably Queue](/docs/platform/integrations/queues), which you can then consume from your own servers to save messages to your own database. Read the guide on [Ably queues](/docs/platform/integrations/queues) for more details on how to set up the queue integration with Ably.

Ably ensures that each message is delivered to only one consumer even if multiple consumers are connected.

Benefits of using an Ably queue:
- You can consume it from your servers, meaning overall this is fault-tolerant. Ably takes care of the complexity of maintaining a queue.
- You can use multiple queues and configure which channels go to which queue via regex filters on the channel name.
- Fault-tolerant: if your systems suffer any temporary downtime, you will not miss messages, up to the queue max size. There is a deadletter queue to handle the situation where messages are dropped from the Ably Queue.

You need to consider:
- During peak times you may need to scale up your consumers to avoid overloading the queue past the maximum queue length allowed.
- Each message has a time-to-live in the queue. The default and maximum is 60 minutes.
- Oldest messages are dropped if the maximum queue length is exceeded. Check the [dead letter queue](/docs/platform/integrations/queues#deadletter) to see if this is happening.
- Always consume messages from the [dead letter queue](/docs/platform/integrations/queues#deadletter) to monitor errors.

## Publishing via your own servers <a id="publish-via-own"/>

Change the publish path: instead of publishing Chat messages, updates, and deletes to Ably directly, proxy them through your own server. This gives you the opportunity to also save the messages as they are produced, and also apply different validation schemes if needed.

Benefits:
- Full control over publishing.
- Opportunity to add extra validation before publishing to Ably.
- Opportunity to add extra processing or business logic before publishing to Ably.
- You can publish messages directly via the Chat REST API, and avoid having to encode/decode Chat Messages to and from Ably Pub/Sub messages.
- If you are using a supported language, you have the option to publish via the Chat SDK.

You need to consider:
- You need to handle updates and deletes on your own, including all consistency issues that arise from this.
- Storing message reactions will require using one of the other methods presented in this guide, otherwise you will not have access to the aggregates (summaries) that Ably provides.
- Your own servers are in the middle of the message publish path, so they can become a bottleneck in availability and will add latency in the publish path.
- Your own servers will need to handle the scale you operate at for realtime publishes.
- Keeping both systems in sync can be a difficult problem to solve in all edge cases. Inconsistencies can happen if either publishing to Ably or saving to your own database fails. You will need mitigation strategies to handle all failure scenarios to ensure eventual consistency.

## Using the Chat History endpoint <a id="history-endpoint"/>

You can fetch the message history of a chat room using the [Chat History endpoint](/docs/api/chat-rest#tag/rooms/paths/~1chat~1%7Bversion%7D~1rooms~1%7BroomName%7D~1messages/get) or the [Chat SDK](/docs/chat/rooms/history). The chat room history endpoint is a paginated HTTP endpoint that allows you to retrieve messages from a chat room. The Chat SDK provides a convenient way to fetch the history of a chat room.

If your use case is to archive chats that have ended, such as to export the chat history of a support ticket that is closed, you can use the chat history endpoint to export the messages to your own system. Read the docs on [chat history](/docs/chat/rooms/history) for more details.

The intended use of the chat history endpoint is to retrieve messages for pre-filling a chat window, not for continuous ingestion into other systems. As a result, there are some important things to consider:
- The history endpoint is not a changelog, it is a snapshot of the messages in the room at the time the request is made. It returns only the latest version of each message.
- The history API returns messages in their canonical global order (sorted by `serial`).
- You will need to decide when and which rooms to import messages from. The metachannel [`[meta]channel.lifecycle`](/docs/metadata-stats/metadata/subscribe#channel-lifecycle) provides events when channels are opened and closed, but your business logic might provide a better solution, for example import when a support ticket is closed or game session ends.
- You can import the same room multiple times (deduplicate by `serial` and `version.serial`). However, to capture all updates and deletes, you will need to fetch from the first message each time, which can be impractical for long-running chats with large message histories.

For use cases where there is a clear start and end of the chat, exporting the chat via history requests is a simple, reliable solution. If there is no clear start and end for chats, if you require continuous ingestion, or if you need the full message version history, please consider using one of the other methods mentioned in this guide.


## Related documentation

* [Extract messages via integrations](/docs/chat/external-storage-and-processing/data-extraction) - Complete setup guide for webhooks, queues, and streaming
* [Chat integrations](/docs/chat/integrations) - Technical reference for message structure mapping
* [Message structure](/docs/chat/rooms/messages#structure) - Chat message format details
* [Chat history](/docs/chat/rooms/history) - Retrieve historical messages via API
* [Process and respond to messages](/docs/chat/external-storage-and-processing/data-processing) - Guide for bidirectional integrations
