---
title: Frequently asked questions
meta_description: "Complete collection of Ably FAQ answers covering SDK issues, connection troubleshooting, configuration problems, and technical solutions."
meta_keywords: "FAQ, frequently asked questions, Ably SDK, troubleshooting, connection issues, configuration, technical support"
---

Answers to the most commonly asked questions about using Ably's platform and SDKs.

## SDK Configuration <a id="sdk-config"/>

FAQs related to SDK configuration and setup issues.

### How do I configure request timeouts? <a id="realtime-request-timeout"/>

<If lang="javascript,nodejs">

The `realtimeRequestTimeout` option is implemented in ably-js and functions as expected. However, it is missing from the TypeScript declaration in ably-js version 1.2.17. Consequently:

- The option will not appear in editor autocomplete.
- TypeScript users will see a compiler error if they attempt to use it.

**If you are not using TypeScript:**

Use the `realtimeRequestTimeout` option as normal. It may not appear in auto-completion but will work as expected.

**If you are using TypeScript:**

There are two solutions:

1. Cast your options to the `Types.ClientOptions` type:

<Code>
```javascript
import * as Ably from 'ably';

const client = new Ably.Realtime({
  realtimeRequestTimeout: 10000,
} as Ably.Types.ClientOptions);
```
</Code>

2. Augment the `Ably.Types.ClientOptions` type (more scalable):

<Code>
```javascript
import * as Ably from 'ably';

// Place this in a separate .d.ts file or anywhere in your project
declare module 'ably' {
  namespace Types {
    interface ClientOptions {
      realtimeRequestTimeout: number;
    }
  }
}

const client = new Ably.Realtime({
  realtimeRequestTimeout: 10000,
});
```
</Code>

</If>

<If lang="java">

You can configure request timeouts using the `ClientOptions` when initializing the Ably client:

<Code>
```java
import io.ably.lib.realtime.AblyRealtime;
import io.ably.lib.types.ClientOptions;

ClientOptions options = new ClientOptions("your-api-key");
options.httpRequestTimeout = 10000; // 10 seconds in milliseconds
options.httpOpenTimeout = 4000;     // 4 seconds for connection establishment

AblyRealtime ably = new AblyRealtime(options);
```
</Code>

**Available timeout options:**
- `httpRequestTimeout`: Total request timeout including retries
- `httpOpenTimeout`: Connection establishment timeout
- `httpRetryTimeout`: Timeout for individual retry attempts

</If>

### Can I change my connection's clientId after connecting? <a id="client-id-change"/>

A connection's `clientId` is immutable once set.

However, late initialization of `clientId` is possible. For instance, if the library is instantiated with an `authCallback`, the `clientId` may only be known after the callback completes. Similarly, if the library uses an opaque token string, it learns the `clientId` only after the server processes the token. In both cases, the "immutable" requirement is satisfied because the `clientId` is set during the client's first interaction with the server.

## Connection and Network Issues <a id="connection-network"/>

FAQs related to connection problems and network troubleshooting.

### How should I monitor for errors in my Ably application? <a id="monitor-requests"/>

Our SDKs provide mechanisms to notify you of errors, primarily through connection and channel state changes. The connection emits an event when its state changes. If it enters the `disconnected` or `failed` state, the change event includes a reason explaining the cause. In the `disconnected` state, the client automatically retries after 15 seconds. Channel states work analogously. Additionally, client libraries emit logs at the ERROR level, which can usually be accessed programmatically via a custom log handler.

A non-2xx status code on an HTTP request is not a reliable error indicator. Many factors, such as imperfect network connections, can cause HTTP errors, and only a small fraction represent actual problems.

For example, when using Comet, if a token expires and cannot reauthenticate online in time, the recv stream closes with a 401 status code and an errorinfo body with code 40142. This is expected behavior; it simply triggers the library to obtain a new token and resume the connection. Conversely, many actual problems (e.g., errors sent as protocol messages over a WebSocket) do not appear as non-2xx HTTP requests.

The protocol uses the most semantically appropriate status code for each response (like 401 for an expired token) rather than avoiding non-2xx responses.

**Recommendation:** Do not monitor HTTP status codes to detect problems. Instead, use the SDKs' built-in mechanisms, particularly connection state changes.

### Why are my concurrent connection counts higher than expected? <a id="concurrent-connections"/>

This FAQ addresses common reasons for higher-than-expected concurrent connections:

**Potential Issues:**
- Using the Realtime library server-side instead of the REST library.
- Accidentally instantiating multiple Realtime client library instances.
- Browser tab sandboxing causing separate connections per tab.

**Troubleshooting:**
- Monitor connections using the developer console.
- Contact support with diagnostic information.

**Warning:** Significantly exceeding package limits may result in account blocking.

### SSL certificate issues communicating with Ably <a id="ssl-certificate"/>

If you're experiencing SSL/TLS certificate validation errors when connecting to Ably's services, this is often related to outdated certificate stores or network configuration.

Common errors include:
- `cURL error: SSL certificate problem: self signed certificate in certificate chain`
- `SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed`
- `SSL: CERTIFICATE_VERIFY_FAILED certificate verify failed: unable to get local issuer certificate`


### Debugging slow REST requests <a id="slow-requests"/>

If you experience slow REST requests, consider the following causes:

Latency-based routing may occasionally direct requests to the wrong datacenter.

Investigate: Run `curl http://rest.ably.io/404` on the affected machine. The 404 error will include the server ID and AWS region. Check if the region is geographically close.

**SSL Handshake:** Establishing a TLS connection involves a three-way handshake, which can compound high latency.

Investigate: Run the following curl command to measure timing:

<If lang="java">

<Code>
```shell
curl -o /dev/null -s -w "time_namelookup: %{time_namelookup}\
 time_connect: %{time_connect}\
 time_appconnect: %{time_appconnect}\
 time_pretransfer: %{time_pretransfer}\
 time_redirect: %{time_redirect}\
 time_starttransfer: %{time_starttransfer}\
 time_total: %{time_total}\
" https://rest.ably.io/time
```
</Code>

</If>

Repeat with `http://rest.ably.io/time` (non-SSL). The `time_appconnect` result indicates the SSL handshake duration. Note that client libraries use HTTP keep-alive, so the handshake occurs only once for multiple requests in close proximity.

**Channel Creation:** Publishing to a previously inactive channel requires a handshake with other regions, adding latency. The `quickAck` option can help by not waiting for channel creation.

**REST Request Overhead:** REST publishes have higher latency than realtime publishes because they authenticate and check capabilities for every request.

**Recommendation:** Use a realtime client library for lower latency. Realtime libraries maintain a persistent WebSocket connection, performing handshakes and capability checks only once.

## Message Handling <a id="message-handling"/>

FAQs related to message publishing, subscribing, and duplication issues.

### Why am I seeing every message multiple times? <a id="duplicate-messages"/>

If your message listener is called multiple times for every message, it is likely due to one of two causes:

**Duplicate Library Instances:** You may be instantiating the Realtime library more than once on a single page and subscribing to the same channels with both. You should typically have a single library instance per app, as one connection can multiplex hundreds of channels. Ensure you instantiate the library once and share the reference.

**Duplicate Subscriptions:** You may be calling `channel#subscribe` multiple times with the same listener. For example, if you call `subscribe()` inside a connected event listener, it will execute every time the connection state becomes connected (which may happen repeatedly on unstable networks).

<If lang="javascript,nodejs">

**JavaScript - Incorrect Code:**

<Code>
```javascript
// WRONG
realtime.connection.on('connected', () => {
  channel.subscribe(msg => console.log('received: ' + msg.name))
});
```
</Code>

**JavaScript - Correct Code (using once):**

<Code>
```javascript
// BETTER
realtime.connection.once('connected', () => {
  channel.subscribe(msg => console.log('received: ' + msg.name))
});
```
</Code>

Alternatively, call `subscribe()` at the top level instead of inside an on-connected callback.

</If>

<If lang="java">

**Java - Incorrect Code:**

<Code>
```java
// WRONG
ably.connection.on(new ConnectionStateListener() {
    @Override
    public void onConnectionStateChanged(ConnectionStateChange stateChange) {
        if (stateChange.current == ConnectionState.connected) {
            channel.subscribe(new MessageListener() {
                @Override
                public void onMessage(Message message) {
                    System.out.println("Received: " + message.name);
                }
            });
        }
    }
});
```
</Code>

**Java - Correct Code (subscribe outside connection listener):**

<Code>
```java
// BETTER
channel.subscribe(new MessageListener() {
    @Override
    public void onMessage(Message message) {
        System.out.println("Received: " + message.name);
    }
});
```
</Code>

Or use a flag to ensure single subscription:

<Code>
```java
// ALTERNATIVE
private boolean isSubscribed = false;

ably.connection.on(new ConnectionStateListener() {
    @Override
    public void onConnectionStateChanged(ConnectionStateChange stateChange) {
        if (stateChange.current == ConnectionState.connected && !isSubscribed) {
            channel.subscribe(new MessageListener() {
                @Override
                public void onMessage(Message message) {
                    System.out.println("Received: " + message.name);
                }
            });
            isSubscribed = true;
        }
    }
});
```
</Code>

</If>

**Caution:** A bug in the ably-java SDK (versions 1.2.34 to 1.2.47) caused message duplication when using the rewind channel option.

### What is the difference between 'failed' and 'refused' message statistics? <a id="failed-refused-stats"/>

**Refused messages** are actively rejected by Ably. This is typically due to breaching a rate limit, a malformed message, or the client lacking permissions to publish to the channel.

**Failed messages** fail for reasons other than active rejection. Examples include service issues or rejection by an external target (e.g., Integrations or Push messages). Note that all rejections from external systems appear as failed statistics, as Ably cannot distinguish between expected and unexpected external rejections.

## Platform-Specific Issues <a id="platform-specific"/>

FAQs related to specific platforms and environments.

### Can I use Ably with a state manager (eg Redux)? <a id="state-manager"/>

You can create and manage the Ably client external to your application, and use a state management solution like Redux to emit events. While this is probably more complicated, you could subscribe to channels, and raise events in your state management store, and have the store cascade these events to the other components in your application that are connected to the store.

It is difficult to give concrete advice around this topic, because applications can be built in different ways, but if you have any specific questions, please contact Ably support for more specific advice.

<If lang="javascript,nodejs">

### How do I fix CORB errors when using ably-js in Chrome extensions? <a id="chrome-extension-corb"/>

**Background:** Chrome 73 changed how cross-origin requests from content scripts are handled. While intended to align content scripts with their parent pages, the implementation enforces stricter rules. Requests from content scripts do not trigger a CORS preflight for cross-origin requests, whereas the same request from the page would. This causes CORB to block the main request.

**Solutions:**

1. **Run in Background Script:** Run the Ably library in the background script instead of the content script.

2. **Proxy Requests:** If you must run the library in the content script, request the background page to handle REST requests (e.g., token authentication). Instead of using `authUrl`, supply an `authCallback` that asks the background page to request a token. Ensure your auth server calls `requestToken` rather than `createTokenRequest` to avoid the library attempting a REST request.

**Note:** Specify `transports: ['web_socket']` in the client options, as the default XHR transport may fail.

<Code>
```javascript
// Example: Chrome extension configuration
const ably = new Ably.Realtime({
  key: 'your-api-key',
  transports: ['web_socket'], // Avoid XHR transport
  authCallback: async (tokenParams, callback) => {
    // Proxy auth through background script
    chrome.runtime.sendMessage({
      action: 'getAblyToken',
      tokenParams: tokenParams
    }, (response) => {
      callback(null, response.token);
    });
  }
});
```
</Code>

### Can I ignore the 'long timer' warning with ably-js in React Native Android? <a id="react-native-timer"/>

ably-js uses timers of up to two minutes (for connection state recovery). Some React Native versions on Android warn about timers longer than 60 seconds because Android may not call JavaScript timers when the activity is in the background. React Native uses a heuristic that suggests long timers might be critical (e.g., alarms) and should fire even in the background.


### Why do Ably connections timeout immediately in React Native? <a id="react-native-timeout"/>

If a realtime connection immediately transitions from connecting to disconnected with the reason "Connection to server temporarily unavailable", the device time may be incorrect. This often occurs in emulators or debug mode, where `setTimeout` can break.

**Diagnosis:**
Run `setTimeout(() => console.log("done"), 10000)`. If it prints "done" immediately instead of after 10 seconds, you have this issue.

### How do I fix 'Cannot read properties of undefined' in Next.js? <a id="nextjs-build-error"/>

This issue is documented in [Next.js issue 58623](https://github.com/vercel/next.js/issues/58623). Resolve it by upgrading Next.js to version 14.0.4.

</If>

<If lang="java">

### How do I handle network changes on Android? <a id="android-network-changes"/>

Android devices frequently change networks (WiFi to mobile data, etc.). The Ably Java SDK handles this automatically, but you may want to monitor network state changes:

<Code>
```java
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;

public class NetworkStateReceiver extends BroadcastReceiver {
    private AblyRealtime ably;

    public NetworkStateReceiver(AblyRealtime ably) {
        this.ably = ably;
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        ConnectivityManager cm = (ConnectivityManager)
            context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();

        if (activeNetwork != null && activeNetwork.isConnected()) {
            // Network is available - Ably will automatically reconnect
            Log.d("Ably", "Network available");
        } else {
            // Network lost - connection will be handled by Ably SDK
            Log.d("Ably", "Network lost");
        }
    }
}

// Register the receiver in your Activity
IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
NetworkStateReceiver receiver = new NetworkStateReceiver(ably);
registerReceiver(receiver, filter);
```
</Code>

### How do I handle ProGuard obfuscation issues? <a id="proguard-issues"/>

When using ProGuard with the Ably Android SDK, certain classes need to be preserved from obfuscation:

<Code>
```java
# Ably SDK ProGuard rules
-keep class io.ably.lib.** { *; }
-keep class org.msgpack.core.** { *; }

# If using push notifications
-keep class com.google.firebase.** { *; }
-keep class io.ably.lib.push.** { *; }

# Preserve WebSocket classes
-keep class okhttp3.** { *; }
-keep class okio.** { *; }
```
</Code>

</If>

## Installation and Build Issues <a id="installation-build"/>

FAQs related to installation and build problems.

<If lang="javascript,nodejs">

### How do I fix git errors when installing ably-js with npm? <a id="npm-install-git-error"/>

When installing Ably Pub/Sub JavaScript SDK with npm, you get "Error while executing: /usr/bin/git ls-remote -h -t https://github.com/ably-forks/msgpack-js.git"

Try the following two commands:

<Code>
```shell
git ls-remote -h -t git://github.com/ably-forks/msgpack-js.git
git ls-remote -h -t https://github.com/ably-forks/msgpack-js.git
```
</Code>

If the first works but the second fails, configure git to use the git protocol instead of HTTPS:

<Code>
```shell
git config --global url."git://".insteadOf https://
```
</Code>

Then attempt to install ably-js again.

### How do I resolve webpack/bundler issues with Ably Pub/Sub JavaScript SDK? <a id="webpack-issues"/>

If you encounter bundling issues with ably-js, try these solutions:

**For Webpack 5:**

<Code>
```javascript
// webpack.config.js
module.exports = {
  resolve: {
    fallback: {
      "buffer": require.resolve("buffer/"),
      "url": require.resolve("url/"),
      "util": require.resolve("util/")
    }
  },
  plugins: [
    new webpack.ProvidePlugin({
      Buffer: ['buffer', 'Buffer'],
    }),
  ]
};
```
</Code>

**For Vite:**

<Code>
```javascript
// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  define: {
    global: 'globalThis',
  }
})
```
</Code>

</If>

<If lang="java">

### ClassNotFoundException when using Proguard with ably-java <a id="proguard-classnotfound"/>

When using Proguard with the Java client library, use the following flags to avoid ClassNotFoundException issues:

<Code>
```java
-keep class io.ably.lib.** { *; }
-keep class org.msgpack.core.** { *; }
```
</Code>

### How do I resolve Gradle build issues with ably-android? <a id="gradle-issues"/>

**Dependency conflicts:**

<Code>
```java
// In your app's build.gradle
android {
    packagingOptions {
        pickFirst '**/libc++_shared.so'
        pickFirst '**/libjsc.so'
    }
}

dependencies {
    implementation 'io.ably:ably-android:1.2.0'

    // If you have conflicts with WebSocket libraries
    configurations.all {
        exclude group: 'org.java-websocket', module: 'Java-WebSocket'
    }
}
```
</Code>

**MultiDex issues:**

<Code>
```java
// Enable MultiDex if you hit the 64K method limit
android {
    defaultConfig {
        multiDexEnabled true
    }
}

dependencies {
    implementation 'androidx.multidex:multidex:2.0.1'
}
```
</Code>

</If>

## Migration and Framework Transitions <a id="migration"/>

FAQs related to migrating from other realtime solutions to Ably.

### Moving from Socket.io to Ably <a id="socketio-migration"/>

Below is a guide to some of the basic transitioning from Socket.io to Ably. For more help, please get in touch with us and we'll be happy to help you.

The socket.io API is actually very similar to the Ably API, if you take a look at our quick start guide: https://www.ably.io/documentation/quick-start-guide

**To connect**

In socketIO:
<Code>
```javascript
io.on('connection', (socket) => {
  console.log('a user connected');
});
```
</Code>

In Ably:
<Code>
```javascript
ably.connection.on('connected', function() {  
    alert("That was simple, you're now connected to Ably in realtime");
});
```
</Code>

**Sending a message:**

In SocketIO:
<Code>
```javascript
io.on('connection', (socket) => {
   socket.broadcast.emit('message-name', 'hello there this is my message');
});
```
</Code>

In Ably, you need to first have a channel set up and then you can send and receive on that channel:
<Code>
```javascript
var channel = ably.channels.get('test-channel');
channel.publish('message-name', 'hello there this is my message');
```
</Code>

**To receive a message:**

In SocketIO:
<Code>
```javascript
socket.on('message-name', (message) => {
    console.log('message was: ' + message);
});
```
</Code>

In Ably any subscribers to the channel that you created will receive the message:
<Code>
```javascript
channel.subscribe('test-channel', function(message) {
  console.log('message was: ' + message.data);
});
```
</Code>

