---
title: Push Notifications - Device activation and subscription
section: general
index: 44
hide_from_nav: true
api_separator:
  Tutorials:
    - Push Tutorials:/tutorials#tut-push-notifications
languages:
  - android
  - swift
  - objc
jump_to:
  Help with:
    - Prerequisites for push#prerequisites
    - Platform installation#platform-install
    - Activating push on your device#device-activation
    - Subscribing to push notifications#subscribing
---

Every device that will receive push notifications must activate itself with the local operating system or framework, and hook into the push notification services that the underlying platform provides. This functionality is platform-specific and can also vary considerably across not just platforms, but also across the push services that operate on those platforms such as GCM and FCM, both of which are available on the Android platform.

The Ably client libraries aim to abstract away this complexity and platform-specific behaviour by providing a consistent API for device activation, maintenance of the device registration, and for subscription to Ably channels for receiving push notifications.

<a href="/images/diagrams/push-process.png" target="_blank">
  <img src="/images/diagrams/push-process.png" style="width: 100%" alt="Push Notifications process using Ably">
</a>

The client libraries also provide a set of admin functionality that is typically used server-side (in a trusted environment) to manage all devices and push notification delivery and subscriptions. You can find out more in the "push admin documentation":/general/push/admin.

In this section, we will run you through all of the features that a push notification device has available to it.

h2(#prerequisites). Prerequisites

Before you can configure your devices to receive push notifications, you must first enable push in your Ably app by adding the third party push service credentials and/or certificates to your app push dashboard. These credentials are then used by Ably to authenticate with the respective third party push service (such as APNs) and delivery all queued notifications.

If you have not already done so, you can sign up for a free account with "Apple's Push Notification service":https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html and Google's "Firebase Cloud Messaging service":https://firebase.google.com/docs/cloud-messaging/.

h2(#platform-install). Platform installation

p(tip). Whilst platform installation is platform-specific, all subsequent Ably API calls are generally portable. Be sure to choose a language above that you wish to see the documentation and code examples in.

Before you can activate your push device or receive push notifications, you must first plug in Ably to the underlying OS or platform. Once Ably is plugged in, all subsequent API interactions you have will be with the Ably Realtime library API which is as consistent as possible across all platforms. By providing a consistent API interface across all platforms, we aim to ensure implementation is simpler and more predictable regardless of the platform you are integrating Ably with.

Installation, however, is platform-specific and as such, instructions for each platform and service are provided below:

h3. Install Ably for Google Firebase Cloud Messaging on Android

As with any Firebase-enabled app, you need to include one or more services within your app to handle interactions with Firebase. You need to have a service that extends "FirebaseMessagingService":https://firebase.google.com/docs/reference/android/com/google/firebase/messaging/FirebaseMessagingService (and overrides "@onMessageReceived()@":https://firebase.google.com/docs/reference/android/com/google/firebase/messaging/FirebaseMessagingService) in order to handle incoming push messages; the code that handles incoming push messages does not need to interact with Ably in any way.

The second requirement is that your app integrates with Firebase to handle registration token notifications, and these notifications do need to be passed to Ably; the registration token is used by Ably's servers to be able to push messages to each specific device. You can be notified of token updates either be by overriding "@onNewToken()@":https://firebase.google.com/docs/reference/android/com/google/firebase/messaging/FirebaseMessagingService in your derived "@FirebaseMessagingService@":https://firebase.google.com/docs/reference/android/com/google/firebase/messaging/FirebaseMessagingService, or by overriding "@onTokenRefresh()@":https://firebase.google.com/docs/reference/android/com/google/firebase/iid/FirebaseInstanceIdService in a service that derives from "@FirebaseInstanceIdService@":https://firebase.google.com/docs/reference/android/com/google/firebase/iid/FirebaseInstanceIdService. A convenient way to do the latter is to extend "@AblyFirebaseInstanceIdService@;":https://github.com/ably/ably-java/blob/release-1.1.0/android/src/main/java/io/ably/lib/push/AblyFirebaseInstanceIdService.java in this case your service's parent class handles the token update, so you do not need to do anything other than ensure the service is activated.

If you are handling token indications in your own code, registration tokens must be notified to the Ably library by calling @AblyFirebaseInstanceIdService.onNewRegistrationToken()@. If deriving from "@FirebaseInstanceIdService@":https://firebase.google.com/docs/reference/android/com/google/firebase/iid/FirebaseInstanceIdService directly, for example, your class should end up looking more or less like this:

```[android]
public class MyRegistrationTokenService extends FirebaseInstanceIdService {
    @Override
    public void onTokenRefresh() {
        // Get updated InstanceID token.
        String token = FirebaseInstanceId.getInstance().getToken();
        // Notify Ably
        AblyFirebaseInstanceIdService.onNewRegistrationToken(this, token);
    }
}
```

h3. Install Ably for Apple Push Notifications on iOS

You should now have a couple of methods: <span lang="swift">"@application(_:didRegisterForRemoteNotificationsWithDeviceToken:)@":https://developer.apple.com/reference/uikit/uiapplicationdelegate/1622958-application</span><span lang="objc">"@application:didRegisterForRemoteNotificationsWithDeviceToken:@":https://developer.apple.com/reference/uikit/uiapplicationdelegate/1622958-application?language=objc</span> and <span lang="swift">"@application(_:didFailToRegisterForRemoteNotificationsWithError:)@":https://developer.apple.com/reference/uikit/uiapplicationdelegate/1622962-application</span><span lang="objc">"@application:​did​Fail​To​Register​For​Remote​Notifications​With​Error:​@":https://developer.apple.com/reference/uikit/uiapplicationdelegate/1622962-application?language=objc</span>. @ARTPush@ has two corresponding methods that you should call from yours, passing to them also an @ARTRealtime@ instance, configured with the authentication setup and other options you need.

```[objc]
// In your UIApplicationDelegate class:
- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
    [ARTPush didRegisterForRemoteNotificationsWithDeviceToken:deviceToken realtime:[self getAblyRealtime]];
}

- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error;
    [ARTPush didFailToRegisterForRemoteNotificationsWithError:error realtime:[self getAblyRealtime]];
}

- (ARTRealtime *)getAblyRealtime {
    ARTClientOptions *options = [[ARTClientOptions alloc] init];
    // Set up options; API key or auth URL, etc.
    return [[ARTRealtime alloc] initWithOptions: options];
}
```
```[swift]
// In your UIApplicationDelegate class:
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
    ARTPush.didRegisterForRemoteNotifications(withDeviceToken: deviceToken, realtime: self.getAblyRealtime())
}

func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
    ARTPush.didFailToRegisterForRemoteNotificationsWithError(error, realtime: self.getAblyRealtime())
}

func getAblyRealtime() -> ARTRealtime {
    var options = ARTClientOptions()
    // Set up options; API key or auth URL, etc.
    return ARTRealtime(options: options)
}
```

h2(#device-activation). Activating push on your device

Activating a device for push notifications and registering it with Ably is commonly performed entirely from the device. However, it is possible to separate the concerns such that activation with the underlying platform is performed on the device, and registration of that activated device with Ably is performed using your own servers. This latter pattern is more commonly used when you want to minimize the capabilities assigned to an untrusted device. "Find out how to register the device from your servers":#activation-from-server

<a href="/images/diagrams/push-device-direct-registration.png" target="_blank">
  <img src="/images/diagrams/push-device-direct-registration.png" style="width: 100%" alt="Push Notifications direct device registration">
</a>

In the following example, we will both activate the device with the underlying platform and register the device with Ably from the device itself.

h3. Activate the device for push with @push.activate@

If you want to start receiving push notifications from Ably (e.g. from <span lang="android">your main activity</span><span lang="objc,swift">your @UIApplicationDelegate@</span>), you need to first call "<span lang="android">@AblyRealtime.push.activate@</span><span lang="objc,swift">@ARTRealtime.push.activate@</span>":#activate which will *register the device for push* by doing the following on your behalf:

* Ensure the Ably client is authenticated
* Generate a unique identifier for this device and store this in local storage
* Activate the device for push notifications with the underlying OS or platform and obtain a unique identifier for the device as a push recipient. For example, in FCM this is described as a "@registration token@":https://firebase.google.com/docs/cloud-messaging/android/client#sample-register, and in APNs this is described as a "@device token@":https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html
* Register the local device with Ably using the device's unique identifier, platform-specific details such as form factor and OS, and the push recipient details to receive push notifications. This in turn ensures Ably can reach this device and deliver push notifications
* Store the "@deviceIdentityToken@":#local-device from the response from Ably in local storage so that subsequent requests to Ably to update push recipient details are authenticated as being from the device in question.

Please note that the effects of calling "@activate@":#activate outlives the current process. Once called, the device will stay registered even after the application is closed, and up until "@deactivate@":#deactivate is called. "@activate@":#activate is idempotent: calling it again when device is already activated has the sole effect of calling its callback.

```[android]
AblyRealtime ably = getAblyRealtime();
ably.setAndroidContext(context)
ably.push.activate();
```
```[objc]
ARTRealtime *ably = [self getAblyRealtime];
[ably.push activate];
```
```[swift]
let ably = self.getAblyRealtime()
ably.push.activate()
```

Please bear in mind that in order for the client to register itself automatically with Ably, it needs to be authenticated and have "the required @push-subscribe@ capability":#required-capabilities. If you would prefer to delegate registration of the push device to your own servers and not allow devices to register themselves directly with Ably, then see the section "how to register devices from your server":#activation-from-server. You can also check "our recommendations":#server-vs-direct-registration for choosing either registration strategy.

h3. Register for callback from @activate@

Once "@activate@":#activate is called, the aforementioned activation and registration process kicks off in the background. Once completed, a callback will be invoked if registered. We recommend you set up this callback so that you will be notified when push activation has succeeded or failed. Once the device has successfully been activated, you can then start subscribing for push notifications on channels and receiving push notifications via Ably.

When the activation process is completed, Ably will <span lang="android">send a broadcast through the application's "@LocalBroadcastManager@":https://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager. You should listen for a broadcast with action @io.ably.broadcast.PUSH_ACTIVATE@</span><span lang="objc,swift">call your </span><span lang="objc">@(void)didActivateAblyPush:(nullable ARTErrorInfo *)error@</span><span lang="swift">@didActivateAblyPush(error: ARTErrorInfo?)@</span><span lang="objc,swift"> method from your @ARTPushRegistererDelegate@ implementation </span> as follows:

```[android]
LocalBroadcastManager.getInstance(context.getApplicationContext()).registerReceiver(new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        ErrorInfo error = IntentUtils.getErrorInfo(intent);
        if (error != null) {
            // Handle error
            return;
        }
        // Subscribe to channels / listen for push etc.
    }
}, new IntentFilter("io.ably.broadcast.PUSH_ACTIVATE"));

ably.push.activate(context);
```
```[objc]
// Add the activate method from 'ARTPushRegistererDelegate' to your 'UIApplicationDelegate' class:
- (void)didActivateAblyPush:(nullable ARTErrorInfo *)error {
    if (error) {
        // Handle error
        return;
    }
    // Subscribe to channels / listen for push etc.
}

// Call activate, which will call the delegate method when done:
[ably.push activate];
```
```[swift]
// Add the activate method from 'ARTPushRegistererDelegate' to your 'UIApplicationDelegate' class:
func didActivateAblyPush(_ error: ARTErrorInfo?) {
    if let error = error {
        // Handle error
        return
    }
    // Subscribe to channels / listen for push etc.
}

// Call activate, which will call the delegate method when done:
ably.push.activate()
```

h2(#subscribing). Subscribe for push notifications

Before you subscribe to a channel for push, make sure its "channel namespace is configured to explicitly enable push notifications":https://support.ably.io/solution/articles/3000030057-what-are-channel-rules-and-how-can-i-use-them-in-my-app. By default, push notifications on channels are disabled.

There are two ways a device can be subscribed to a channel: directly "by its device ID":#subscribing-device-id, or indirectly "by its associated client ID":#subscribing-client-id.

h3(#subscribing-device-id). Subscribing by device ID

A **device ID** uniquely identifies a device within Ably's services and is assigned automatically at the time the device is activated.

If your client "has the push-subscribe capabilities":#push-capabilities, you can do the following:

```[objc]
[[realtime.channels get:@"pushenabled:foo"].push subscribeDevice:^(ARTErrorInfo *error) {
    // Check error.
}];
```
```[swift]
realtime.channels.get("pushenabled:foo").push.subscribeDevice { error
    // Check error.
}
```
```[android]
realtime.channels.get("pushenabled:foo").push.subscribeDevice(context);

// or

realtime.channels.get("pushenabled:foo").push.subscribeDeviceAsync(context, new CompletionListener() {
    @Override
    public void onSuccess() {}

    @Override
    public void onError(ErrorInfo errorInfo) {
        // Handle error.
    }
});
```

If your client doesn't have the @push-subscribe@ permissions, you should communicate the device ID to your server so that it can subscribe on the device's behalf. You can find your unique device ID at "<span lang="objc,swift">@ARTRealtime.device.id@</span><span lang="android">@AblyRealtime.device().id@</span>":#device-details. The server must then "use the push admin API":/general/push/admin to subscribe the device.

h3(#subscribing-client-id). Subscribing by client ID

When a device is registered, it can be associated with a "client ID":/realtime/authentication/#identified-clients. "<span lang="android">@AblyRealtime.push.activate@</span><span lang="objc,swift">@ARTRealtime.push.activate@</span>":#activate takes the client ID from the @AblyRealtime@ instance.

You can subscribe all devices associated with a client ID to a channel in a single operation; that is, create a subscription by client ID. New device registrations associated to that client ID will also be subscribed to the channel, and if a device registration is no longer associated with that client ID, it will also stop being subscribed to the channel (unless it's also "subscribed directly by device ID":#subscribing-device-id).

To subscribe your @AblyRealtime@ instance's client ID to a channel:

```[objc]
[[realtime.channels get:@"pushenabled:foo"].push subscribeClient:^(ARTErrorInfo *error) {
    // Check error.
}];
```
```[swift]
realtime.channels.get("pushenabled:foo").push.subscribeClient { error
    // Check error.
}
```
```[android]
realtime.channels.get("pushenabled:foo").push.subscribeClient();

// or

realtime.channels.get("pushenabled:foo").push.subscribeClientAsync(new CompletionListener() {
    @Override
    public void onSuccess() {}

    @Override
    public void onError(ErrorInfo errorInfo) {
        // Handle error.
    }
});
```

Alternatively, if you want to subscribe a different client ID not currently associated with the currently authenticated realtime instance, you can "use the admin API":/general/push/admin.

h2(#push-capabilities). Push capabilities

These are the "capabilities":/core-features/authentication/#capabilities-explained necessary to perform push operations:

* @push-subscribe@: Register and deregister the local device, and subscribe and unsubscribe the local device to channels for push notifications.
* @push-admin@: Register, update and deregister any device registration, and subscribe and unsubscribe to channels for push notifications. Publish push notification using the @POST /push/publish@ endpoint (@AblyRealtime.push.admin.publish@ method).

Typically, client devices subscribing for push will either have @push-subscribe@ privileges or "delegate operations to a server":#activation-from-server with @push-admin@ privileges.

h2(#activation-from-server). Activating devices from your server

The default for @AblyRealtime.push.activate@ is to register the device with Ably directly from the device, but you can instead delegate that to your server. Don't forget to register the device using the "push admin API":/general/push/admin in your server.

<a href="/images/diagrams/push-device-server-registration.png" target="_blank">
  <img src="/images/diagrams/push-device-server-registration.png" style="width: 100%" alt="Push Notifications device registration via server">
</a>


blang[objc,swift].
  For this, your @UIApplicationDelegate@ must implement these optional methods from @ARTPushRegistererDelegate@:

  ```[objc]
  - (void)ablyPushCustomRegister:(ARTErrorInfo *)error
                   deviceDetails:(ARTDeviceDetails *)deviceDetails
                        callback:(void (^)(ARTDeviceIdentityTokenDetails * _Nullable, ARTErrorInfo * _Nullable))callback {
      if (error) {
          // Handle error.
          callback(nil, error);
          return;
      }

      [self registerThroughYourServer:deviceDetails callback:callback];
  }

  - (void)ablyPushCustomDeregister:(ARTErrorInfo *)error d
                          deviceId:(ARTDeviceId *)deviceId
                          callback:(void (^)(ARTErrorInfo * _Nullable))callback {
      if (error) {
          // Handle error.
          callback(nil, error);
          return;
      }

      [self unregisterThroughYourServer:deviceDetails callback:callback];
  }
  ```
  ```[swift]
  func ablyPushCustomRegister(_ error: ARTErrorInfo?, deviceDetails: ARTDeviceDetails, callback: @escaping (ARTDeviceIdentityTokenDetails?, ARTErrorInfo?) -> Void) {
      if let e = error {
          // Handle error.
          callback(nil, e)
          return
      }

      self.registerThroughYourServer(deviceDetails: deviceDetails, callback: callback)
  }

  func ablyPushCustomDeregister(_ error: ARTErrorInfo?, deviceId: String, callback: ((ARTErrorInfo?) -> Void)? = nil) {
      if let e = error {
          // Handle error.
          callback(nil, e)
          return
      }

      self.unregisterThroughYourServer(deviceDetails: deviceDetails, callback: callback)
  }
  ```

blang[android].
  For this, you need to communicate back and forth with the Ably library via the application's "@LocalBroadcastManager@":https://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.

  First, make sure you pass @true@ as the @useCustomRegisterer@ parameter to "@activate@":#activate (and for "@deactivate@":#deactivate).

  ```[android]
  ably.push.activate(context, true);
  ably.push.deactivate(context, true);
  ```

  The Ably library will then broadcast an @io.ably.broadcast.PUSH_REGISTER_DEVICE@ action when it needs you to register from your server, and @io.ably.broadcast.PUSH_DEREGISTER_DEVICE@ when it needs you to deregister. You must configure a listener to those actions in your application's @AndroidManifest.xml@, and from it answer back with a @PUSH_DEVICE_REGISTERED@ or @PUSH_DEVICE_DEREGISTERED@, like this:

  ```[xml]
  <receiver android:name=".MyAblyBroadcastReceiver" >
    <intent-filter>
       <action android:name="io.ably.broadcast.PUSH_REGISTER_DEVICE" />
       <action android:name="io.ably.broadcast.PUSH_DEREGISTER_DEVICE" />
    </intent-filter>
  </receiver>
  ```

  ```[android]
  public class MyAblyBroadcastReceiver extends BroadcastReceiver {
      @Override
      public void onReceive(Context context, Intent intent) {
          AblyRealtime ably = getAblyRealtime();
          String action = intent.getAction();

          if (action.equals("io.ably.broadcast.PUSH_REGISTER_DEVICE")) {
              DeviceDetails device = ably.device(context);
              boolean isNew = intent.getBooleanExtra("isNew", false);

              Intent response = new Intent("io.ably.broadcast.PUSH_DEVICE_REGISTERED");

              try {
                  String deviceIdentityToken = registerThroughYourServer(device, isNew);
                  response.putExtra("deviceIdentityToken", deviceIdentityToken);
              } catch(AblyException e) {
                  IntentUtils.addErrorInfo(intent, e.errorInfo);
              }

              LocalBroadcastManager.getInstance(context.getApplicationContext()).sendBroadcast(intent);
          } else if (action.equals("io.ably.broadcast.PUSH_DEREGISTER_DEVICE")) {
              DeviceDetails device = ably.device(context);

              Intent response = new Intent("io.ably.broadcast.PUSH_DEVICE_DEREGISTERED");

              try {
                  deregisterThroughYourServer(device.id);
              } catch(AblyException e) {
                  IntentUtils.addErrorInfo(intent, e.errorInfo);
              }

              LocalBroadcastManager.getInstance(context.getApplicationContext()).sendBroadcast(intent);
          }
      }
  }
  ```

h2(#server-vs-direct-registration). Direct registration vs. registration via your server

Two options for registering devices gives you the flexibility to implement push notifications in the best way for each use case.

Direct registration means less server side code as the device registers itself and attaches to a channel. However, this means you need to trust your devices to handle this securely and efficiently. Token authentication solves this.

If you want to control all of your devices server side then registration via server is the way to go. The Ably Push Admin API lets you do this.

<%= partial partial_version('general/push/_push_intro') %>

h1. Push Device API reference

inline-toc.
  Methods:
    - activate()#activate
    - deactivate()#deactivate
  Related types:
    - DeviceDetails#device-details
    - LocalDevice#localdevice
    - PushChannel#push-channel
    - PushChannelSubscription#push-channel-subscription
    - PaginatedResult#paginated-result

<%= partial partial_version('types/_push_device') %>

h2(#related-types). Related types

h3(#device-details).
  default:    DeviceDetails
  ruby:       Ably::Models::DeviceDetails
  swift,objc: ARTDeviceDetails

<%= partial partial_version('types/_device_details') %>

h3(#local-device).
  default: LocalDevice
  ruby:    Ably::Models::LocalDevice

<%= partial partial_version('types/_local_device') %>

h3(#push-channel).
    default: PushChannel
    ruby:    Ably::Models::PushChannel

<%= partial partial_version('types/_push_channel') %>

h3(#push-channel-subscription).
  default:      PushChannelSubscription
  ruby:         Ably::Models::PushChannelSubscription
  java,android: ChannelSubscription
  swift,objc:   ArtPushChannelSubscription

<%= partial partial_version('types/_push_channel_subscription') %>

h3(#paginated-result).
  default:      PaginatedResult
  swift,objc:   ARTPaginatedResult
  ruby:         Ably::Models::PaginatedResult
  java,android: io.ably.lib.types.PaginatedResult
  csharp:       IO.Ably.PaginatedResult

<%= partial partial_version('types/_paginated_result') %>
