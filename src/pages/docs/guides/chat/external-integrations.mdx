---
title: "Guide: Integrate external systems with Ably Chat"
meta_description: "Extend Ably Chat with external integrations: process messages with AI, webhooks, and custom logic at scale."
meta_keywords: "chat integrations, external systems, webhooks, AI chat, message processing, chat automation, integration rules, message routing"
---

Ably Chat is designed for extensibility. Whether you need to process messages with AI, translate content in real-time, trigger business workflows, or enrich messages with external data, Ably's integration capabilities enable you to extend your chat application without compromising on scale, reliability, or performance.

This guide explains how to architect integrations that process chat messages through external systems and respond back to the chat in real-time.

## Why integrate external systems? <a id="why-integrate"/>

Integrating external systems with Ably Chat enables you to extend your chat application beyond simple message delivery. Common integration use cases include:

* **AI-powered assistance:** Process commands or questions through language models and respond with helpful information
* **Real-time translation:** Automatically translate messages for multilingual chat rooms
* **Notifications:** Detect and process mentions, or trigger custom notification services
* **Analytics and monitoring:** Analyze sentiment, track engagement metrics, or identify trending topics
* **Workflow automation:** Trigger external business processes based on chat activity
* **Command processing:** Handle slash commands that invoke server-side logic

## Why Ably for external integrations? <a id="why-ably"/>

Ably Chat integrations are built on Ably's proven platform architecture:

* **Reliable message delivery:** Every integration benefits from Ably's [four pillars of dependability](/docs/platform/architecture): Performance, Integrity, Reliability, and Availability
* **Flexible routing:** Use channel filters to selectively route only the messages that need processing
* **Multiple integration methods:** Choose webhooks, queues, or streaming based on your architecture and scale requirements
* **Proven at scale:** Ably processes over 500 million messages per day with [serverless scalability](/docs/platform/architecture/platform-scalability)
* **No vendor lock-in:** Integrate with any external service using any language or platform

Because Ably Chat rooms use Pub/Sub channels as their underlying transport, you can leverage all of Ably's [platform integrations](/docs/platform/integrations) to extend your chat application.

## Understanding the integration flow <a id="integration-flow"/>

The typical integration flow works as follows:

1. A user sends a message to a chat room, optionally including [metadata or headers](#metadata-headers) to control processing
2. An integration rule evaluates the message based on room name pattern matching
3. If the rule matches, Ably forwards the message to your external system
4. Your external system processes the message (AI inference, translation, business logic, etc.)
5. The external system [sends a response](#responding) back to the chat room
6. All subscribed clients receive the response in real-time

This bidirectional flow enables powerful patterns like chatbots, automated support, real-time translation, and more.

## Choosing an integration method <a id="implementation-options"/>

Ably provides three integration methods, each suited to different use cases:

### Webhooks

[Outbound webhooks](/docs/platform/integrations/webhooks) are ideal for simple business logic and event-driven actions.

**Best for:**
* Processing @mentions or triggering custom notifications
* Executing lightweight business logic (lookup, validation, etc.)
* Serverless architectures (AWS Lambda, Cloud Functions, etc.)

**Learn more:** See [Extract messages via integrations](/docs/chat/rooms/message-extraction#webhooks) for setup details and code examples.

### Ably Queues

[Ably Queues](/docs/platform/integrations/queues) provide strict ordering and fault-tolerant delivery.

**Best for:**
* Automated support flows where message order matters
* Processing sequential events (game moves, transaction steps)
* Fault-tolerant message processing with automatic retries

**Learn more:** See [Extract messages via integrations](/docs/chat/rooms/message-extraction#queues) for setup details and code examples.

### Streaming

[Outbound streaming](/docs/platform/integrations/streaming) enables massive scale and integration with existing infrastructure.

**Best for:**
* High-throughput scenarios (large-scale chats, millions of messages)
* Existing streaming infrastructure (Kafka, Kinesis, etc.)
* Complex data pipelines and analytics

**Learn more:** See [Extract messages via integrations](/docs/chat/rooms/message-extraction#streaming) for setup details and code examples.

## Using metadata and headers <a id="metadata-headers"/>

Metadata and headers enable you to control how messages are processed by external systems and add context for integration logic.

### Metadata

Message [`metadata`](/docs/chat/rooms/messages#structure) is set by the client when sending a message. Use metadata for business data that should persist with the message.

<Code>
```javascript
// Client sends message with metadata
await room.messages.send({
  text: 'What is the weather in London?',
  metadata: {
    intent: 'weather-query',
    location: 'London',
    userId: 'user-123'
  }
});
```
</Code>

**Important:** Metadata is not server-validated. Always treat it as untrusted user input in your integration code.

### Headers

Message [`headers`](/docs/chat/rooms/messages#structure) can be set by the client, but can also be added by integration rules at the server level. This makes headers useful for adding server-authoritative routing data.

<Code>
```javascript
// Client sends message with headers
await room.messages.send({
  text: '@bot translate "Hello, nice to meet you!"',
  headers: {
    'x-command': 'translate',
    'x-target-lang': 'fr'
  }
});
```
</Code>

Headers can also be added by your integration rule configuration in the Ably dashboard, providing server-authoritative data that clients cannot tamper with. This is useful for routing decisions or adding trusted context before messages reach your integration.

### Metadata vs Headers

Both metadata and headers are persisted with messages and accessible in your integration:

| | Metadata | Headers |
|---|----------|---------|
| **Set by** | Client only | Client or integration rule |
| **Best for** | Non-critical client specific data | Routing logic and server-authoritative data |
| **Trusted?** | No (client-controlled) | Partially (rule-added headers are trusted) |
| **Use case** | Context, intent | Integration routing |

## Understanding channel names and room names <a id="channel-names"/>

Chat rooms are underpinned by Ably Pub/Sub channels with a `::$chat` suffix added to form the full channel name. When using the Chat SDK to create or get a room, this is done automatically - you don't need to include the suffix yourself.

Integration rules match against the full channel name, but you don't need to include the `::$chat` suffix in your filter pattern.

<Code>
```javascript
// Get a chat room - the room name becomes the channel name with ::$chat suffix
const supportRoom = await chatClient.rooms.get('chat:support');
// Underlying channel: chat:support::$chat

// Messages sent to these rooms will trigger an integration
// if your rule's channel filter is: ^chat:support.*
await supportRoom.messages.send({ text: 'Need help' });

// Messages sent to other channel patterns will NOT trigger the integration
const generalRoom = await chatClient.rooms.get('chat:general');
// Underlying channel: chat:general::$chat
await generalRoom.messages.send({ text: 'Hi' }); // Won't trigger if filter is ^chat:support.*
```
</Code>

## Processing messages in your integration <a id="processing"/>

When your integration receives messages, extract the metadata and headers to control processing logic.

<Code>
```javascript
const Ably = require('ably');

async function processIntegrationPayload(envelopeData) {
  // Decode messages using Ably SDK
  const decodedMessages = Ably.Realtime.Message.fromEncodedArray(envelopeData.messages);

  for (const msg of decodedMessages) {
    // Extract text content
    const text = msg.data?.text;

    // Extract headers for routing
    const headers = msg.extras?.headers || {};
    const command = headers['x-command'];

    // Extract metadata for business context (treat as untrusted)
    const metadata = msg.data?.metadata || {};
    const intent = metadata.intent;

    // Extract room name for sending responses
    const roomName = envelopeData.channel.replace('::$chat', '');

    // Route based on headers or metadata
    if (command === 'translate') {
      await handleTranslation(text, headers['x-target-lang'], roomName);
    } else if (intent === 'weather-query') {
      await handleWeatherQuery(metadata.location, roomName);
    }
  }
}
```
</Code>

For complete details on message decoding and structure, see [Extract messages via integrations](/docs/chat/rooms/message-extraction#decoding).

## Responding back to chat <a id="responding"/>

After processing messages through your external system, publish responses back to the chat room. This completes the bidirectional integration flow.

### Avoiding infinite loops

When your integration responds back to chat, ensure responses don't trigger the same integration rule. Use Ably's [skip integrations](/docs/platform/integrations/skip-integrations) feature to publish messages that bypass integration rules.

**Note:** Your API key or token must have the [`privileged-headers`](/docs/auth/capabilities#capability-operations) capability to skip integrations.

<Code>
```javascript
const { ChatClient } = require('@ably/chat');

async function sendResponseToChat(roomName, responseText) {
  // Initialize Chat client with privileged API key
  const chatClient = new ChatClient({ key: 'YOUR_API_KEY' });

  // Get the chat room
  const room = await chatClient.rooms.get(roomName);

  // Send response message skipping integration rules
  await room.messages.send({
    text: responseText
  }, {
    extras: {
      privileged: {
        skipRule: '*' // Skip all integration rules
      }
    }
  });
}
```
</Code>

Alternatively, you can skip only specific rules by providing the rule IDs as an array instead of `'*'`. The rule ID is available in the integration webhook envelope's `ruleId` field, or you can find it in your Ably [dashboard](https://ably.com/dashboard) under Integrations.

## Complete example: AI assistant integration <a id="example"/>

The following example demonstrates a complete bidirectional integration where messages are processed by an AI assistant and responses are sent back to the chat.

### Step 1: Client sends message with metadata

<Code>
```javascript
// Client application
await room.messages.send({
  text: '@bot translate "Hello!"',
  metadata: {
    intent: 'translate',
    targetLanguage: 'fr'
  }
});
```
</Code>

### Step 2: Integration rule forwards to webhook

Configure an integration rule in your dashboard:
- Channel filter: `^chat:.*` (matches all chat rooms)
- Event type: `channel.message`
- Endpoint: `https://your-domain.com/webhook`

### Step 3: Webhook processes and responds

<Code>
```javascript
const express = require('express');
const Ably = require('ably');

const app = express();
app.use(express.json());

app.post('/webhook', async (req, res) => {
  const envelope = req.body;

  // Decode messages
  const messages = Ably.Realtime.Message.fromEncodedArray(envelope.messages);

  for (const msg of messages) {
    const text = msg.data?.text;
    const metadata = msg.data?.metadata || {};
    const roomName = envelope.channel.replace('::$chat', '');

    // Process based on metadata intent
    if (metadata.intent === 'translate') {
      const translation = await translateText(text, metadata.targetLanguage);
      await sendResponseToChat(roomName, `Translation: ${translation}`);
    }
  }

  res.status(200).send('OK');
});

async function translateText(text, targetLang) {
  // Call your translation service
  return `[Translated to ${targetLang}]: ${text}`;
}

async function sendResponseToChat(roomName, responseText) {
  const { ChatClient } = require('@ably/chat');
  const chatClient = new ChatClient({ key: process.env.ABLY_API_KEY });

  const room = await chatClient.rooms.get(roomName);

  await room.messages.send({
    text: responseText
  }, {
    extras: {
      privileged: {
        skipRule: '*' // Prevent infinite loop
      }
    }
  });
}

app.listen(3000);
```
</Code>

### Step 4: Clients receive the response

All clients subscribed to the room receive the AI assistant's response in real-time:

<Code>
```javascript
room.messages.subscribe((event) => {
  console.log('Received:', event.message.text);
  // Output: "Translation: [Translated to fr]: Bonjour!"
});
```
</Code>

## Key considerations <a id="key-considerations"/>

Consider the following when integrating external systems with Ably Chat:

* **Avoiding infinite loops:** Always use the [skip integrations flag](#responding) when responding back to chat to prevent your response from triggering the integration again
* **Scale and reliability:** Different integration methods offer different reliability guarantees. See [choosing an integration method](#implementation-options) for guidance
* **External system limitations:** Your external service may have rate limits, processing constraints, or availability issues. Implement retry logic, circuit breakers, and caching to handle these limitations gracefully
* **Cost optimization:** Only process messages that require processing. Use channel filters and metadata/headers to route messages efficiently
* **Security:** Always validate and sanitize client-provided metadata before using it in your integration logic

## Next steps <a id="next-steps"/>

Explore related documentation to deepen your integration knowledge:

* [Extract messages via integrations](/docs/chat/rooms/message-extraction) - Complete technical guide for setting up webhooks, queues, and streaming
* [Chat integrations](/docs/chat/integrations) - Technical reference for Chat message structure
* [Platform Integrations](/docs/platform/integrations) - Detailed setup for all integration types
* [Export Chat Data](/docs/guides/chat/export-chat) - Guide for storing chat messages long-term
* [Chat SDK documentation](/docs/chat) - Comprehensive guide to Ably Chat features
* [Chat Moderation](/docs/chat/moderation) - Filter and moderate chat content

For custom integration requirements or questions, [contact Ably support](https://ably.com/support).
